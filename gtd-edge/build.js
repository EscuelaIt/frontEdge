System.register('componentes/base/toolbar/toolbar.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2'], function (_export) {
    'use strict';

    var angular, angularMaterial, raiz, nombreComponente;
    return {
        setters: [function (_npmAngular150Rc1) {
            angular = _npmAngular150Rc1;
        }, function (_npmAngularMaterial102) {
            angularMaterial = _npmAngularMaterial102;
        }],
        execute: function () {
            raiz = "./componentes/base/";
            nombreComponente = 'toolbar';

            angular.module(nombreComponente, ['ngMaterial']).component(nombreComponente, {
                templateUrl: '' + raiz + nombreComponente + '/' + nombreComponente + '.html'
            });

            _export('default', nombreComponente);
        }
    };
});
System.register('componentes/base/sidenav/sidenav.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2'], function (_export) {
    'use strict';

    var angular, angularMaterial, raiz, nombreComponente;
    return {
        setters: [function (_npmAngular150Rc1) {
            angular = _npmAngular150Rc1;
        }, function (_npmAngularMaterial102) {
            angularMaterial = _npmAngularMaterial102;
        }],
        execute: function () {
            raiz = "./componentes/base/";
            nombreComponente = 'sidenav';

            angular.module(nombreComponente, ['ngMaterial']).component(nombreComponente, {
                templateUrl: '' + raiz + nombreComponente + '/' + nombreComponente + '.html'
            });

            _export('default', nombreComponente);
        }
    };
});
System.register('componentes/base/fab/fab.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2'], function (_export) {
    'use strict';

    var angular, angularMaterial, raiz, nombreComponente;
    return {
        setters: [function (_npmAngular150Rc1) {
            angular = _npmAngular150Rc1;
        }, function (_npmAngularMaterial102) {
            angularMaterial = _npmAngularMaterial102;
        }],
        execute: function () {
            raiz = "./componentes/base/";
            nombreComponente = 'fab';

            angular.module(nombreComponente, ['ngMaterial']).component(nombreComponente, {
                templateUrl: '' + raiz + nombreComponente + '/' + nombreComponente + '.html'
            });

            _export('default', nombreComponente);
        }
    };
});
System.register('componentes/base/anuncio/anuncio.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2'], function (_export) {
  'use strict';

  var angular, angularMaterial, raiz, nombreComponente;
  return {
    setters: [function (_npmAngular150Rc1) {
      angular = _npmAngular150Rc1;
    }, function (_npmAngularMaterial102) {
      angularMaterial = _npmAngularMaterial102;
    }],
    execute: function () {
      raiz = "./componentes/base/";
      nombreComponente = 'anuncio';

      angular.module(nombreComponente, ['ngMaterial']).directive(nombreComponente, function () {
        return {
          restrict: 'E',
          transclude: { titulo: 'titulo', texto: '?texto' },
          templateUrl: '' + raiz + nombreComponente + '/' + nombreComponente + '.html'
        };
      });

      _export('default', nombreComponente);
    }
  };
});
System.register('componentes/base/base.js', ['npm:angular@1.5.0-rc.1', 'componentes/base/toolbar/toolbar.js', 'componentes/base/sidenav/sidenav.js', 'componentes/base/fab/fab.js', 'componentes/base/anuncio/anuncio.js'], function (_export) {
  'use strict';

  var angular, toolbar, sidenav, fab, anuncio, nombreComponente;
  return {
    setters: [function (_npmAngular150Rc1) {
      angular = _npmAngular150Rc1;
    }, function (_componentesBaseToolbarToolbarJs) {
      toolbar = _componentesBaseToolbarToolbarJs['default'];
    }, function (_componentesBaseSidenavSidenavJs) {
      sidenav = _componentesBaseSidenavSidenavJs['default'];
    }, function (_componentesBaseFabFabJs) {
      fab = _componentesBaseFabFabJs['default'];
    }, function (_componentesBaseAnuncioAnuncioJs) {
      anuncio = _componentesBaseAnuncioAnuncioJs['default'];
    }],
    execute: function () {
      nombreComponente = 'base';

      angular.module(nombreComponente, [toolbar, sidenav, fab, anuncio]);

      _export('default', nombreComponente);
    }
  };
});
System.register('componentes/portada/lista-tareas/fila-tarea/fila-tarea.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2'], function (_export) {
  'use strict';

  var angular, angularMaterial, raiz, nombreComponente, nombreFichero;
  return {
    setters: [function (_npmAngular150Rc1) {
      angular = _npmAngular150Rc1;
    }, function (_npmAngularMaterial102) {
      angularMaterial = _npmAngularMaterial102;
    }],
    execute: function () {
      raiz = "./componentes/portada/lista-tareas/";
      nombreComponente = 'filaTarea';
      nombreFichero = 'fila-tarea';

      angular.module(nombreComponente, ['ngMaterial']).component(nombreComponente, {
        templateUrl: '' + raiz + nombreFichero + '/' + nombreFichero + '.html',
        bindings: { tarea: '=' }
      });

      _export('default', nombreComponente);
    }
  };
});
System.register("componentes/portada/lista-tareas/lista-tareas-ctrl.js", ["npm:babel-runtime@5.8.35/helpers/class-call-check"], function (_export) {
  var _classCallCheck, listaTareasCtrl1, listaTareasCtrl;

  return {
    setters: [function (_npmBabelRuntime5835HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5835HelpersClassCallCheck["default"];
    }],
    execute: function () {
      "use strict";

      listaTareasCtrl1 = function listaTareasCtrl1(servicioTareas) {
        this.tareas = servicioTareas.tareas;
      };

      listaTareasCtrl = function listaTareasCtrl(servicioTareas) {
        _classCallCheck(this, listaTareasCtrl);

        this.tareas = servicioTareas.tareas;
      };

      _export("default", listaTareasCtrl);
    }
  };
});
System.register('servicioTareas.js', ['npm:angular@1.5.0-rc.1'], function (_export) {
  'use strict';

  var angular, nombreServicio;

  function funcionTareas() {
    var _this = this;

    this.tareas = [];
    this.tareasId = 0;

    this.tareasIniciales = function () {
      _this.tareas = [{ id: 1, titulo: 'tarea inicial', estado: 'inbox' }, { id: 2, titulo: 'tarea programada', estado: 'scheduled', fecha: new Date() }, { id: 3, titulo: 'tarea ya hecha', estado: 'done' }];
      _this.tareasId = 3;
    };

    this.obtenerTarea = function (tareaId) {
      return tareaId == 0 ? { id: 0, estado: 'add' } : _this.tareas.find(function (tarea) {
        return tarea.id == tareaId;
      });
    };
    this.guardarTarea = function (tarea) {
      if (tarea.id == 0) {
        _this.tareasId++;
        tarea.id = _this.tareasId;
        tarea.estado = 'inbox';
        _this.tareas.push(tarea);
      } else {
        _this.cambiarTarea(tarea);
      }
    };
    this.borrarTarea = function (tareaId) {
      var tareaIndex = _this.tareas.findIndex(function (tarea) {
        return tarea.id == tareaId;
      });
      _this.tareas.splice(tareaIndex, 1);
    };

    this.cambiarTarea = function (tareaCambiada) {
      var tareaActual = _this.tareas.find(function (tarea) {
        return tarea.id == tareaCambiada.id;
      });
      tareaActual = tareaCambiada;
    };

    this.tareasIniciales();
  }

  return {
    setters: [function (_npmAngular150Rc1) {
      angular = _npmAngular150Rc1;
    }],
    execute: function () {
      nombreServicio = 'servicioTareas';
      angular.module(nombreServicio, []).service(nombreServicio, funcionTareas);

      _export('default', nombreServicio);
    }
  };
});
System.register('componentes/portada/lista-tareas/lista-tareas.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2', 'componentes/portada/lista-tareas/fila-tarea/fila-tarea.js', 'componentes/portada/lista-tareas/lista-tareas-ctrl.js', 'servicioTareas.js'], function (_export) {
    'use strict';

    var angular, angularMaterial, filaTarea, listaTareasCtrl, moduloServicioTareas, raiz, nombreComponente, nombreFichero;
    return {
        setters: [function (_npmAngular150Rc1) {
            angular = _npmAngular150Rc1;
        }, function (_npmAngularMaterial102) {
            angularMaterial = _npmAngularMaterial102;
        }, function (_componentesPortadaListaTareasFilaTareaFilaTareaJs) {
            filaTarea = _componentesPortadaListaTareasFilaTareaFilaTareaJs['default'];
        }, function (_componentesPortadaListaTareasListaTareasCtrlJs) {
            listaTareasCtrl = _componentesPortadaListaTareasListaTareasCtrlJs['default'];
        }, function (_servicioTareasJs) {
            moduloServicioTareas = _servicioTareasJs['default'];
        }],
        execute: function () {
            raiz = "./componentes/portada/";
            nombreComponente = 'listaTareas';
            nombreFichero = 'lista-tareas';

            angular.module(nombreComponente, ['ngMaterial', filaTarea, moduloServicioTareas]).component(nombreComponente, {
                templateUrl: '' + raiz + nombreFichero + '/' + nombreFichero + '.html',
                /*controller : function(servicioTareas){
                    this.tareas = servicioTareas.tareas
                },*/
                controller: listaTareasCtrl
            });

            _export('default', nombreComponente);
        }
    };
});
System.register('componentes/portada/portada.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-ui-router@1.0.0-alpha0', 'componentes/portada/lista-tareas/lista-tareas.js'], function (_export) {
    'use strict';

    var angular, angularUiRouter, listaTareas, nombreComponente, configurarEstado;
    return {
        setters: [function (_npmAngular150Rc1) {
            angular = _npmAngular150Rc1;
        }, function (_npmAngularUiRouter100Alpha0) {
            angularUiRouter = _npmAngularUiRouter100Alpha0;
        }, function (_componentesPortadaListaTareasListaTareasJs) {
            listaTareas = _componentesPortadaListaTareasListaTareasJs['default'];
        }],
        execute: function () {
            nombreComponente = 'portada';

            configurarEstado = function configurarEstado($stateProvider) {
                $stateProvider.state(nombreComponente, {
                    url: '/',
                    template: '<lista-tareas></lista-tareas>'
                });
            };

            angular.module(nombreComponente, ['ui.router', listaTareas]).config(configurarEstado);

            _export('default', nombreComponente);
        }
    };
});
System.registerDynamic("npm:core-js@1.2.6/library/modules/$", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/define-property", ["npm:core-js@1.2.6/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/define-property", ["npm:core-js@1.2.6/library/fn/object/define-property"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/define-property'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/create-class", ["npm:babel-runtime@5.8.35/core-js/object/define-property"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('npm:babel-runtime@5.8.35/core-js/object/define-property')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/class-call-check", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("componentes/tarea/tarea-ctrl.js", ["npm:babel-runtime@5.8.35/helpers/create-class", "npm:babel-runtime@5.8.35/helpers/class-call-check"], function (_export) {
  var _createClass, _classCallCheck, tareaCtrl;

  return {
    setters: [function (_npmBabelRuntime5835HelpersCreateClass) {
      _createClass = _npmBabelRuntime5835HelpersCreateClass["default"];
    }, function (_npmBabelRuntime5835HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5835HelpersClassCallCheck["default"];
    }],
    execute: function () {
      "use strict";

      tareaCtrl = (function () {
        function tareaCtrl(servicioTareas, $stateParams, $state, $mdToast) {
          var _this = this;

          _classCallCheck(this, tareaCtrl);

          this.servicioTareas = servicioTareas;
          this.$stateParams = $stateParams;
          this.$state = $state;
          this.$mdToast = $mdToast;
          this.tareaId = $stateParams.tareaId;
          this.tarea = servicioTareas.obtenerTarea(this.tareaId);
          this.guardar = function () {
            servicioTareas.guardarTarea(_this.tarea);
            $mdToast.show($mdToast.simple().content("Tarea guadada").hideDelay(3000));
            $state.go('portada');
          };
        }

        _createClass(tareaCtrl, [{
          key: "borrar",
          value: function borrar() {
            this.servicioTareas.borrarTarea(this.tareaId);
            this.$mdToast.show(this.$mdToast.simple().content("Tarea borrada").hideDelay(3000));
            this.$state.go('portada');
          }
        }]);

        return tareaCtrl;
      })();

      _export("default", tareaCtrl);
    }
  };
});
System.register('componentes/tarea/tarea.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2', 'npm:angular-ui-router@1.0.0-alpha0', 'componentes/tarea/tarea-ctrl.js'], function (_export) {
  'use strict';

  var angular, angularMaterial, angularUiRouter, tareaCtrl, raiz, nombreComponente, configurarEstado;
  return {
    setters: [function (_npmAngular150Rc1) {
      angular = _npmAngular150Rc1;
    }, function (_npmAngularMaterial102) {
      angularMaterial = _npmAngularMaterial102;
    }, function (_npmAngularUiRouter100Alpha0) {
      angularUiRouter = _npmAngularUiRouter100Alpha0;
    }, function (_componentesTareaTareaCtrlJs) {
      tareaCtrl = _componentesTareaTareaCtrlJs['default'];
    }],
    execute: function () {
      raiz = "./componentes/";
      nombreComponente = 'tarea';

      configurarEstado = function configurarEstado($stateProvider) {
        $stateProvider.state(nombreComponente, {
          url: '/' + nombreComponente + '/:tareaId',
          template: '<' + nombreComponente + '></' + nombreComponente + '>'
        });
      };

      angular.module(nombreComponente, ['ngMaterial', 'ui.router']).component(nombreComponente, {
        templateUrl: '' + raiz + nombreComponente + '/' + nombreComponente + '.html',
        controller: tareaCtrl
      }).config(configurarEstado);

      _export('default', nombreComponente);
    }
  };
});
System.register('componentes/configuracion/configuracion.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2', 'npm:angular-ui-router@1.0.0-alpha0'], function (_export) {
    'use strict';

    var angular, angularMaterial, angularUiRouter, raiz, nombreComponente, configurarEstado;
    return {
        setters: [function (_npmAngular150Rc1) {
            angular = _npmAngular150Rc1;
        }, function (_npmAngularMaterial102) {
            angularMaterial = _npmAngularMaterial102;
        }, function (_npmAngularUiRouter100Alpha0) {
            angularUiRouter = _npmAngularUiRouter100Alpha0;
        }],
        execute: function () {
            raiz = "./componentes/";
            nombreComponente = 'configuracion';

            configurarEstado = function configurarEstado($stateProvider) {
                $stateProvider.state(nombreComponente, {
                    url: '/' + nombreComponente,
                    template: '<' + nombreComponente + '></' + nombreComponente + '>'
                });
            };

            angular.module(nombreComponente, ['ngMaterial', 'ui.router']).component(nombreComponente, {
                templateUrl: '' + raiz + nombreComponente + '/' + nombreComponente + '.html'
            }).config(configurarEstado);

            _export('default', nombreComponente);
        }
    };
});
System.registerDynamic("npm:angular@1.5.0-rc.1/angular", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.5.0-rc.1/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      function isArrayBuffer(obj) {
        return toString.call(obj) === '[object ArrayBuffer]';
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(","),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var result,
              key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination = copyType(source);
          if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
          switch (toString.call(source)) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
              return new source.constructor(copyElement(source.buffer));
            case '[object ArrayBuffer]':
              if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
              }
              return source.slice(0);
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
              return new source.constructor(source.valueOf());
            case '[object RegExp]':
              var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              re.lastIndex = source.lastIndex;
              return re;
          }
          if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
          }
        }
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2))
                return false;
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key]))
                    return false;
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2))
                return false;
              return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              return isRegExp(o2) ? o1.toString() == o2.toString() : false;
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                  continue;
                if (!equals(o1[key], o2[key]))
                  return false;
                keySet[key] = true;
              }
              for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (typeof obj === 'undefined')
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.5.0-rc.1',
        major: 1,
        minor: 5,
        dot: 0,
        codeName: 'quantum-fermentation'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteCleanData(nodes) {
        for (var i = 0,
            ii = nodes.length; i < ii; i++) {
          jqLiteRemoveData(nodes[i]);
        }
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      var jqLiteContains = Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          wrapNode = jqLite(wrapNode).eq(0).clone()[0];
          var parent = element.parentNode;
          if (parent) {
            parent.replaceChild(wrapNode, element);
          }
          wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var ARROW_ARG = /^([^\(]+?)=>/;
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function extractArgs(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
      }
      function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              argDecl = extractArgs(fn);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }),
            instanceInjector = protoInstanceInjector;
        providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function injectionArgs(fn, locals, serviceName) {
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0,
                length = $inject.length; i < length; i++) {
              var key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
          }
          function isClass(func) {
            if (msie <= 11) {
              return false;
            }
            return typeof func === 'function' && /^(?:class\s|constructor\()/.test(Function.prototype.toString.call(func));
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
              fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
              return fn.apply(self, args);
            } else {
              args.unshift(null);
              return new (Function.prototype.bind.apply(fn, args));
            }
          }
          function instantiate(Type, locals, serviceName) {
            var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args));
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateJsProvider = function() {
        this.$get = function() {};
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              var runner = new $$AnimateRunner();
              runner.complete();
              return runner;
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = ['$$rAF', function($$rAF) {
          var waitQueue = [];
          function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
              return;
            $$rAF(function() {
              for (var i = 0; i < waitQueue.length; i++) {
                waitQueue[i]();
              }
              waitQueue = [];
            });
          }
          return function() {
            var passed = false;
            waitForTick(function() {
              passed = true;
            });
            return function(callback) {
              passed ? callback() : waitForTick(callback);
            };
          };
        }];
      };
      var $$AnimateRunnerFactoryProvider = function() {
        this.$get = ['$q', '$sniffer', '$$animateAsyncRun', function($q, $sniffer, $$animateAsyncRun) {
          var INITIAL_STATE = 0;
          var DONE_PENDING_STATE = 1;
          var DONE_COMPLETE_STATE = 2;
          AnimateRunner.chain = function(chain, callback) {
            var index = 0;
            next();
            function next() {
              if (index === chain.length) {
                callback(true);
                return;
              }
              chain[index](function(response) {
                if (response === false) {
                  callback(false);
                  return;
                }
                index++;
                next();
              });
            }
          };
          AnimateRunner.all = function(runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function(runner) {
              runner.done(onProgress);
            });
            function onProgress(response) {
              status = status && response;
              if (++count === runners.length) {
                callback(status);
              }
            }
          };
          function AnimateRunner(host) {
            this.setHost(host);
            this._doneCallbacks = [];
            this._runInAnimationFrame = $$animateAsyncRun();
            this._state = 0;
          }
          AnimateRunner.prototype = {
            setHost: function(host) {
              this.host = host || {};
            },
            done: function(fn) {
              if (this._state === DONE_COMPLETE_STATE) {
                fn();
              } else {
                this._doneCallbacks.push(fn);
              }
            },
            progress: noop,
            getPromise: function() {
              if (!this.promise) {
                var self = this;
                this.promise = $q(function(resolve, reject) {
                  self.done(function(status) {
                    status === false ? reject() : resolve();
                  });
                });
              }
              return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
              return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function(handler) {
              return this.getPromise()['catch'](handler);
            },
            'finally': function(handler) {
              return this.getPromise()['finally'](handler);
            },
            pause: function() {
              if (this.host.pause) {
                this.host.pause();
              }
            },
            resume: function() {
              if (this.host.resume) {
                this.host.resume();
              }
            },
            end: function() {
              if (this.host.end) {
                this.host.end();
              }
              this._resolve(true);
            },
            cancel: function() {
              if (this.host.cancel) {
                this.host.cancel();
              }
              this._resolve(false);
            },
            complete: function(response) {
              var self = this;
              if (self._state === INITIAL_STATE) {
                self._state = DONE_PENDING_STATE;
                self._runInAnimationFrame(function() {
                  self._resolve(response);
                });
              }
            },
            _resolve: function(response) {
              if (this._state !== DONE_COMPLETE_STATE) {
                forEach(this._doneCallbacks, function(fn) {
                  fn(response);
                });
                this._doneCallbacks.length = 0;
                this._state = DONE_COMPLETE_STATE;
              }
            }
          };
          return AnimateRunner;
        }];
      };
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
          return function(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = copy(options);
            }
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new $$AnimateRunner();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                applyAnimationContents();
                if (!closed) {
                  runner.complete();
                }
                closed = true;
              });
              return runner;
            }
            function applyAnimationContents() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || pendingLocation) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.component = function registerComponent(name, options) {
          var controller = options.controller || function() {};
          function factory($injector) {
            function makeInjectable(fn) {
              if (isFunction(fn) || isArray(fn)) {
                return function(tElement, tAttrs) {
                  return $injector.invoke(fn, this, {
                    $element: tElement,
                    $attrs: tAttrs
                  });
                };
              } else {
                return fn;
              }
            }
            var template = (!options.template && !options.templateUrl ? '' : options.template);
            return {
              controller: controller,
              controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
              template: makeInjectable(template),
              templateUrl: makeInjectable(options.templateUrl),
              transclude: options.transclude,
              scope: {},
              bindToController: options.bindings || {},
              restrict: 'E'
            };
          }
          forEach(options, function(val, key) {
            if (key.charAt(0) === '$') {
              factory[key] = val;
            }
          });
          factory.$inject = ['$injector'];
          return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
          var SIMPLE_ATTR_NAME = /^\w/;
          var specialAttrHolder = document.createElement('div');
          var Attributes = function(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          };
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  if (SIMPLE_ATTR_NAME.test(attrName)) {
                    this.$$element.attr(attrName, value);
                  } else {
                    setSpecialAttr(this.$$element[0], attrName, value);
                  }
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = "<span " + attrName + ">";
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
          }
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            forEach($compileNodes, function(node, index) {
              if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
              }
            });
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            };
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
              } else {
                boundSlots[slotName] = null;
              }
            }
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (eager) {
              return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            var compiled;
            return function() {
              if (!compiled) {
                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                $compileNodes = transcludeFn = previousCompileContext = null;
              }
              return compiled.apply(this, arguments);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                didScanForMultipleTransclusion = false,
                mightHaveMultipleTransclusionError = false,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                var candidateDirective;
                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                  if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }
                didScanForMultipleTransclusion = true;
              }
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  var slots = createMap();
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  if (isObject(directiveValue)) {
                    $template = [];
                    var slotMap = createMap();
                    var filledSlots = createMap();
                    forEach(directiveValue, function(elementSelector, slotName) {
                      var optional = (elementSelector.charAt(0) === '?');
                      elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                      slotMap[elementSelector] = slotName;
                      slots[slotName] = null;
                      filledSlots[slotName] = optional;
                    });
                    forEach($compileNode.contents(), function(node) {
                      var slotName = slotMap[directiveNormalize(nodeName_(node))];
                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] = slots[slotName] || [];
                        slots[slotName].push(node);
                      } else {
                        $template.push(node);
                      }
                    });
                    forEach(filledSlots, function(filled, slotName) {
                      if (!filled) {
                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                      }
                    });
                    for (var slotName in slots) {
                      if (slots[slotName]) {
                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                      }
                    }
                  }
                  $compileNode.empty();
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                  childTranscludeFn.$$slots = slots;
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function getControllers(directiveName, $__require, $element, elementControllers) {
              var value;
              if (isString($__require)) {
                var match = $__require.match(REQUIRE_PREFIX_REGEXP);
                var name = $__require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                  $element = $element.parent();
                } else {
                  value = elementControllers && elementControllers[name];
                  value = value && value.instance;
                }
                if (!value) {
                  var dataName = '$' + name + 'Controller';
                  value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                  throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                }
              } else if (isArray($__require)) {
                value = [];
                for (var i = 0,
                    ii = $__require.length; i < ii; i++) {
                  value[i] = getControllers(directiveName, $__require[i], $element, elementControllers);
                }
              }
              return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
              var elementControllers = createMap();
              for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                  $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                  $element: $element,
                  $attrs: attrs,
                  $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                if (!hasElementTranscludeDirective) {
                  $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
              }
              return elementControllers;
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var i,
                  ii,
                  linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  removeScopeBindingWatches,
                  removeControllerBindingWatches;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
                transcludeFn.isSlotFilled = function(slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                removeScopeBindingWatches = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (removeScopeBindingWatches) {
                  isolateScope.$on('$destroy', removeScopeBindingWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                  removeControllerBindingWatches && removeControllerBindingWatches();
                  removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
              }
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                if (slotName) {
                  var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                  if (slotTranscludeFn) {
                    return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                  } else if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                  }
                } else {
                  return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                }
              }
            }
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
              fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
              delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            forEach(bindings, function(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value)) {
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  if (isString(attrs[attrName])) {
                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                  }
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  var removeWatch;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            return removeWatchCollection.length && function removeWatches() {
              for (var i = 0,
                  ii = removeWatchCollection.length; i < ii; ++i) {
                removeWatchCollection[i]();
              }
            };
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v, k) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString(requestConfig.url)) {
              throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch;
            return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            }, listener, objectEquality);
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
              var constantInterp;
              if (!mustHaveExpression) {
                var unescapedText = unescapeText(text);
                constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
              }
              return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function($rootScope, $window, $q, $$q, $browser) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
              if (skipApply) {
                $browser.defer(callback);
              } else {
                $rootScope.$evalAsync(callback);
              }
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
              if (!hasParams) {
                fn(iteration);
              } else {
                fn.apply(null, args);
              }
            }
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = beginsWith(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name) {
        return name + '';
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.LocalsExpression = 'LocalsExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.constants.hasOwnProperty(this.peek().text)) {
            primary = copy(this.constants[this.consume().text]);
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        constants: {
          'true': {
            type: AST.Literal,
            value: true
          },
          'false': {
            type: AST.Literal,
            value: false
          },
          'null': {
            type: AST.Literal,
            value: null
          },
          'undefined': {
            type: AST.Literal,
            value: undefined
          },
          'this': {type: AST.ThisExpression},
          '$locals': {type: AST.LocalsExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.LocalsExpression:
              this.assign(intoId, 'l');
              recursionFn('l');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ')');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.LocalsExpression:
              return function(scope, locals) {
                return context ? {value: locals} : locals;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign, inputs) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1) {
                ensureSafeAssignContext(lhs);
                if (lhs && !(lhs[rhs])) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
              ensureSafeAssignContext(lhs);
              if (lhs && !(lhs[right])) {
                lhs[right] = {};
              }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true
              };
          return function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return addInterceptor(noop, interceptorFn);
            }
          };
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            }, listener, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        var defer = function() {
          var d = new Deferred();
          d.resolve = simpleBind(d, d.resolve);
          d.reject = simpleBind(d, d.reject);
          d.notify = simpleBind(d, d.notify);
          return d;
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then;
            var that = this;
            var done = false;
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              rejectPromise(e);
              exceptionHandler(e);
            }
            function resolvePromise(val) {
              if (done)
                return;
              done = true;
              that.$$resolve(val);
            }
            function rejectPromise(val) {
              if (done)
                return;
              done = true;
              that.$$reject(val);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$exceptionHandler', '$parse', '$browser', function($exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  logMsg,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            watch.fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: expr,
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $compileMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
          if (val) {
            httpOptions = val;
            return this;
          }
          return httpOptions;
        };
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            return $http.get(tpl, extend({
              cache: $templateCache,
              transformResponse: transformResponse
            }, httpOptions))['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      var MAX_DIGITS = 22;
      var DECIMAL_SEP = '.';
      var ZERO_CHAR = '0';
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      function parse(numStr) {
        var exponent = 0,
            digits,
            numberOfIntegerDigits;
        var i,
            j,
            zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
        }
        if ((i = numStr.search(/e/i)) > 0) {
          if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
          numberOfIntegerDigits += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
          numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++)
          ;
        if (i == (zeros = numStr.length)) {
          digits = [0];
          numberOfIntegerDigits = 1;
        } else {
          zeros--;
          while (numStr.charAt(zeros) == ZERO_CHAR)
            zeros--;
          numberOfIntegerDigits -= i;
          digits = [];
          for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
          }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = numberOfIntegerDigits - 1;
          numberOfIntegerDigits = 1;
        }
        return {
          d: digits,
          e: exponent,
          i: numberOfIntegerDigits
        };
      }
      function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
          digits.splice(roundAt);
        } else {
          parsedNumber.i = 1;
          digits.length = roundAt = fractionSize + 1;
          for (var i = 0; i < roundAt; i++)
            digits[i] = 0;
        }
        if (digit >= 5)
          digits[roundAt - 1]++;
        for (; fractionLen < fractionSize; fractionLen++)
          digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
          d = d + carry;
          digits[i] = d % 10;
          return Math.floor(d / 10);
        }, 0);
        if (carry) {
          digits.unshift(carry);
          parsedNumber.i++;
        }
      }
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number))
          return '';
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + '',
            formattedText = '',
            parsedNumber;
        if (isInfinity) {
          formattedText = '\u221e';
        } else {
          parsedNumber = parse(numStr);
          roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
          var digits = parsedNumber.d;
          var integerLen = parsedNumber.i;
          var exponent = parsedNumber.e;
          var decimals = [];
          isZero = digits.reduce(function(isZero, d) {
            return isZero && !d;
          }, true);
          while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
          }
          if (integerLen > 0) {
            decimals = digits.splice(integerLen);
          } else {
            decimals = digits;
            digits = [0];
          }
          var groups = [];
          if (digits.length > pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize).join(''));
          }
          while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize).join(''));
          }
          if (digits.length) {
            groups.unshift(digits.join(''));
          }
          formattedText = groups.join(groupSep);
          if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
          }
          if (exponent) {
            formattedText += 'e+' + exponent;
          }
        }
        if (number < 0 && !isZero) {
          return pattern.negPre + formattedText + pattern.negSuf;
        } else {
          return pattern.posPre + formattedText + pattern.posSuf;
        }
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = ZERO_CHAR + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim);
        };
      }
      function dateStrGetter(name, shortForm) {
        return function(date, formats) {
          var value = date['get' + name]();
          var get = uppercase(shortForm ? ('SHORT' + name) : name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (array == null)
            return array;
          if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
          }
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function(data) {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var timeout;
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', function($animate) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (toString.call($element[0]).match(/SVG/)) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending',
          EMPTY_CLASS = 'ng-empty',
          NOT_EMPTY_CLASS = 'ng-not-empty';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
              } else {
                parsedNgModelAssign($scope, ctrl.$modelValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
          if (ctrl.$isEmpty(value)) {
            $animate.removeClass($element, NOT_EMPTY_CLASS);
            $animate.addClass($element, EMPTY_CLASS);
          } else {
            $animate.removeClass($element, EMPTY_CLASS);
            $animate.addClass($element, NOT_EMPTY_CLASS);
          }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function(error) {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$$updateEmptyClasses(viewValue);
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function(ev) {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(optionValues[key], key);
                var selectValue = getTrackByValueFn(optionValues[key], locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var selectCtrl = ctrls[0];
          var ngModelCtrl = ctrls[1];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option && !option.disabled) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                  option.element.setAttribute('selected', 'selected');
                }
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option && !option.disabled)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function addOrReuseElement(parent, current, type, templateElement) {
            var element;
            if (current && lowercase(current.nodeName) === type) {
              element = current;
            } else {
              element = templateElement.cloneNode(false);
              if (!current) {
                parent.appendChild(element);
              } else {
                parent.insertBefore(element, current);
              }
            }
            return element;
          }
          function removeExcessElements(current) {
            var next;
            while (current) {
              next = current.nextSibling;
              jqLiteRemove(current);
              current = next;
            }
          }
          function skipEmptyAndUnknownOptions(current) {
            var emptyOption_ = emptyOption && emptyOption[0];
            var unknownOption_ = unknownOption && unknownOption[0];
            if (emptyOption_ || unknownOption_) {
              while (current && (current === emptyOption_ || current === unknownOption_ || current.nodeType === NODE_TYPE_COMMENT || (nodeName_(current) === 'option' && current.value === ''))) {
                current = current.nextSibling;
              }
            }
            return current;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            options = ngOptions.getOptions();
            var groupMap = {};
            var currentElement = selectElement[0].firstChild;
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            currentElement = skipEmptyAndUnknownOptions(currentElement);
            options.items.forEach(function updateOption(option) {
              var group;
              var groupElement;
              var optionElement;
              if (isDefined(option.group)) {
                group = groupMap[option.group];
                if (!group) {
                  groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                  currentElement = groupElement.nextSibling;
                  groupElement.label = option.group;
                  group = groupMap[option.group] = {
                    groupElement: groupElement,
                    currentOptionElement: groupElement.firstChild
                  };
                }
                optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                updateOptionElement(option, optionElement);
                group.currentOptionElement = optionElement.nextSibling;
              } else {
                optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                updateOptionElement(option, optionElement);
                currentElement = optionElement.nextSibling;
              }
            });
            Object.keys(groupMap).forEach(function(key) {
              removeExcessElements(groupMap[key].currentOptionElement);
            });
            removeExcessElements(currentElement);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              var isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', 'ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, jqLite(previousNode));
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', function($animate) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeMinErr = minErr('ngTransclude');
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = '';
          }
          function ngTranscludeCloneAttachFn(clone) {
            if (clone.length) {
              $element.empty();
              $element.append(clone);
            }
          }
          if (!$transclude) {
            throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
          $transclude(ngTranscludeCloneAttachFn, null, slotName);
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        console.log('WARNING: Tried to load angular more than once.');
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "STANDALONEMONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular@1.5.0-rc.1/index", ["npm:angular@1.5.0-rc.1/angular"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:angular@1.5.0-rc.1/angular');
  module.exports = angular;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular@1.5.0-rc.1", ["npm:angular@1.5.0-rc.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular@1.5.0-rc.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-animate@1.5.0-rc.1/angular-animate", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    (function(window, angular, undefined) {
      'use strict';
      var noop = angular.noop;
      var copy = angular.copy;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var PREPARE_CLASS_SUFFIX = '-prepare';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      var ngMinErr = angular.$$minErr('ng');
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return [];
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationOptions(element, target, newOptions) {
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = [function() {
        return function(scope, element, attrs) {
          var val = attrs.ngAnimateChildren;
          if (angular.isString(val) && val.length === 0) {
            element.data(NG_ANIMATE_CHILDREN_DATA, true);
          } else {
            attrs.$observe('ngAnimateChildren', function(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            });
          }
        };
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(' '), onAnimationProgress);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(' '), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function() {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function() {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = ' ';
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          var keys = classString.split(ONE_SPACE);
          var map = Object.create(null);
          forEach(keys, function(key) {
            map[key] = true;
          });
          return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            var currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some(function(className) {
              return currentClassMap[className];
            });
          }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(options, and) {
          options = options || {};
          var a = (options.addClass || '').length > 0;
          var b = (options.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation.options);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          var nA = newAnimation.options.addClass;
          var nR = newAnimation.options.removeClass;
          var cA = currentAnimation.options.addClass;
          var cR = currentAnimation.options.removeClass;
          if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
            return false;
          }
          return (hasMatchingClasses(nA, cR)) || (hasMatchingClasses(nR, cA));
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationOptions(element, options) {
            return mergeAnimationOptions(element, options, {});
          }
          var contains = Node.prototype.contains || function(arg) {
            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
          };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          return {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
            },
            off: function(event, container, callback) {
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
              function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                  var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                  return !isMatch;
                });
              }
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            }
          };
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              close();
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationOptions(element, existingAnimation.options, options);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationOptions(element, options);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationOptions(element, options);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation.options);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails.options));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                  });
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
            var parentHost = element.data(NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            while (parentElement && parentElement.length) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              var parentNode = parentElement[0];
              if (parentNode.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentNode) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled = disabledElementsLookup.get(parentNode);
                if (parentElementDisabled === true && elementDisabled !== false) {
                  elementDisabled = true;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
                if (!rootElementDetected) {
                  parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);
                  if (parentHost) {
                    parentElement = parentHost;
                    rootElementDetected = true;
                  }
                }
              }
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              parentElement = parentElement.parent();
            }
            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                if (!$injector.has(driverName))
                  continue;
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                getRunner(element).setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
        return {
          restrict: 'A',
          transclude: 'element',
          terminal: true,
          priority: 600,
          link: function(scope, $element, attrs, ctrl, $transclude) {
            var previousElement,
                previousScope;
            scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function(element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            });
          }
        };
      }];
      angular.module('ngAnimate', []).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-animate@1.5.0-rc.1/index", ["npm:angular-animate@1.5.0-rc.1/angular-animate"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:angular-animate@1.5.0-rc.1/angular-animate');
  module.exports = 'ngAnimate';
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-animate@1.5.0-rc.1", ["npm:angular-animate@1.5.0-rc.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-animate@1.5.0-rc.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-aria@1.5.0-rc.1/angular-aria", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(window, angular, undefined) {
    'use strict';
    var ngAriaModule = angular.module('ngAria', ['ng']).provider('$aria', $AriaProvider);
    var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY'];
    var isNodeOneOf = function(elem, nodeTypeArray) {
      if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {
        return true;
      }
    };
    function $AriaProvider() {
      var config = {
        ariaHidden: true,
        ariaChecked: true,
        ariaDisabled: true,
        ariaRequired: true,
        ariaInvalid: true,
        ariaMultiline: true,
        ariaValue: true,
        tabindex: true,
        bindKeypress: true,
        bindRoleForClick: true
      };
      this.config = function(newConfig) {
        config = angular.extend(config, newConfig);
      };
      function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {
        return function(scope, elem, attr) {
          var ariaCamelName = attr.$normalize(ariaAttr);
          if (config[ariaCamelName] && !isNodeOneOf(elem, nodeBlackList) && !attr[ariaCamelName]) {
            scope.$watch(attr[attrName], function(boolVal) {
              boolVal = negate ? !boolVal : !!boolVal;
              elem.attr(ariaAttr, boolVal);
            });
          }
        };
      }
      this.$get = function() {
        return {
          config: function(key) {
            return config[key];
          },
          $$watchExpr: watchExpr
        };
      };
    }
    ngAriaModule.directive('ngShow', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);
    }]).directive('ngHide', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);
    }]).directive('ngModel', ['$aria', function($aria) {
      function shouldAttachAttr(attr, normalizedAttr, elem) {
        return $aria.config(normalizedAttr) && !elem.attr(attr);
      }
      function shouldAttachRole(role, elem) {
        return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');
      }
      function getShape(attr, elem) {
        var type = attr.type,
            role = attr.role;
        return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' : ((type || role) === 'radio' || role === 'menuitemradio') ? 'radio' : (type === 'range' || role === 'progressbar' || role === 'slider') ? 'range' : (type || role) === 'textbox' || elem[0].nodeName === 'TEXTAREA' ? 'multiline' : '';
      }
      return {
        restrict: 'A',
        require: '?ngModel',
        priority: 200,
        compile: function(elem, attr) {
          var shape = getShape(attr, elem);
          return {
            pre: function(scope, elem, attr, ngModel) {
              if (shape === 'checkbox' && attr.type !== 'checkbox') {
                ngModel.$isEmpty = function(value) {
                  return value === false;
                };
              }
            },
            post: function(scope, elem, attr, ngModel) {
              var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem) && !isNodeOneOf(elem, nodeBlackList);
              function ngAriaWatchModelValue() {
                return ngModel.$modelValue;
              }
              function getRadioReaction() {
                if (needsTabIndex) {
                  needsTabIndex = false;
                  return function ngAriaRadioReaction(newVal) {
                    var boolVal = (attr.value == ngModel.$viewValue);
                    elem.attr('aria-checked', boolVal);
                    elem.attr('tabindex', 0 - !boolVal);
                  };
                } else {
                  return function ngAriaRadioReaction(newVal) {
                    elem.attr('aria-checked', (attr.value == ngModel.$viewValue));
                  };
                }
              }
              function ngAriaCheckboxReaction() {
                elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));
              }
              switch (shape) {
                case 'radio':
                case 'checkbox':
                  if (shouldAttachRole(shape, elem)) {
                    elem.attr('role', shape);
                  }
                  if (shouldAttachAttr('aria-checked', 'ariaChecked', elem)) {
                    scope.$watch(ngAriaWatchModelValue, shape === 'radio' ? getRadioReaction() : ngAriaCheckboxReaction);
                  }
                  if (needsTabIndex) {
                    elem.attr('tabindex', 0);
                  }
                  break;
                case 'range':
                  if (shouldAttachRole(shape, elem)) {
                    elem.attr('role', 'slider');
                  }
                  if ($aria.config('ariaValue')) {
                    var needsAriaValuemin = !elem.attr('aria-valuemin') && (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin'));
                    var needsAriaValuemax = !elem.attr('aria-valuemax') && (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax'));
                    var needsAriaValuenow = !elem.attr('aria-valuenow');
                    if (needsAriaValuemin) {
                      attr.$observe('min', function ngAriaValueMinReaction(newVal) {
                        elem.attr('aria-valuemin', newVal);
                      });
                    }
                    if (needsAriaValuemax) {
                      attr.$observe('max', function ngAriaValueMinReaction(newVal) {
                        elem.attr('aria-valuemax', newVal);
                      });
                    }
                    if (needsAriaValuenow) {
                      scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                        elem.attr('aria-valuenow', newVal);
                      });
                    }
                  }
                  if (needsTabIndex) {
                    elem.attr('tabindex', 0);
                  }
                  break;
                case 'multiline':
                  if (shouldAttachAttr('aria-multiline', 'ariaMultiline', elem)) {
                    elem.attr('aria-multiline', true);
                  }
                  break;
              }
              if (ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem)) {
                scope.$watch(function ngAriaRequiredWatch() {
                  return ngModel.$error.required;
                }, function ngAriaRequiredReaction(newVal) {
                  elem.attr('aria-required', !!newVal);
                });
              }
              if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem)) {
                scope.$watch(function ngAriaInvalidWatch() {
                  return ngModel.$invalid;
                }, function ngAriaInvalidReaction(newVal) {
                  elem.attr('aria-invalid', !!newVal);
                });
              }
            }
          };
        }
      };
    }]).directive('ngDisabled', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngDisabled', 'aria-disabled', []);
    }]).directive('ngMessages', function() {
      return {
        restrict: 'A',
        require: '?ngMessages',
        link: function(scope, elem, attr, ngMessages) {
          if (!elem.attr('aria-live')) {
            elem.attr('aria-live', 'assertive');
          }
        }
      };
    }).directive('ngClick', ['$aria', '$parse', function($aria, $parse) {
      return {
        restrict: 'A',
        compile: function(elem, attr) {
          var fn = $parse(attr.ngClick, null, true);
          return function(scope, elem, attr) {
            if (!isNodeOneOf(elem, nodeBlackList)) {
              if ($aria.config('bindRoleForClick') && !elem.attr('role')) {
                elem.attr('role', 'button');
              }
              if ($aria.config('tabindex') && !elem.attr('tabindex')) {
                elem.attr('tabindex', 0);
              }
              if ($aria.config('bindKeypress') && !attr.ngKeypress) {
                elem.on('keypress', function(event) {
                  var keyCode = event.which || event.keyCode;
                  if (keyCode === 32 || keyCode === 13) {
                    scope.$apply(callback);
                  }
                  function callback() {
                    fn(scope, {$event: event});
                  }
                });
              }
            }
          };
        }
      };
    }]).directive('ngDblclick', ['$aria', function($aria) {
      return function(scope, elem, attr) {
        if ($aria.config('tabindex') && !elem.attr('tabindex') && !isNodeOneOf(elem, nodeBlackList)) {
          elem.attr('tabindex', 0);
        }
      };
    }]);
  })(window, window.angular);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-aria@1.5.0-rc.1/index", ["npm:angular-aria@1.5.0-rc.1/angular-aria"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:angular-aria@1.5.0-rc.1/angular-aria');
  module.exports = 'ngAria';
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-aria@1.5.0-rc.1", ["npm:angular-aria@1.5.0-rc.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-aria@1.5.0-rc.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-material@1.0.2/angular-material", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    (function(window, angular, undefined) {
      "use strict";
      (function() {
        "use strict";
        angular.module('ngMaterial', ["ng", "ngAnimate", "ngAria", "material.core", "material.core.gestures", "material.core.layout", "material.core.theming.palette", "material.core.theming", "material.core.animate", "material.components.autocomplete", "material.components.bottomSheet", "material.components.backdrop", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.chips", "material.components.content", "material.components.datepicker", "material.components.dialog", "material.components.divider", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.fabTrigger", "material.components.gridList", "material.components.icon", "material.components.input", "material.components.list", "material.components.menu", "material.components.menuBar", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.toast", "material.components.toolbar", "material.components.tooltip", "material.components.virtualRepeat", "material.components.whiteframe"]);
      })();
      (function() {
        "use strict";
        angular.module('material.core', ['ngAnimate', 'material.core.animate', 'material.core.layout', 'material.core.gestures', 'material.core.theming']).config(MdCoreConfigure).run(DetectNgTouch);
        function DetectNgTouch($log, $injector) {
          if ($injector.has('$swipe')) {
            var msg = "" + "You are using the ngTouch module. \n" + "Angular Material already has mobile click, tap, and swipe support... \n" + "ngTouch is not supported with Angular Material!";
            $log.warn(msg);
          }
        }
        DetectNgTouch.$inject = ["$log", "$injector"];
        function MdCoreConfigure($provide, $mdThemingProvider) {
          $provide.decorator('$$rAF', ["$delegate", rAFDecorator]);
          $mdThemingProvider.theme('default').primaryPalette('indigo').accentPalette('pink').warnPalette('deep-orange').backgroundPalette('grey');
        }
        MdCoreConfigure.$inject = ["$provide", "$mdThemingProvider"];
        function rAFDecorator($delegate) {
          $delegate.throttle = function(cb) {
            var queuedArgs,
                alreadyQueued,
                queueCb,
                context;
            return function debounced() {
              queuedArgs = arguments;
              context = this;
              queueCb = cb;
              if (!alreadyQueued) {
                alreadyQueued = true;
                $delegate(function() {
                  queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
                  alreadyQueued = false;
                });
              }
            };
          };
          return $delegate;
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdConstant', MdConstantFactory);
        function MdConstantFactory($sniffer) {
          var webkit = /webkit/i.test($sniffer.vendorPrefix);
          function vendorProperty(name) {
            return webkit ? ('webkit' + name.charAt(0).toUpperCase() + name.substring(1)) : name;
          }
          return {
            KEY_CODE: {
              COMMA: 188,
              ENTER: 13,
              ESCAPE: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT_ARROW: 37,
              UP_ARROW: 38,
              RIGHT_ARROW: 39,
              DOWN_ARROW: 40,
              TAB: 9,
              BACKSPACE: 8,
              DELETE: 46
            },
            CSS: {
              TRANSITIONEND: 'transitionend' + (webkit ? ' webkitTransitionEnd' : ''),
              ANIMATIONEND: 'animationend' + (webkit ? ' webkitAnimationEnd' : ''),
              TRANSFORM: vendorProperty('transform'),
              TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),
              TRANSITION: vendorProperty('transition'),
              TRANSITION_DURATION: vendorProperty('transitionDuration'),
              ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),
              ANIMATION_DURATION: vendorProperty('animationDuration'),
              ANIMATION_NAME: vendorProperty('animationName'),
              ANIMATION_TIMING: vendorProperty('animationTimingFunction'),
              ANIMATION_DIRECTION: vendorProperty('animationDirection')
            },
            MEDIA: {
              'xs': '(max-width: 599px)',
              'gt-xs': '(min-width: 600px)',
              'sm': '(min-width: 600px) and (max-width: 959px)',
              'gt-sm': '(min-width: 960px)',
              'md': '(min-width: 960px) and (max-width: 1279px)',
              'gt-md': '(min-width: 1280px)',
              'lg': '(min-width: 1280px) and (max-width: 1919px)',
              'gt-lg': '(min-width: 1920px)',
              'xl': '(min-width: 1920px)'
            },
            MEDIA_PRIORITY: ['xl', 'gt-lg', 'lg', 'gt-md', 'md', 'gt-sm', 'sm', 'gt-xs', 'xs']
          };
        }
        MdConstantFactory.$inject = ["$sniffer"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').config(["$provide", function($provide) {
          $provide.decorator('$mdUtil', ['$delegate', function($delegate) {
            $delegate.iterator = MdIterator;
            return $delegate;
          }]);
        }]);
        function MdIterator(items, reloop) {
          var trueFn = function() {
            return true;
          };
          if (items && !angular.isArray(items)) {
            items = Array.prototype.slice.call(items);
          }
          reloop = !!reloop;
          var _items = items || [];
          return {
            items: getItems,
            count: count,
            inRange: inRange,
            contains: contains,
            indexOf: indexOf,
            itemAt: itemAt,
            findBy: findBy,
            add: add,
            remove: remove,
            first: first,
            last: last,
            next: angular.bind(null, findSubsequentItem, false),
            previous: angular.bind(null, findSubsequentItem, true),
            hasPrevious: hasPrevious,
            hasNext: hasNext
          };
          function getItems() {
            return [].concat(_items);
          }
          function count() {
            return _items.length;
          }
          function inRange(index) {
            return _items.length && (index > -1) && (index < _items.length);
          }
          function hasNext(item) {
            return item ? inRange(indexOf(item) + 1) : false;
          }
          function hasPrevious(item) {
            return item ? inRange(indexOf(item) - 1) : false;
          }
          function itemAt(index) {
            return inRange(index) ? _items[index] : null;
          }
          function findBy(key, val) {
            return _items.filter(function(item) {
              return item[key] === val;
            });
          }
          function add(item, index) {
            if (!item)
              return -1;
            if (!angular.isNumber(index)) {
              index = _items.length;
            }
            _items.splice(index, 0, item);
            return indexOf(item);
          }
          function remove(item) {
            if (contains(item)) {
              _items.splice(indexOf(item), 1);
            }
          }
          function indexOf(item) {
            return _items.indexOf(item);
          }
          function contains(item) {
            return item && (indexOf(item) > -1);
          }
          function first() {
            return _items.length ? _items[0] : null;
          }
          function last() {
            return _items.length ? _items[_items.length - 1] : null;
          }
          function findSubsequentItem(backwards, item, validate, limit) {
            validate = validate || trueFn;
            var curIndex = indexOf(item);
            while (true) {
              if (!inRange(curIndex))
                return null;
              var nextIndex = curIndex + (backwards ? -1 : 1);
              var foundItem = null;
              if (inRange(nextIndex)) {
                foundItem = _items[nextIndex];
              } else if (reloop) {
                foundItem = backwards ? last() : first();
                nextIndex = indexOf(foundItem);
              }
              if ((foundItem === null) || (nextIndex === limit))
                return null;
              if (validate(foundItem))
                return foundItem;
              if (angular.isUndefined(limit))
                limit = nextIndex;
              curIndex = nextIndex;
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdMedia', mdMediaFactory);
        function mdMediaFactory($mdConstant, $rootScope, $window) {
          var queries = {};
          var mqls = {};
          var results = {};
          var normalizeCache = {};
          $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
          $mdMedia.getQuery = getQuery;
          $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;
          return $mdMedia;
          function $mdMedia(query) {
            var validated = queries[query];
            if (angular.isUndefined(validated)) {
              validated = queries[query] = validate(query);
            }
            var result = results[validated];
            if (angular.isUndefined(result)) {
              result = add(validated);
            }
            return result;
          }
          function validate(query) {
            return $mdConstant.MEDIA[query] || ((query.charAt(0) !== '(') ? ('(' + query + ')') : query);
          }
          function add(query) {
            var result = mqls[query];
            if (!result) {
              result = mqls[query] = $window.matchMedia(query);
            }
            result.addListener(onQueryChange);
            return (results[result.media] = !!result.matches);
          }
          function onQueryChange(query) {
            $rootScope.$evalAsync(function() {
              results[query.media] = !!query.matches;
            });
          }
          function getQuery(name) {
            return mqls[name];
          }
          function getResponsiveAttribute(attrs, attrName) {
            for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
              var mediaName = $mdConstant.MEDIA_PRIORITY[i];
              if (!mqls[queries[mediaName]].matches) {
                continue;
              }
              var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
              if (attrs[normalizedName]) {
                return attrs[normalizedName];
              }
            }
            return attrs[getNormalizedName(attrs, attrName)];
          }
          function watchResponsiveAttributes(attrNames, attrs, watchFn) {
            var unwatchFns = [];
            attrNames.forEach(function(attrName) {
              var normalizedName = getNormalizedName(attrs, attrName);
              if (angular.isDefined(attrs[normalizedName])) {
                unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
              }
              for (var mediaName in $mdConstant.MEDIA) {
                normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
                if (angular.isDefined(attrs[normalizedName])) {
                  unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
                }
              }
            });
            return function unwatch() {
              unwatchFns.forEach(function(fn) {
                fn();
              });
            };
          }
          function getNormalizedName(attrs, attrName) {
            return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));
          }
        }
        mdMediaFactory.$inject = ["$mdConstant", "$rootScope", "$window"];
      })();
      (function() {
        "use strict";
        var nextUniqueId = 0;
        angular.module('material.core').factory('$mdUtil', UtilFactory);
        function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window) {
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}'));
          var hasComputedStyle = function(target, key, expectedVal) {
            var hasValue = false;
            if (target && target.length) {
              var computedStyles = $window.getComputedStyle(target[0]);
              hasValue = angular.isDefined(computedStyles[key]) && (expectedVal ? computedStyles[key] == expectedVal : true);
            }
            return hasValue;
          };
          var $mdUtil = {
            dom: {},
            now: window.performance ? angular.bind(window.performance, window.performance.now) : Date.now || function() {
              return new Date().getTime();
            },
            clientRect: function(element, offsetParent, isOffsetRect) {
              var node = getNode(element);
              offsetParent = getNode(offsetParent || node.offsetParent || document.body);
              var nodeRect = node.getBoundingClientRect();
              var offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {
                left: 0,
                top: 0,
                width: 0,
                height: 0
              };
              return {
                left: nodeRect.left - offsetRect.left,
                top: nodeRect.top - offsetRect.top,
                width: nodeRect.width,
                height: nodeRect.height
              };
            },
            offsetRect: function(element, offsetParent) {
              return $mdUtil.clientRect(element, offsetParent, true);
            },
            nodesToArray: function(nodes) {
              nodes = nodes || [];
              var results = [];
              for (var i = 0; i < nodes.length; ++i) {
                results.push(nodes.item(i));
              }
              return results;
            },
            scrollTop: function(element) {
              element = angular.element(element || $document[0].body);
              var body = (element[0] == $document[0].body) ? $document[0].body : undefined;
              var scrollTop = body ? body.scrollTop + body.parentElement.scrollTop : 0;
              return scrollTop || Math.abs(element[0].getBoundingClientRect().top);
            },
            findFocusTarget: function(containerEl, attributeVal) {
              var AUTO_FOCUS = '[md-autofocus]';
              var elToFocus;
              elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);
              if (!elToFocus && attributeVal != AUTO_FOCUS) {
                elToFocus = scanForFocusable(containerEl, '[md-auto-focus]');
                if (!elToFocus) {
                  elToFocus = scanForFocusable(containerEl, AUTO_FOCUS);
                }
              }
              return elToFocus;
              function scanForFocusable(target, selector) {
                var elFound,
                    items = target[0].querySelectorAll(selector);
                if (items && items.length) {
                  var EXP_ATTR = /\s*\[?([\-a-z]*)\]?\s*/i;
                  var matches = EXP_ATTR.exec(selector);
                  var attribute = matches ? matches[1] : null;
                  items.length && angular.forEach(items, function(it) {
                    it = angular.element(it);
                    var focusExpression = it[0].getAttribute(attribute);
                    var isFocusable = !focusExpression || !$mdUtil.validateScope(it) ? true : (it.scope().$eval(focusExpression) !== false);
                    if (isFocusable)
                      elFound = it;
                  });
                }
                return elFound;
              }
            },
            disableScrollAround: function(element, parent) {
              $mdUtil.disableScrollAround._count = $mdUtil.disableScrollAround._count || 0;
              ++$mdUtil.disableScrollAround._count;
              if ($mdUtil.disableScrollAround._enableScrolling)
                return $mdUtil.disableScrollAround._enableScrolling;
              element = angular.element(element);
              var body = $document[0].body,
                  restoreBody = disableBodyScroll(),
                  restoreElement = disableElementScroll(parent);
              return $mdUtil.disableScrollAround._enableScrolling = function() {
                if (!--$mdUtil.disableScrollAround._count) {
                  restoreBody();
                  restoreElement();
                  delete $mdUtil.disableScrollAround._enableScrolling;
                }
              };
              function disableElementScroll(element) {
                element = angular.element(element || body)[0];
                var zIndex = 50;
                var scrollMask = angular.element('<div class="md-scroll-mask" style="z-index: ' + zIndex + '">' + '  <div class="md-scroll-mask-bar"></div>' + '</div>');
                element.appendChild(scrollMask[0]);
                scrollMask.on('wheel', preventDefault);
                scrollMask.on('touchmove', preventDefault);
                $document.on('keydown', disableKeyNav);
                return function restoreScroll() {
                  scrollMask.off('wheel');
                  scrollMask.off('touchmove');
                  scrollMask[0].parentNode.removeChild(scrollMask[0]);
                  $document.off('keydown', disableKeyNav);
                  delete $mdUtil.disableScrollAround._enableScrolling;
                };
                function disableKeyNav(e) {}
                function preventDefault(e) {
                  e.preventDefault();
                }
              }
              function disableBodyScroll() {
                var htmlNode = body.parentNode;
                var restoreHtmlStyle = htmlNode.getAttribute('style') || '';
                var restoreBodyStyle = body.getAttribute('style') || '';
                var scrollOffset = $mdUtil.scrollTop(body);
                var clientWidth = body.clientWidth;
                if (body.scrollHeight > body.clientHeight + 1) {
                  applyStyles(body, {
                    position: 'fixed',
                    width: '100%',
                    top: -scrollOffset + 'px'
                  });
                  applyStyles(htmlNode, {overflowY: 'scroll'});
                }
                if (body.clientWidth < clientWidth)
                  applyStyles(body, {overflow: 'hidden'});
                return function restoreScroll() {
                  body.setAttribute('style', restoreBodyStyle);
                  htmlNode.setAttribute('style', restoreHtmlStyle);
                  body.scrollTop = scrollOffset;
                  htmlNode.scrollTop = scrollOffset;
                };
              }
              function applyStyles(el, styles) {
                for (var key in styles) {
                  el.style[key] = styles[key];
                }
              }
            },
            enableScrolling: function() {
              var method = this.disableScrollAround._enableScrolling;
              method && method();
            },
            floatingScrollbars: function() {
              if (this.floatingScrollbars.cached === undefined) {
                var tempNode = angular.element('<div style="width: 100%; z-index: -1; position: absolute; height: 35px; overflow-y: scroll"><div style="height: 60px;"></div></div>');
                $document[0].body.appendChild(tempNode[0]);
                this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);
                tempNode.remove();
              }
              return this.floatingScrollbars.cached;
            },
            forceFocus: function(element) {
              var node = element[0] || element;
              document.addEventListener('click', function focusOnClick(ev) {
                if (ev.target === node && ev.$focus) {
                  node.focus();
                  ev.stopImmediatePropagation();
                  ev.preventDefault();
                  node.removeEventListener('click', focusOnClick);
                }
              }, true);
              var newEvent = document.createEvent('MouseEvents');
              newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0, false, false, false, false, 0, null);
              newEvent.$material = true;
              newEvent.$focus = true;
              node.dispatchEvent(newEvent);
            },
            createBackdrop: function(scope, addClass) {
              return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [addClass]))(scope);
            },
            supplant: function(template, values, pattern) {
              pattern = pattern || /\{([^\{\}]*)\}/g;
              return template.replace(pattern, function(a, b) {
                var p = b.split('.'),
                    r = values;
                try {
                  for (var s in p) {
                    if (p.hasOwnProperty(s)) {
                      r = r[p[s]];
                    }
                  }
                } catch (e) {
                  r = a;
                }
                return (typeof r === 'string' || typeof r === 'number') ? r : a;
              });
            },
            fakeNgModel: function() {
              return {
                $fake: true,
                $setTouched: angular.noop,
                $setViewValue: function(value) {
                  this.$viewValue = value;
                  this.$render(value);
                  this.$viewChangeListeners.forEach(function(cb) {
                    cb();
                  });
                },
                $isEmpty: function(value) {
                  return ('' + value).length === 0;
                },
                $parsers: [],
                $formatters: [],
                $viewChangeListeners: [],
                $render: angular.noop
              };
            },
            debounce: function(func, wait, scope, invokeApply) {
              var timer;
              return function debounced() {
                var context = scope,
                    args = Array.prototype.slice.call(arguments);
                $timeout.cancel(timer);
                timer = $timeout(function() {
                  timer = undefined;
                  func.apply(context, args);
                }, wait || 10, invokeApply);
              };
            },
            throttle: function throttle(func, delay) {
              var recent;
              return function throttled() {
                var context = this;
                var args = arguments;
                var now = $mdUtil.now();
                if (!recent || (now - recent > delay)) {
                  func.apply(context, args);
                  recent = now;
                }
              };
            },
            time: function time(cb) {
              var start = $mdUtil.now();
              cb();
              return $mdUtil.now() - start;
            },
            valueOnUse: function(scope, key, getter) {
              var value = null,
                  args = Array.prototype.slice.call(arguments);
              var params = (args.length > 3) ? args.slice(3) : [];
              Object.defineProperty(scope, key, {get: function() {
                  if (value === null)
                    value = getter.apply(scope, params);
                  return value;
                }});
            },
            nextUid: function() {
              return '' + nextUniqueId++;
            },
            validateScope: function(element) {
              var hasScope = element && angular.isDefined(element.scope());
              if (!hasScope) {
                $log.warn("element.scope() is not available when 'debug mode' == false. @see https://docs.angularjs.org/guide/production!");
              }
              return hasScope;
            },
            disconnectScope: function disconnectScope(scope) {
              if (!scope)
                return;
              if (scope.$root === scope)
                return;
              if (scope.$$destroyed)
                return;
              var parent = scope.$parent;
              scope.$$disconnected = true;
              if (parent.$$childHead === scope)
                parent.$$childHead = scope.$$nextSibling;
              if (parent.$$childTail === scope)
                parent.$$childTail = scope.$$prevSibling;
              if (scope.$$prevSibling)
                scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
              if (scope.$$nextSibling)
                scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
              scope.$$nextSibling = scope.$$prevSibling = null;
            },
            reconnectScope: function reconnectScope(scope) {
              if (!scope)
                return;
              if (scope.$root === scope)
                return;
              if (!scope.$$disconnected)
                return;
              var child = scope;
              var parent = child.$parent;
              child.$$disconnected = false;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
            },
            getClosest: function getClosest(el, tagName, onlyParent) {
              if (el instanceof angular.element)
                el = el[0];
              tagName = tagName.toUpperCase();
              if (onlyParent)
                el = el.parentNode;
              if (!el)
                return null;
              do {
                if (el.nodeName === tagName) {
                  return el;
                }
              } while (el = el.parentNode);
              return null;
            },
            elementContains: function(node, child) {
              var hasContains = (window.Node && window.Node.prototype && Node.prototype.contains);
              var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
                return (node === child) || !!(this.compareDocumentPosition(arg) & 16);
              });
              return findFn(child);
            },
            extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
              var found = scanTree(element);
              if (!found && !!warnNotFound) {
                $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [nodeName, element[0].outerHTML]));
              }
              return angular.element(found || element);
              function scanTree(element) {
                return scanLevel(element) || (!!scanDeep ? scanChildren(element) : null);
              }
              function scanLevel(element) {
                if (element) {
                  for (var i = 0,
                      len = element.length; i < len; i++) {
                    if (element[i].nodeName.toLowerCase() === nodeName) {
                      return element[i];
                    }
                  }
                }
                return null;
              }
              function scanChildren(element) {
                var found;
                if (element) {
                  for (var i = 0,
                      len = element.length; i < len; i++) {
                    var target = element[i];
                    if (!found) {
                      for (var j = 0,
                          numChild = target.childNodes.length; j < numChild; j++) {
                        found = found || scanTree([target.childNodes[j]]);
                      }
                    }
                  }
                }
                return found;
              }
            },
            initOptionalProperties: function(scope, attr, defaults) {
              defaults = defaults || {};
              angular.forEach(scope.$$isolateBindings, function(binding, key) {
                if (binding.optional && angular.isUndefined(scope[key])) {
                  var attrIsDefined = angular.isDefined(attr[binding.attrName]);
                  scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
                }
              });
            },
            nextTick: function(callback, digest, scope) {
              var nextTick = $mdUtil.nextTick;
              var timeout = nextTick.timeout;
              var queue = nextTick.queue || [];
              queue.push(callback);
              if (digest == null)
                digest = true;
              nextTick.digest = nextTick.digest || digest;
              nextTick.queue = queue;
              return timeout || (nextTick.timeout = $timeout(processQueue, 0, false));
              function processQueue() {
                var skip = scope && scope.$$destroyed;
                var queue = !skip ? nextTick.queue : [];
                var digest = !skip ? nextTick.digest : null;
                nextTick.queue = [];
                nextTick.timeout = null;
                nextTick.digest = false;
                queue.forEach(function(callback) {
                  callback();
                });
                if (digest)
                  $rootScope.$digest();
              }
            },
            processTemplate: function(template) {
              if (usesStandardSymbols) {
                return template;
              } else {
                if (!template || !angular.isString(template))
                  return template;
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              }
            },
            getParentWithPointerEvents: function(element) {
              var parent = element.parent();
              while (hasComputedStyle(parent, 'pointer-events', 'none')) {
                parent = parent.parent();
              }
              return parent;
            },
            getNearestContentElement: function(element) {
              var current = element.parent()[0];
              while (current && current !== $rootElement[0] && current !== document.body && current.nodeName.toUpperCase() !== 'MD-CONTENT') {
                current = current.parentNode;
              }
              return current;
            },
            hasComputedStyle: hasComputedStyle
          };
          $mdUtil.dom.animator = $$mdAnimate($mdUtil);
          return $mdUtil;
          function getNode(el) {
            return el[0] || el;
          }
        }
        UtilFactory.$inject = ["$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window"];
        angular.element.prototype.focus = angular.element.prototype.focus || function() {
          if (this.length) {
            this[0].focus();
          }
          return this;
        };
        angular.element.prototype.blur = angular.element.prototype.blur || function() {
          if (this.length) {
            this[0].blur();
          }
          return this;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.core').service('$mdAria', AriaService);
        function AriaService($$rAF, $log, $window) {
          return {
            expect: expect,
            expectAsync: expectAsync,
            expectWithText: expectWithText
          };
          function expect(element, attrName, defaultValue) {
            var node = angular.element(element)[0] || element;
            if (node && ((!node.hasAttribute(attrName) || node.getAttribute(attrName).length === 0) && !childHasAttribute(node, attrName))) {
              defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : '';
              if (defaultValue.length) {
                element.attr(attrName, defaultValue);
              } else {
                $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
              }
            }
          }
          function expectAsync(element, attrName, defaultValueGetter) {
            $$rAF(function() {
              expect(element, attrName, defaultValueGetter());
            });
          }
          function expectWithText(element, attrName) {
            expectAsync(element, attrName, function() {
              return getText(element);
            });
          }
          function getText(element) {
            return element.text().trim();
          }
          function childHasAttribute(node, attrName) {
            var hasChildren = node.hasChildNodes(),
                hasAttr = false;
            function isHidden(el) {
              var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
              return (style.display === 'none');
            }
            if (hasChildren) {
              var children = node.childNodes;
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.nodeType === 1 && child.hasAttribute(attrName)) {
                  if (!isHidden(child)) {
                    hasAttr = true;
                  }
                }
              }
            }
            return hasAttr;
          }
        }
        AriaService.$inject = ["$$rAF", "$log", "$window"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').service('$mdCompiler', mdCompilerService);
        function mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
          this.compile = function(options) {
            var templateUrl = options.templateUrl;
            var template = options.template || '';
            var controller = options.controller;
            var controllerAs = options.controllerAs;
            var resolve = angular.extend({}, options.resolve || {});
            var locals = angular.extend({}, options.locals || {});
            var transformTemplate = options.transformTemplate || angular.identity;
            var bindToController = options.bindToController;
            angular.forEach(resolve, function(value, key) {
              if (angular.isString(value)) {
                resolve[key] = $injector.get(value);
              } else {
                resolve[key] = $injector.invoke(value);
              }
            });
            angular.extend(resolve, locals);
            if (templateUrl) {
              resolve.$template = $http.get(templateUrl, {cache: $templateCache}).then(function(response) {
                return response.data;
              });
            } else {
              resolve.$template = $q.when(template);
            }
            return $q.all(resolve).then(function(locals) {
              var compiledData;
              var template = transformTemplate(locals.$template, options);
              var element = options.element || angular.element('<div>').html(template.trim()).contents();
              var linkFn = $compile(element);
              return compiledData = {
                locals: locals,
                element: element,
                link: function link(scope) {
                  locals.$scope = scope;
                  if (controller) {
                    var invokeCtrl = $controller(controller, locals, true);
                    if (bindToController) {
                      angular.extend(invokeCtrl.instance, locals);
                    }
                    var ctrl = invokeCtrl();
                    element.data('$ngControllerController', ctrl);
                    element.children().data('$ngControllerController', ctrl);
                    if (controllerAs) {
                      scope[controllerAs] = ctrl;
                    }
                    compiledData.controller = ctrl;
                  }
                  return linkFn(scope);
                }
              };
            });
          };
        }
        mdCompilerService.$inject = ["$q", "$http", "$injector", "$compile", "$controller", "$templateCache"];
      })();
      (function() {
        "use strict";
        var HANDLERS = {};
        var pointer,
            lastPointer,
            forceSkipClickHijack = false;
        var lastLabelClickPos = null;
        var isInitialized = false;
        angular.module('material.core.gestures', []).provider('$mdGesture', MdGestureProvider).factory('$$MdGestureHandler', MdGestureHandler).run(attachToDocument);
        function MdGestureProvider() {}
        MdGestureProvider.prototype = {
          skipClickHijack: function() {
            return forceSkipClickHijack = true;
          },
          $get: ["$$MdGestureHandler", "$$rAF", "$timeout", function($$MdGestureHandler, $$rAF, $timeout) {
            return new MdGesture($$MdGestureHandler, $$rAF, $timeout);
          }]
        };
        function MdGesture($$MdGestureHandler, $$rAF, $timeout) {
          var userAgent = navigator.userAgent || navigator.vendor || window.opera;
          var isIos = userAgent.match(/ipad|iphone|ipod/i);
          var isAndroid = userAgent.match(/android/i);
          var hasJQuery = (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);
          var self = {
            handler: addHandler,
            register: register,
            isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack
          };
          if (self.isHijackingClicks) {
            var maxClickDistance = 6;
            self.handler('click', {
              options: {maxDistance: maxClickDistance},
              onEnd: checkDistanceAndEmit('click')
            });
            self.handler('focus', {
              options: {maxDistance: maxClickDistance},
              onEnd: function(ev, pointer) {
                if (pointer.distance < this.state.options.maxDistance) {
                  if (canFocus(ev.target)) {
                    this.dispatchEvent(ev, 'focus', pointer);
                    ev.target.focus();
                  }
                }
                function canFocus(element) {
                  var focusableElements = ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA', 'VIDEO', 'AUDIO'];
                  return (element.getAttribute('tabindex') != '-1') && !element.hasAttribute('DISABLED') && (element.hasAttribute('tabindex') || element.hasAttribute('href') || (focusableElements.indexOf(element.nodeName) != -1));
                }
              }
            });
            self.handler('mouseup', {
              options: {maxDistance: maxClickDistance},
              onEnd: checkDistanceAndEmit('mouseup')
            });
            self.handler('mousedown', {onStart: function(ev) {
                this.dispatchEvent(ev, 'mousedown');
              }});
          }
          function checkDistanceAndEmit(eventName) {
            return function(ev, pointer) {
              if (pointer.distance < this.state.options.maxDistance) {
                this.dispatchEvent(ev, eventName, pointer);
              }
            };
          }
          function register(element, handlerName, options) {
            var handler = HANDLERS[handlerName.replace(/^\$md./, '')];
            if (!handler) {
              throw new Error('Failed to register element with handler ' + handlerName + '. ' + 'Available handlers: ' + Object.keys(HANDLERS).join(', '));
            }
            return handler.registerElement(element, options);
          }
          function addHandler(name, definition) {
            var handler = new $$MdGestureHandler(name);
            angular.extend(handler, definition);
            HANDLERS[name] = handler;
            return self;
          }
          return self.handler('press', {
            onStart: function(ev, pointer) {
              this.dispatchEvent(ev, '$md.pressdown');
            },
            onEnd: function(ev, pointer) {
              this.dispatchEvent(ev, '$md.pressup');
            }
          }).handler('hold', {
            options: {
              maxDistance: 6,
              delay: 500
            },
            onCancel: function() {
              $timeout.cancel(this.state.timeout);
            },
            onStart: function(ev, pointer) {
              if (!this.state.registeredParent)
                return this.cancel();
              this.state.pos = {
                x: pointer.x,
                y: pointer.y
              };
              this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {
                this.dispatchEvent(ev, '$md.hold');
                this.cancel();
              }), this.state.options.delay, false);
            },
            onMove: function(ev, pointer) {
              ev.preventDefault();
              var dx = this.state.pos.x - pointer.x;
              var dy = this.state.pos.y - pointer.y;
              if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {
                this.cancel();
              }
            },
            onEnd: function() {
              this.onCancel();
            }
          }).handler('drag', {
            options: {
              minDistance: 6,
              horizontal: true,
              cancelMultiplier: 1.5
            },
            onStart: function(ev) {
              if (!this.state.registeredParent)
                this.cancel();
            },
            onMove: function(ev, pointer) {
              var shouldStartDrag,
                  shouldCancel;
              ev.preventDefault();
              if (!this.state.dragPointer) {
                if (this.state.options.horizontal) {
                  shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
                  shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                } else {
                  shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
                  shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                }
                if (shouldStartDrag) {
                  this.state.dragPointer = makeStartPointer(ev);
                  updatePointerState(ev, this.state.dragPointer);
                  this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);
                } else if (shouldCancel) {
                  this.cancel();
                }
              } else {
                this.dispatchDragMove(ev);
              }
            },
            dispatchDragMove: $$rAF.throttle(function(ev) {
              if (this.state.isRunning) {
                updatePointerState(ev, this.state.dragPointer);
                this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);
              }
            }),
            onEnd: function(ev, pointer) {
              if (this.state.dragPointer) {
                updatePointerState(ev, this.state.dragPointer);
                this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);
              }
            }
          }).handler('swipe', {
            options: {
              minVelocity: 0.65,
              minDistance: 10
            },
            onEnd: function(ev, pointer) {
              var eventType;
              if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance) {
                eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight';
                this.dispatchEvent(ev, eventType);
              } else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance) {
                eventType = pointer.directionY == 'up' ? '$md.swipeup' : '$md.swipedown';
                this.dispatchEvent(ev, eventType);
              }
            }
          });
        }
        MdGesture.$inject = ["$$MdGestureHandler", "$$rAF", "$timeout"];
        function GestureHandler(name) {
          this.name = name;
          this.state = {};
        }
        function MdGestureHandler() {
          var hasJQuery = (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);
          GestureHandler.prototype = {
            options: {},
            dispatchEvent: hasJQuery ? jQueryDispatchEvent : nativeDispatchEvent,
            onStart: angular.noop,
            onMove: angular.noop,
            onEnd: angular.noop,
            onCancel: angular.noop,
            start: function(ev, pointer) {
              if (this.state.isRunning)
                return;
              var parentTarget = this.getNearestParent(ev.target);
              var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};
              this.state = {
                isRunning: true,
                options: angular.extend({}, this.options, parentTargetOptions),
                registeredParent: parentTarget
              };
              this.onStart(ev, pointer);
            },
            move: function(ev, pointer) {
              if (!this.state.isRunning)
                return;
              this.onMove(ev, pointer);
            },
            end: function(ev, pointer) {
              if (!this.state.isRunning)
                return;
              this.onEnd(ev, pointer);
              this.state.isRunning = false;
            },
            cancel: function(ev, pointer) {
              this.onCancel(ev, pointer);
              this.state = {};
            },
            getNearestParent: function(node) {
              var current = node;
              while (current) {
                if ((current.$mdGesture || {})[this.name]) {
                  return current;
                }
                current = current.parentNode;
              }
              return null;
            },
            registerElement: function(element, options) {
              var self = this;
              element[0].$mdGesture = element[0].$mdGesture || {};
              element[0].$mdGesture[this.name] = options || {};
              element.on('$destroy', onDestroy);
              return onDestroy;
              function onDestroy() {
                delete element[0].$mdGesture[self.name];
                element.off('$destroy', onDestroy);
              }
            }
          };
          return GestureHandler;
          function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj = new angular.element.Event(eventType);
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            angular.extend(eventObj, {
              clientX: eventPointer.x,
              clientY: eventPointer.y,
              screenX: eventPointer.x,
              screenY: eventPointer.y,
              pageX: eventPointer.x,
              pageY: eventPointer.y,
              ctrlKey: srcEvent.ctrlKey,
              altKey: srcEvent.altKey,
              shiftKey: srcEvent.shiftKey,
              metaKey: srcEvent.metaKey
            });
            angular.element(eventPointer.target).trigger(eventObj);
          }
          function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj;
            if (eventType === 'click' || eventType == 'mouseup' || eventType == 'mousedown') {
              eventObj = document.createEvent('MouseEvents');
              eventObj.initMouseEvent(eventType, true, true, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null);
            } else {
              eventObj = document.createEvent('CustomEvent');
              eventObj.initCustomEvent(eventType, true, true, {});
            }
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            eventPointer.target.dispatchEvent(eventObj);
          }
        }
        function attachToDocument($mdGesture, $$MdGestureHandler) {
          document.contains || (document.contains = function(node) {
            return document.body.contains(node);
          });
          if (!isInitialized && $mdGesture.isHijackingClicks) {
            document.addEventListener('click', clickHijacker, true);
            document.addEventListener('mouseup', mouseInputHijacker, true);
            document.addEventListener('mousedown', mouseInputHijacker, true);
            document.addEventListener('focus', mouseInputHijacker, true);
            isInitialized = true;
          }
          function mouseInputHijacker(ev) {
            var isKeyClick = !ev.clientX && !ev.clientY;
            if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
              ev.preventDefault();
              ev.stopPropagation();
            }
          }
          function clickHijacker(ev) {
            var isKeyClick = ev.clientX === 0 && ev.clientY === 0;
            if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
              ev.preventDefault();
              ev.stopPropagation();
              lastLabelClickPos = null;
            } else {
              lastLabelClickPos = null;
              if (ev.target.tagName.toLowerCase() == 'label') {
                lastLabelClickPos = {
                  x: ev.x,
                  y: ev.y
                };
              }
            }
          }
          var START_EVENTS = 'mousedown touchstart pointerdown';
          var MOVE_EVENTS = 'mousemove touchmove pointermove';
          var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel';
          angular.element(document).on(START_EVENTS, gestureStart).on(MOVE_EVENTS, gestureMove).on(END_EVENTS, gestureEnd).on('$$mdGestureReset', function gestureClearCache() {
            lastPointer = pointer = null;
          });
          function runHandlers(handlerEvent, event) {
            var handler;
            for (var name in HANDLERS) {
              handler = HANDLERS[name];
              if (handler instanceof $$MdGestureHandler) {
                if (handlerEvent === 'start') {
                  handler.cancel();
                }
                handler[handlerEvent](event, pointer);
              }
            }
          }
          function gestureStart(ev) {
            if (pointer)
              return;
            var now = +Date.now();
            if (lastPointer && !typesMatch(ev, lastPointer) && (now - lastPointer.endTime < 1500)) {
              return;
            }
            pointer = makeStartPointer(ev);
            runHandlers('start', ev);
          }
          function gestureMove(ev) {
            if (!pointer || !typesMatch(ev, pointer))
              return;
            updatePointerState(ev, pointer);
            runHandlers('move', ev);
          }
          function gestureEnd(ev) {
            if (!pointer || !typesMatch(ev, pointer))
              return;
            updatePointerState(ev, pointer);
            pointer.endTime = +Date.now();
            runHandlers('end', ev);
            lastPointer = pointer;
            pointer = null;
          }
        }
        attachToDocument.$inject = ["$mdGesture", "$$MdGestureHandler"];
        function makeStartPointer(ev) {
          var point = getEventPoint(ev);
          var startPointer = {
            startTime: +Date.now(),
            target: ev.target,
            type: ev.type.charAt(0)
          };
          startPointer.startX = startPointer.x = point.pageX;
          startPointer.startY = startPointer.y = point.pageY;
          return startPointer;
        }
        function typesMatch(ev, pointer) {
          return ev && pointer && ev.type.charAt(0) === pointer.type;
        }
        function isInputEventFromLabelClick(event) {
          return lastLabelClickPos && lastLabelClickPos.x == event.x && lastLabelClickPos.y == event.y;
        }
        function updatePointerState(ev, pointer) {
          var point = getEventPoint(ev);
          var x = pointer.x = point.pageX;
          var y = pointer.y = point.pageY;
          pointer.distanceX = x - pointer.startX;
          pointer.distanceY = y - pointer.startY;
          pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY);
          pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : '';
          pointer.directionY = pointer.distanceY > 0 ? 'down' : pointer.distanceY < 0 ? 'up' : '';
          pointer.duration = +Date.now() - pointer.startTime;
          pointer.velocityX = pointer.distanceX / pointer.duration;
          pointer.velocityY = pointer.distanceY / pointer.duration;
        }
        function getEventPoint(ev) {
          ev = ev.originalEvent || ev;
          return (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]) || ev;
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').provider('$$interimElement', InterimElementProvider);
        function InterimElementProvider() {
          createInterimElementProvider.$get = InterimElementFactory;
          InterimElementFactory.$inject = ["$document", "$q", "$$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector"];
          return createInterimElementProvider;
          function createInterimElementProvider(interimFactoryName) {
            var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove'];
            var customMethods = {};
            var providerConfig = {presets: {}};
            var provider = {
              setDefaults: setDefaults,
              addPreset: addPreset,
              addMethod: addMethod,
              $get: factory
            };
            provider.addPreset('build', {methods: ['controller', 'controllerAs', 'resolve', 'template', 'templateUrl', 'themable', 'transformTemplate', 'parent']});
            factory.$inject = ["$$interimElement", "$injector"];
            return provider;
            function setDefaults(definition) {
              providerConfig.optionsFactory = definition.options;
              providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
              return provider;
            }
            function addMethod(name, fn) {
              customMethods[name] = fn;
              return provider;
            }
            function addPreset(name, definition) {
              definition = definition || {};
              definition.methods = definition.methods || [];
              definition.options = definition.options || function() {
                return {};
              };
              if (/^cancel|hide|show$/.test(name)) {
                throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
              }
              if (definition.methods.indexOf('_options') > -1) {
                throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
              }
              providerConfig.presets[name] = {
                methods: definition.methods.concat(EXPOSED_METHODS),
                optionsFactory: definition.options,
                argOption: definition.argOption
              };
              return provider;
            }
            function addPresetMethod(presetName, methodName, method) {
              providerConfig.presets[presetName][methodName] = method;
            }
            function factory($$interimElement, $injector) {
              var defaultMethods;
              var defaultOptions;
              var interimElementService = $$interimElement();
              var publicService = {
                hide: interimElementService.hide,
                cancel: interimElementService.cancel,
                show: showInterimElement,
                destroy: destroyInterimElement
              };
              defaultMethods = providerConfig.methods || [];
              defaultOptions = invokeFactory(providerConfig.optionsFactory, {});
              angular.forEach(customMethods, function(fn, name) {
                publicService[name] = fn;
              });
              angular.forEach(providerConfig.presets, function(definition, name) {
                var presetDefaults = invokeFactory(definition.optionsFactory, {});
                var presetMethods = (definition.methods || []).concat(defaultMethods);
                angular.extend(presetDefaults, {$type: name});
                function Preset(opts) {
                  this._options = angular.extend({}, presetDefaults, opts);
                }
                angular.forEach(presetMethods, function(name) {
                  Preset.prototype[name] = function(value) {
                    this._options[name] = value;
                    return this;
                  };
                });
                if (definition.argOption) {
                  var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1);
                  publicService[methodName] = function(arg) {
                    var config = publicService[name](arg);
                    return publicService.show(config);
                  };
                }
                publicService[name] = function(arg) {
                  if (arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg)) {
                    return (new Preset())[definition.argOption](arg);
                  } else {
                    return new Preset(arg);
                  }
                };
              });
              return publicService;
              function showInterimElement(opts) {
                opts = opts || {};
                if (opts._options)
                  opts = opts._options;
                return interimElementService.show(angular.extend({}, defaultOptions, opts));
              }
              function destroyInterimElement(opts) {
                return interimElementService.destroy(opts);
              }
              function invokeFactory(factory, defaultVal) {
                var locals = {};
                locals[interimFactoryName] = publicService;
                return $injector.invoke(factory || function() {
                  return defaultVal;
                }, {}, locals);
              }
            }
          }
          function InterimElementFactory($document, $q, $$q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector) {
            return function createInterimElementService() {
              var SHOW_CANCELLED = false;
              var service,
                  stack = [];
              return service = {
                show: show,
                hide: hide,
                cancel: cancel,
                destroy: destroy,
                $injector_: $injector
              };
              function show(options) {
                options = options || {};
                var interimElement = new InterimElement(options || {});
                var hideExisting = !options.skipHide && stack.length ? service.hide() : $q.when(true);
                hideExisting.finally(function() {
                  stack.push(interimElement);
                  interimElement.show().catch(function(reason) {
                    return reason;
                  });
                });
                return interimElement.deferred.promise;
              }
              function hide(reason, options) {
                if (!stack.length)
                  return $q.when(reason);
                options = options || {};
                if (options.closeAll) {
                  var promise = $q.all(stack.reverse().map(closeElement));
                  stack = [];
                  return promise;
                } else if (options.closeTo !== undefined) {
                  return $q.all(stack.splice(options.closeTo).map(closeElement));
                } else {
                  var interim = stack.pop();
                  return closeElement(interim);
                }
                function closeElement(interim) {
                  interim.remove(reason, false, options || {}).catch(function(reason) {
                    return reason;
                  });
                  return interim.deferred.promise;
                }
              }
              function cancel(reason, options) {
                var interim = stack.shift();
                if (!interim)
                  return $q.when(reason);
                interim.remove(reason, true, options || {}).catch(function(reason) {
                  return reason;
                });
                return interim.deferred.promise;
              }
              function destroy(target) {
                var interim = !target ? stack.shift() : null;
                var cntr = angular.element(target).length ? angular.element(target)[0].parentNode : null;
                if (cntr) {
                  var filtered = stack.filter(function(entry) {
                    var currNode = entry.options.element[0];
                    return (currNode === cntr);
                  });
                  if (filtered.length > 0) {
                    interim = filtered[0];
                    stack.splice(stack.indexOf(interim), 1);
                  }
                }
                return interim ? interim.remove(SHOW_CANCELLED, false, {'$destroy': true}) : $q.when(SHOW_CANCELLED);
              }
              function InterimElement(options) {
                var self,
                    element,
                    showAction = $q.when(true);
                options = configureScopeAndTransitions(options);
                return self = {
                  options: options,
                  deferred: $q.defer(),
                  show: createAndTransitionIn,
                  remove: transitionOutAndRemove
                };
                function createAndTransitionIn() {
                  return $q(function(resolve, reject) {
                    compileElement(options).then(function(compiledData) {
                      element = linkElement(compiledData, options);
                      showAction = showElement(element, options, compiledData.controller).then(resolve, rejectAll);
                    }, rejectAll);
                    function rejectAll(fault) {
                      self.deferred.reject(fault);
                      reject(fault);
                    }
                  });
                }
                function transitionOutAndRemove(response, isCancelled, opts) {
                  if (!element)
                    return $q.when(false);
                  options = angular.extend(options || {}, opts || {});
                  options.cancelAutoHide && options.cancelAutoHide();
                  options.element.triggerHandler('$mdInterimElementRemove');
                  if (options.$destroy === true) {
                    return hideElement(options.element, options).then(function() {
                      (isCancelled && rejectAll(response)) || resolveAll(response);
                    });
                  } else {
                    $q.when(showAction).finally(function() {
                      hideElement(options.element, options).then(function() {
                        (isCancelled && rejectAll(response)) || resolveAll(response);
                      }, rejectAll);
                    });
                    return self.deferred.promise;
                  }
                  function resolveAll(response) {
                    self.deferred.resolve(response);
                  }
                  function rejectAll(fault) {
                    self.deferred.reject(fault);
                  }
                }
                function configureScopeAndTransitions(options) {
                  options = options || {};
                  if (options.template) {
                    options.template = $mdUtil.processTemplate(options.template);
                  }
                  return angular.extend({
                    preserveScope: false,
                    cancelAutoHide: angular.noop,
                    scope: options.scope || $rootScope.$new(options.isolateScope),
                    onShow: function transitionIn(scope, element, options) {
                      return $animate.enter(element, options.parent);
                    },
                    onRemove: function transitionOut(scope, element) {
                      return element && $animate.leave(element) || $q.when();
                    }
                  }, options);
                }
                function compileElement(options) {
                  var compiled = !options.skipCompile ? $mdCompiler.compile(options) : null;
                  return compiled || $q(function(resolve) {
                    resolve({
                      locals: {},
                      link: function() {
                        return options.element;
                      }
                    });
                  });
                }
                function linkElement(compileData, options) {
                  angular.extend(compileData.locals, options);
                  var element = compileData.link(options.scope);
                  options.element = element;
                  options.parent = findParent(element, options);
                  if (options.themable)
                    $mdTheming(element);
                  return element;
                }
                function findParent(element, options) {
                  var parent = options.parent;
                  if (angular.isFunction(parent)) {
                    parent = parent(options.scope, element, options);
                  } else if (angular.isString(parent)) {
                    parent = angular.element($document[0].querySelector(parent));
                  } else {
                    parent = angular.element(parent);
                  }
                  if (!(parent || {}).length) {
                    var el;
                    if ($rootElement[0] && $rootElement[0].querySelector) {
                      el = $rootElement[0].querySelector(':not(svg) > body');
                    }
                    if (!el)
                      el = $rootElement[0];
                    if (el.nodeName == '#comment') {
                      el = $document[0].body;
                    }
                    return angular.element(el);
                  }
                  return parent;
                }
                function startAutoHide() {
                  var autoHideTimer,
                      cancelAutoHide = angular.noop;
                  if (options.hideDelay) {
                    autoHideTimer = $timeout(service.hide, options.hideDelay);
                    cancelAutoHide = function() {
                      $timeout.cancel(autoHideTimer);
                    };
                  }
                  options.cancelAutoHide = function() {
                    cancelAutoHide();
                    options.cancelAutoHide = undefined;
                  };
                }
                function showElement(element, options, controller) {
                  var notifyShowing = options.onShowing || angular.noop;
                  var notifyComplete = options.onComplete || angular.noop;
                  notifyShowing(options.scope, element, options, controller);
                  return $q(function(resolve, reject) {
                    try {
                      $q.when(options.onShow(options.scope, element, options, controller)).then(function() {
                        notifyComplete(options.scope, element, options);
                        startAutoHide();
                        resolve(element);
                      }, reject);
                    } catch (e) {
                      reject(e.message);
                    }
                  });
                }
                function hideElement(element, options) {
                  var announceRemoving = options.onRemoving || angular.noop;
                  return $$q(function(resolve, reject) {
                    try {
                      var action = $$q.when(options.onRemove(options.scope, element, options) || true);
                      announceRemoving(element, action);
                      if (options.$destroy == true) {
                        resolve(element);
                      } else {
                        action.then(function() {
                          if (!options.preserveScope && options.scope) {
                            options.scope.$destroy();
                          }
                          resolve(element);
                        }, reject);
                      }
                    } catch (e) {
                      reject(e.message);
                    }
                  });
                }
              }
            };
          }
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          var $mdUtil,
              $interpolate,
              $log;
          var SUFFIXES = /(-gt)?-(sm|md|lg)/g;
          var WHITESPACE = /\s+/g;
          var FLEX_OPTIONS = ['grow', 'initial', 'auto', 'none', 'noshrink', 'nogrow'];
          var LAYOUT_OPTIONS = ['row', 'column'];
          var ALIGNMENT_MAIN_AXIS = ["", "start", "center", "end", "stretch", "space-around", "space-between"];
          var ALIGNMENT_CROSS_AXIS = ["", "start", "center", "end", "stretch"];
          var config = {
            enabled: true,
            breakpoints: []
          };
          registerLayoutAPI(angular.module('material.core.layout', ['ng']));
          function registerLayoutAPI(module) {
            var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var BREAKPOINTS = ["", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl"];
            var API_WITH_VALUES = ["layout", "flex", "flex-order", "flex-offset", "layout-align"];
            var API_NO_VALUES = ["show", "hide", "layout-padding", "layout-margin"];
            angular.forEach(BREAKPOINTS, function(mqb) {
              angular.forEach(API_WITH_VALUES, function(name) {
                var fullName = mqb ? name + "-" + mqb : name;
                module.directive(directiveNormalize(fullName), attributeWithObserve(fullName));
              });
              angular.forEach(API_NO_VALUES, function(name) {
                var fullName = mqb ? name + "-" + mqb : name;
                module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));
              });
            });
            module.directive('mdLayoutCss', disableLayoutDirective).directive('ngCloak', buildCloakInterceptor('ng-cloak')).directive('layoutWrap', attributeWithoutValue('layout-wrap')).directive('layoutNoWrap', attributeWithoutValue('layout-no-wrap')).directive('layoutFill', attributeWithoutValue('layout-fill')).directive('layoutLtMd', warnAttrNotSupported('layout-lt-md', true)).directive('layoutLtLg', warnAttrNotSupported('layout-lt-lg', true)).directive('flexLtMd', warnAttrNotSupported('flex-lt-md', true)).directive('flexLtLg', warnAttrNotSupported('flex-lt-lg', true)).directive('layoutAlignLtMd', warnAttrNotSupported('layout-align-lt-md')).directive('layoutAlignLtLg', warnAttrNotSupported('layout-align-lt-lg')).directive('flexOrderLtMd', warnAttrNotSupported('flex-order-lt-md')).directive('flexOrderLtLg', warnAttrNotSupported('flex-order-lt-lg')).directive('offsetLtMd', warnAttrNotSupported('flex-offset-lt-md')).directive('offsetLtLg', warnAttrNotSupported('flex-offset-lt-lg')).directive('hideLtMd', warnAttrNotSupported('hide-lt-md')).directive('hideLtLg', warnAttrNotSupported('hide-lt-lg')).directive('showLtMd', warnAttrNotSupported('show-lt-md')).directive('showLtLg', warnAttrNotSupported('show-lt-lg'));
            function directiveNormalize(name) {
              return name.replace(PREFIX_REGEXP, '').replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
              });
            }
          }
          function disableLayoutDirective() {
            return {
              restrict: 'A',
              priority: '900',
              compile: function(element, attr) {
                config.enabled = false;
                return angular.noop;
              }
            };
          }
          function buildCloakInterceptor(className) {
            return ['$timeout', function($timeout) {
              return {
                restrict: 'A',
                priority: -10,
                compile: function(element) {
                  if (!config.enabled)
                    return angular.noop;
                  element.addClass(className);
                  return function(scope, element) {
                    $timeout(function() {
                      element.removeClass(className);
                    }, 10, false);
                  };
                }
              };
            }];
          }
          function attributeWithObserve(className) {
            return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
              $mdUtil = _$mdUtil_;
              $interpolate = _$interpolate_;
              $log = _$log_;
              return {
                restrict: 'A',
                compile: function(element, attr) {
                  var linkFn;
                  if (config.enabled) {
                    validateAttributeUsage(className, attr, element, $log);
                    validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                    linkFn = translateWithValueToCssClass;
                  }
                  return linkFn || angular.noop;
                }
              };
            }];
            function translateWithValueToCssClass(scope, element, attrs) {
              var updateFn = updateClassWithValue(element, className, attrs);
              var unwatch = attrs.$observe(attrs.$normalize(className), updateFn);
              updateFn(getNormalizedAttrValue(className, attrs, ""));
              scope.$on("$destroy", function() {
                unwatch();
              });
            }
          }
          function attributeWithoutValue(className) {
            return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
              $mdUtil = _$mdUtil_;
              $interpolate = _$interpolate_;
              $log = _$log_;
              return {
                restrict: 'A',
                compile: function(element, attr) {
                  var linkFn;
                  if (config.enabled) {
                    validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                    translateToCssClass(null, element);
                    linkFn = translateToCssClass;
                  }
                  return linkFn || angular.noop;
                }
              };
            }];
            function translateToCssClass(scope, element) {
              element.addClass(className);
            }
          }
          function updateClassWithValue(element, className) {
            var lastClass;
            return function updateClassFn(newValue) {
              var value = validateAttributeValue(className, newValue || "");
              if (angular.isDefined(value)) {
                if (lastClass)
                  element.removeClass(lastClass);
                lastClass = !value ? className : className + "-" + value.replace(WHITESPACE, "-");
                element.addClass(lastClass);
              }
            };
          }
          function warnAttrNotSupported(className) {
            var parts = className.split("-");
            return ["$log", function($log) {
              $log.warn(className + "has been deprecated. Please use a `" + parts[0] + "-gt-<xxx>` variant.");
              return angular.noop;
            }];
          }
          function validateAttributeUsage(className, attr, element, $log) {
            var message,
                usage,
                url;
            var nodeName = element[0].nodeName.toLowerCase();
            switch (className.replace(SUFFIXES, "")) {
              case "flex":
                if ((nodeName == "md-button") || (nodeName == "fieldset")) {
                  usage = "<" + nodeName + " " + className + "></" + nodeName + ">";
                  url = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers";
                  message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.";
                  $log.warn($mdUtil.supplant(message, [usage, url]));
                }
            }
          }
          function validateAttributeValue(className, value, updateFn) {
            var origValue = value;
            if (!needsInterpolation(value)) {
              switch (className.replace(SUFFIXES, "")) {
                case 'layout':
                  if (!findIn(value, LAYOUT_OPTIONS)) {
                    value = LAYOUT_OPTIONS[0];
                  }
                  break;
                case 'flex':
                  if (!findIn(value, FLEX_OPTIONS)) {
                    if (isNaN(value)) {
                      value = '';
                    }
                  }
                  break;
                case 'flex-offset':
                case 'flex-order':
                  if (!value || isNaN(+value)) {
                    value = '0';
                  }
                  break;
                case 'layout-align':
                  var axis = extractAlignAxis(value);
                  value = $mdUtil.supplant("{main}-{cross}", axis);
                  break;
                case 'layout-padding':
                case 'layout-margin':
                case 'layout-fill':
                case 'layout-wrap':
                case 'layout-no-wrap':
                  value = '';
                  break;
              }
              if (value != origValue) {
                (updateFn || angular.noop)(value);
              }
            }
            return value;
          }
          function buildUpdateFn(element, className, attrs) {
            return function updateAttrValue(fallback) {
              if (!needsInterpolation(fallback)) {
                attrs[attrs.$normalize(className)] = fallback;
              }
            };
          }
          function needsInterpolation(value) {
            return (value || "").indexOf($interpolate.startSymbol()) > -1;
          }
          function getNormalizedAttrValue(className, attrs, defaultVal) {
            var normalizedAttr = attrs.$normalize(className);
            return attrs[normalizedAttr] ? attrs[normalizedAttr].replace(WHITESPACE, "-") : defaultVal || null;
          }
          function findIn(item, list, replaceWith) {
            item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;
            var found = false;
            if (item) {
              list.forEach(function(it) {
                it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
                found = found || (it === item);
              });
            }
            return found;
          }
          function extractAlignAxis(attrValue) {
            var axis = {
              main: "start",
              cross: "stretch"
            },
                values;
            attrValue = (attrValue || "");
            if (attrValue.indexOf("-") == 0 || attrValue.indexOf(" ") == 0) {
              attrValue = "none" + attrValue;
            }
            values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-");
            if (values.length && (values[0] === "space")) {
              values = [values[0] + "-" + values[1], values[2]];
            }
            if (values.length > 0)
              axis.main = values[0] || axis.main;
            if (values.length > 1)
              axis.cross = values[1] || axis.cross;
            if (ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0)
              axis.main = "start";
            if (ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0)
              axis.cross = "stretch";
            return axis;
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdComponentRegistry', ComponentRegistry);
        function ComponentRegistry($log, $q) {
          var self;
          var instances = [];
          var pendings = {};
          return self = {
            notFoundError: function(handle) {
              $log.error('No instance found for handle', handle);
            },
            getInstances: function() {
              return instances;
            },
            get: function(handle) {
              if (!isValidID(handle))
                return null;
              var i,
                  j,
                  instance;
              for (i = 0, j = instances.length; i < j; i++) {
                instance = instances[i];
                if (instance.$$mdHandle === handle) {
                  return instance;
                }
              }
              return null;
            },
            register: function(instance, handle) {
              if (!handle)
                return angular.noop;
              instance.$$mdHandle = handle;
              instances.push(instance);
              resolveWhen();
              return deregister;
              function deregister() {
                var index = instances.indexOf(instance);
                if (index !== -1) {
                  instances.splice(index, 1);
                }
              }
              function resolveWhen() {
                var dfd = pendings[handle];
                if (dfd) {
                  dfd.resolve(instance);
                  delete pendings[handle];
                }
              }
            },
            when: function(handle) {
              if (isValidID(handle)) {
                var deferred = $q.defer();
                var instance = self.get(handle);
                if (instance) {
                  deferred.resolve(instance);
                } else {
                  pendings[handle] = deferred;
                }
                return deferred.promise;
              }
              return $q.reject("Invalid `md-component-id` value.");
            }
          };
          function isValidID(handle) {
            return handle && (handle !== "");
          }
        }
        ComponentRegistry.$inject = ["$log", "$q"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdButtonInkRipple', MdButtonInkRipple);
          function MdButtonInkRipple($mdInkRipple) {
            return {attach: function attachRipple(scope, element, options) {
                options = angular.extend(optionsForElement(element), options);
                return $mdInkRipple.attach(scope, element, options);
              }};
            function optionsForElement(element) {
              if (element.hasClass('md-icon-button')) {
                return {
                  isMenuItem: element.hasClass('md-menu-item'),
                  fitRipple: true,
                  center: true
                };
              } else {
                return {
                  isMenuItem: element.hasClass('md-menu-item'),
                  dimBackground: true
                };
              }
            }
            ;
          }
          MdButtonInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdCheckboxInkRipple', MdCheckboxInkRipple);
          function MdCheckboxInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: true,
                dimBackground: false,
                fitRipple: true
              }, options));
            }
            ;
          }
          MdCheckboxInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdListInkRipple', MdListInkRipple);
          function MdListInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: 'full'
              }, options));
            }
            ;
          }
          MdListInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdInkRipple', InkRippleService).directive('mdInkRipple', InkRippleDirective).directive('mdNoInk', attrNoDirective).directive('mdNoBar', attrNoDirective).directive('mdNoStretch', attrNoDirective);
        var DURATION = 450;
        function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {
          return {
            controller: angular.noop,
            link: function(scope, element, attr) {
              attr.hasOwnProperty('mdInkRippleCheckbox') ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element);
            }
          };
        }
        InkRippleDirective.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"];
        function InkRippleService($injector) {
          return {attach: attach};
          function attach(scope, element, options) {
            if (element.controller('mdNoInk'))
              return angular.noop;
            return $injector.instantiate(InkRippleCtrl, {
              $scope: scope,
              $element: element,
              rippleOptions: options
            });
          }
        }
        InkRippleService.$inject = ["$injector"];
        function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil) {
          this.$window = $window;
          this.$timeout = $timeout;
          this.$mdUtil = $mdUtil;
          this.$scope = $scope;
          this.$element = $element;
          this.options = rippleOptions;
          this.mousedown = false;
          this.ripples = [];
          this.timeout = null;
          this.lastRipple = null;
          $mdUtil.valueOnUse(this, 'container', this.createContainer);
          this.$element.addClass('md-ink-ripple');
          ($element.controller('mdInkRipple') || {}).createRipple = angular.bind(this, this.createRipple);
          ($element.controller('mdInkRipple') || {}).setColor = angular.bind(this, this.color);
          this.bindEvents();
        }
        InkRippleCtrl.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil"];
        function autoCleanup(self, cleanupFn) {
          if (self.mousedown || self.lastRipple) {
            self.mousedown = false;
            self.$mdUtil.nextTick(angular.bind(self, cleanupFn), false);
          }
        }
        InkRippleCtrl.prototype.color = function(value) {
          var self = this;
          if (angular.isDefined(value)) {
            self._color = self._parseColor(value);
          }
          return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor());
          function getElementColor() {
            var items = self.options && self.options.colorElement ? self.options.colorElement : [];
            var elem = items.length ? items[0] : self.$element[0];
            return elem ? self.$window.getComputedStyle(elem).color : 'rgb(0,0,0)';
          }
        };
        InkRippleCtrl.prototype.calculateColor = function() {
          return this.color();
        };
        InkRippleCtrl.prototype._parseColor = function parseColor(color, multiplier) {
          multiplier = multiplier || 1;
          if (!color)
            return;
          if (color.indexOf('rgba') === 0)
            return color.replace(/\d?\.?\d*\s*\)\s*$/, (0.1 * multiplier).toString() + ')');
          if (color.indexOf('rgb') === 0)
            return rgbToRGBA(color);
          if (color.indexOf('#') === 0)
            return hexToRGBA(color);
          function hexToRGBA(color) {
            var hex = color[0] === '#' ? color.substr(1) : color,
                dig = hex.length / 3,
                red = hex.substr(0, dig),
                green = hex.substr(dig, dig),
                blue = hex.substr(dig * 2);
            if (dig === 1) {
              red += red;
              green += green;
              blue += blue;
            }
            return 'rgba(' + parseInt(red, 16) + ',' + parseInt(green, 16) + ',' + parseInt(blue, 16) + ',0.1)';
          }
          function rgbToRGBA(color) {
            return color.replace(')', ', 0.1)').replace('(', 'a(');
          }
        };
        InkRippleCtrl.prototype.bindEvents = function() {
          this.$element.on('mousedown', angular.bind(this, this.handleMousedown));
          this.$element.on('mouseup touchend', angular.bind(this, this.handleMouseup));
          this.$element.on('mouseleave', angular.bind(this, this.handleMouseup));
          this.$element.on('touchmove', angular.bind(this, this.handleTouchmove));
        };
        InkRippleCtrl.prototype.handleMousedown = function(event) {
          if (this.mousedown)
            return;
          if (event.hasOwnProperty('originalEvent'))
            event = event.originalEvent;
          this.mousedown = true;
          if (this.options.center) {
            this.createRipple(this.container.prop('clientWidth') / 2, this.container.prop('clientWidth') / 2);
          } else {
            if (event.srcElement !== this.$element[0]) {
              var layerRect = this.$element[0].getBoundingClientRect();
              var layerX = event.clientX - layerRect.left;
              var layerY = event.clientY - layerRect.top;
              this.createRipple(layerX, layerY);
            } else {
              this.createRipple(event.offsetX, event.offsetY);
            }
          }
        };
        InkRippleCtrl.prototype.handleMouseup = function() {
          autoCleanup(this, this.clearRipples);
        };
        InkRippleCtrl.prototype.handleTouchmove = function() {
          autoCleanup(this, this.deleteRipples);
        };
        InkRippleCtrl.prototype.deleteRipples = function() {
          for (var i = 0; i < this.ripples.length; i++) {
            this.ripples[i].remove();
          }
        };
        InkRippleCtrl.prototype.clearRipples = function() {
          for (var i = 0; i < this.ripples.length; i++) {
            this.fadeInComplete(this.ripples[i]);
          }
        };
        InkRippleCtrl.prototype.createContainer = function() {
          var container = angular.element('<div class="md-ripple-container"></div>');
          this.$element.append(container);
          return container;
        };
        InkRippleCtrl.prototype.clearTimeout = function() {
          if (this.timeout) {
            this.$timeout.cancel(this.timeout);
            this.timeout = null;
          }
        };
        InkRippleCtrl.prototype.isRippleAllowed = function() {
          var element = this.$element[0];
          do {
            if (!element.tagName || element.tagName === 'BODY')
              break;
            if (element && angular.isFunction(element.hasAttribute)) {
              if (element.hasAttribute('disabled'))
                return false;
              if (this.inkRipple() === 'false' || this.inkRipple() === '0')
                return false;
            }
          } while (element = element.parentNode);
          return true;
        };
        InkRippleCtrl.prototype.inkRipple = function() {
          return this.$element.attr('md-ink-ripple');
        };
        InkRippleCtrl.prototype.createRipple = function(left, top) {
          if (!this.isRippleAllowed())
            return;
          var ctrl = this;
          var ripple = angular.element('<div class="md-ripple"></div>');
          var width = this.$element.prop('clientWidth');
          var height = this.$element.prop('clientHeight');
          var x = Math.max(Math.abs(width - left), left) * 2;
          var y = Math.max(Math.abs(height - top), top) * 2;
          var size = getSize(this.options.fitRipple, x, y);
          var color = this.calculateColor();
          ripple.css({
            left: left + 'px',
            top: top + 'px',
            background: 'black',
            width: size + 'px',
            height: size + 'px',
            backgroundColor: rgbaToRGB(color),
            borderColor: rgbaToRGB(color)
          });
          this.lastRipple = ripple;
          this.clearTimeout();
          this.timeout = this.$timeout(function() {
            ctrl.clearTimeout();
            if (!ctrl.mousedown)
              ctrl.fadeInComplete(ripple);
          }, DURATION * 0.35, false);
          if (this.options.dimBackground)
            this.container.css({backgroundColor: color});
          this.container.append(ripple);
          this.ripples.push(ripple);
          ripple.addClass('md-ripple-placed');
          this.$mdUtil.nextTick(function() {
            ripple.addClass('md-ripple-scaled md-ripple-active');
            ctrl.$timeout(function() {
              ctrl.clearRipples();
            }, DURATION, false);
          }, false);
          function rgbaToRGB(color) {
            return color ? color.replace('rgba', 'rgb').replace(/,[^\),]+\)/, ')') : 'rgb(0,0,0)';
          }
          function getSize(fit, x, y) {
            return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
          }
        };
        InkRippleCtrl.prototype.fadeInComplete = function(ripple) {
          if (this.lastRipple === ripple) {
            if (!this.timeout && !this.mousedown) {
              this.removeRipple(ripple);
            }
          } else {
            this.removeRipple(ripple);
          }
        };
        InkRippleCtrl.prototype.removeRipple = function(ripple) {
          var ctrl = this;
          var index = this.ripples.indexOf(ripple);
          if (index < 0)
            return;
          this.ripples.splice(this.ripples.indexOf(ripple), 1);
          ripple.removeClass('md-ripple-active');
          if (this.ripples.length === 0)
            this.container.css({backgroundColor: ''});
          this.$timeout(function() {
            ctrl.fadeOutComplete(ripple);
          }, DURATION, false);
        };
        InkRippleCtrl.prototype.fadeOutComplete = function(ripple) {
          ripple.remove();
          this.lastRipple = null;
        };
        function attrNoDirective() {
          return {controller: angular.noop};
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdTabInkRipple', MdTabInkRipple);
          function MdTabInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: 'full'
              }, options));
            }
            ;
          }
          MdTabInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core.theming.palette', []).constant('$mdColorPalette', {
          'red': {
            '50': '#ffebee',
            '100': '#ffcdd2',
            '200': '#ef9a9a',
            '300': '#e57373',
            '400': '#ef5350',
            '500': '#f44336',
            '600': '#e53935',
            '700': '#d32f2f',
            '800': '#c62828',
            '900': '#b71c1c',
            'A100': '#ff8a80',
            'A200': '#ff5252',
            'A400': '#ff1744',
            'A700': '#d50000',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 A100',
            'contrastStrongLightColors': '400 500 600 700 A200 A400 A700'
          },
          'pink': {
            '50': '#fce4ec',
            '100': '#f8bbd0',
            '200': '#f48fb1',
            '300': '#f06292',
            '400': '#ec407a',
            '500': '#e91e63',
            '600': '#d81b60',
            '700': '#c2185b',
            '800': '#ad1457',
            '900': '#880e4f',
            'A100': '#ff80ab',
            'A200': '#ff4081',
            'A400': '#f50057',
            'A700': '#c51162',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '500 600 A200 A400 A700'
          },
          'purple': {
            '50': '#f3e5f5',
            '100': '#e1bee7',
            '200': '#ce93d8',
            '300': '#ba68c8',
            '400': '#ab47bc',
            '500': '#9c27b0',
            '600': '#8e24aa',
            '700': '#7b1fa2',
            '800': '#6a1b9a',
            '900': '#4a148c',
            'A100': '#ea80fc',
            'A200': '#e040fb',
            'A400': '#d500f9',
            'A700': '#aa00ff',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200 A400 A700'
          },
          'deep-purple': {
            '50': '#ede7f6',
            '100': '#d1c4e9',
            '200': '#b39ddb',
            '300': '#9575cd',
            '400': '#7e57c2',
            '500': '#673ab7',
            '600': '#5e35b1',
            '700': '#512da8',
            '800': '#4527a0',
            '900': '#311b92',
            'A100': '#b388ff',
            'A200': '#7c4dff',
            'A400': '#651fff',
            'A700': '#6200ea',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200'
          },
          'indigo': {
            '50': '#e8eaf6',
            '100': '#c5cae9',
            '200': '#9fa8da',
            '300': '#7986cb',
            '400': '#5c6bc0',
            '500': '#3f51b5',
            '600': '#3949ab',
            '700': '#303f9f',
            '800': '#283593',
            '900': '#1a237e',
            'A100': '#8c9eff',
            'A200': '#536dfe',
            'A400': '#3d5afe',
            'A700': '#304ffe',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200 A400'
          },
          'blue': {
            '50': '#e3f2fd',
            '100': '#bbdefb',
            '200': '#90caf9',
            '300': '#64b5f6',
            '400': '#42a5f5',
            '500': '#2196f3',
            '600': '#1e88e5',
            '700': '#1976d2',
            '800': '#1565c0',
            '900': '#0d47a1',
            'A100': '#82b1ff',
            'A200': '#448aff',
            'A400': '#2979ff',
            'A700': '#2962ff',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 400 A100',
            'contrastStrongLightColors': '500 600 700 A200 A400 A700'
          },
          'light-blue': {
            '50': '#e1f5fe',
            '100': '#b3e5fc',
            '200': '#81d4fa',
            '300': '#4fc3f7',
            '400': '#29b6f6',
            '500': '#03a9f4',
            '600': '#039be5',
            '700': '#0288d1',
            '800': '#0277bd',
            '900': '#01579b',
            'A100': '#80d8ff',
            'A200': '#40c4ff',
            'A400': '#00b0ff',
            'A700': '#0091ea',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900 A700',
            'contrastStrongLightColors': '600 700 800 A700'
          },
          'cyan': {
            '50': '#e0f7fa',
            '100': '#b2ebf2',
            '200': '#80deea',
            '300': '#4dd0e1',
            '400': '#26c6da',
            '500': '#00bcd4',
            '600': '#00acc1',
            '700': '#0097a7',
            '800': '#00838f',
            '900': '#006064',
            'A100': '#84ffff',
            'A200': '#18ffff',
            'A400': '#00e5ff',
            'A700': '#00b8d4',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '700 800 900',
            'contrastStrongLightColors': '700 800 900'
          },
          'teal': {
            '50': '#e0f2f1',
            '100': '#b2dfdb',
            '200': '#80cbc4',
            '300': '#4db6ac',
            '400': '#26a69a',
            '500': '#009688',
            '600': '#00897b',
            '700': '#00796b',
            '800': '#00695c',
            '900': '#004d40',
            'A100': '#a7ffeb',
            'A200': '#64ffda',
            'A400': '#1de9b6',
            'A700': '#00bfa5',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '500 600 700 800 900',
            'contrastStrongLightColors': '500 600 700'
          },
          'green': {
            '50': '#e8f5e9',
            '100': '#c8e6c9',
            '200': '#a5d6a7',
            '300': '#81c784',
            '400': '#66bb6a',
            '500': '#4caf50',
            '600': '#43a047',
            '700': '#388e3c',
            '800': '#2e7d32',
            '900': '#1b5e20',
            'A100': '#b9f6ca',
            'A200': '#69f0ae',
            'A400': '#00e676',
            'A700': '#00c853',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900',
            'contrastStrongLightColors': '600 700'
          },
          'light-green': {
            '50': '#f1f8e9',
            '100': '#dcedc8',
            '200': '#c5e1a5',
            '300': '#aed581',
            '400': '#9ccc65',
            '500': '#8bc34a',
            '600': '#7cb342',
            '700': '#689f38',
            '800': '#558b2f',
            '900': '#33691e',
            'A100': '#ccff90',
            'A200': '#b2ff59',
            'A400': '#76ff03',
            'A700': '#64dd17',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '700 800 900',
            'contrastStrongLightColors': '700 800 900'
          },
          'lime': {
            '50': '#f9fbe7',
            '100': '#f0f4c3',
            '200': '#e6ee9c',
            '300': '#dce775',
            '400': '#d4e157',
            '500': '#cddc39',
            '600': '#c0ca33',
            '700': '#afb42b',
            '800': '#9e9d24',
            '900': '#827717',
            'A100': '#f4ff81',
            'A200': '#eeff41',
            'A400': '#c6ff00',
            'A700': '#aeea00',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '900',
            'contrastStrongLightColors': '900'
          },
          'yellow': {
            '50': '#fffde7',
            '100': '#fff9c4',
            '200': '#fff59d',
            '300': '#fff176',
            '400': '#ffee58',
            '500': '#ffeb3b',
            '600': '#fdd835',
            '700': '#fbc02d',
            '800': '#f9a825',
            '900': '#f57f17',
            'A100': '#ffff8d',
            'A200': '#ffff00',
            'A400': '#ffea00',
            'A700': '#ffd600',
            'contrastDefaultColor': 'dark'
          },
          'amber': {
            '50': '#fff8e1',
            '100': '#ffecb3',
            '200': '#ffe082',
            '300': '#ffd54f',
            '400': '#ffca28',
            '500': '#ffc107',
            '600': '#ffb300',
            '700': '#ffa000',
            '800': '#ff8f00',
            '900': '#ff6f00',
            'A100': '#ffe57f',
            'A200': '#ffd740',
            'A400': '#ffc400',
            'A700': '#ffab00',
            'contrastDefaultColor': 'dark'
          },
          'orange': {
            '50': '#fff3e0',
            '100': '#ffe0b2',
            '200': '#ffcc80',
            '300': '#ffb74d',
            '400': '#ffa726',
            '500': '#ff9800',
            '600': '#fb8c00',
            '700': '#f57c00',
            '800': '#ef6c00',
            '900': '#e65100',
            'A100': '#ffd180',
            'A200': '#ffab40',
            'A400': '#ff9100',
            'A700': '#ff6d00',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '800 900',
            'contrastStrongLightColors': '800 900'
          },
          'deep-orange': {
            '50': '#fbe9e7',
            '100': '#ffccbc',
            '200': '#ffab91',
            '300': '#ff8a65',
            '400': '#ff7043',
            '500': '#ff5722',
            '600': '#f4511e',
            '700': '#e64a19',
            '800': '#d84315',
            '900': '#bf360c',
            'A100': '#ff9e80',
            'A200': '#ff6e40',
            'A400': '#ff3d00',
            'A700': '#dd2c00',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 400 A100 A200',
            'contrastStrongLightColors': '500 600 700 800 900 A400 A700'
          },
          'brown': {
            '50': '#efebe9',
            '100': '#d7ccc8',
            '200': '#bcaaa4',
            '300': '#a1887f',
            '400': '#8d6e63',
            '500': '#795548',
            '600': '#6d4c41',
            '700': '#5d4037',
            '800': '#4e342e',
            '900': '#3e2723',
            'A100': '#d7ccc8',
            'A200': '#bcaaa4',
            'A400': '#8d6e63',
            'A700': '#5d4037',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200',
            'contrastStrongLightColors': '300 400'
          },
          'grey': {
            '50': '#fafafa',
            '100': '#f5f5f5',
            '200': '#eeeeee',
            '300': '#e0e0e0',
            '400': '#bdbdbd',
            '500': '#9e9e9e',
            '600': '#757575',
            '700': '#616161',
            '800': '#424242',
            '900': '#212121',
            '1000': '#000000',
            'A100': '#ffffff',
            'A200': '#eeeeee',
            'A400': '#bdbdbd',
            'A700': '#616161',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900'
          },
          'blue-grey': {
            '50': '#eceff1',
            '100': '#cfd8dc',
            '200': '#b0bec5',
            '300': '#90a4ae',
            '400': '#78909c',
            '500': '#607d8b',
            '600': '#546e7a',
            '700': '#455a64',
            '800': '#37474f',
            '900': '#263238',
            'A100': '#cfd8dc',
            'A200': '#b0bec5',
            'A400': '#78909c',
            'A700': '#455a64',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300',
            'contrastStrongLightColors': '400 500'
          }
        });
      })();
      (function() {
        "use strict";
        angular.module('material.core.theming', ['material.core.theming.palette']).directive('mdTheme', ThemingDirective).directive('mdThemable', ThemableDirective).provider('$mdTheming', ThemingProvider).run(generateAllThemes);
        var GENERATED = {};
        var PALETTES;
        var THEMES;
        var DARK_FOREGROUND = {
          name: 'dark',
          '1': 'rgba(0,0,0,0.87)',
          '2': 'rgba(0,0,0,0.54)',
          '3': 'rgba(0,0,0,0.26)',
          '4': 'rgba(0,0,0,0.12)'
        };
        var LIGHT_FOREGROUND = {
          name: 'light',
          '1': 'rgba(255,255,255,1.0)',
          '2': 'rgba(255,255,255,0.7)',
          '3': 'rgba(255,255,255,0.3)',
          '4': 'rgba(255,255,255,0.12)'
        };
        var DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)';
        var LIGHT_SHADOW = '';
        var DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)');
        var LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87)');
        var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)');
        var THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background'];
        var DEFAULT_COLOR_TYPE = 'primary';
        var LIGHT_DEFAULT_HUES = {
          'accent': {
            'default': 'A200',
            'hue-1': 'A100',
            'hue-2': 'A400',
            'hue-3': 'A700'
          },
          'background': {
            'default': 'A100',
            'hue-1': '300',
            'hue-2': '800',
            'hue-3': '900'
          }
        };
        var DARK_DEFAULT_HUES = {'background': {
            'default': '800',
            'hue-1': '600',
            'hue-2': '300',
            'hue-3': '900'
          }};
        THEME_COLOR_TYPES.forEach(function(colorType) {
          var defaultDefaultHues = {
            'default': '500',
            'hue-1': '300',
            'hue-2': '800',
            'hue-3': 'A100'
          };
          if (!LIGHT_DEFAULT_HUES[colorType])
            LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;
          if (!DARK_DEFAULT_HUES[colorType])
            DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;
        });
        var VALID_HUE_VALUES = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', 'A100', 'A200', 'A400', 'A700'];
        var generateOnDemand = false;
        function ThemingProvider($mdColorPalette) {
          PALETTES = {};
          THEMES = {};
          var themingProvider;
          var defaultTheme = 'default';
          var alwaysWatchTheme = false;
          angular.extend(PALETTES, $mdColorPalette);
          ThemingService.$inject = ["$rootScope", "$log"];
          return themingProvider = {
            definePalette: definePalette,
            extendPalette: extendPalette,
            theme: registerTheme,
            setDefaultTheme: function(theme) {
              defaultTheme = theme;
            },
            alwaysWatchTheme: function(alwaysWatch) {
              alwaysWatchTheme = alwaysWatch;
            },
            generateThemesOnDemand: function(onDemand) {
              generateOnDemand = onDemand;
            },
            $get: ThemingService,
            _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
            _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
            _PALETTES: PALETTES,
            _THEMES: THEMES,
            _parseRules: parseRules,
            _rgba: rgba
          };
          function definePalette(name, map) {
            map = map || {};
            PALETTES[name] = checkPaletteValid(name, map);
            return themingProvider;
          }
          function extendPalette(name, map) {
            return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
          }
          function checkPaletteValid(name, map) {
            var missingColors = VALID_HUE_VALUES.filter(function(field) {
              return !map[field];
            });
            if (missingColors.length) {
              throw new Error("Missing colors %1 in palette %2!".replace('%1', missingColors.join(', ')).replace('%2', name));
            }
            return map;
          }
          function registerTheme(name, inheritFrom) {
            if (THEMES[name])
              return THEMES[name];
            inheritFrom = inheritFrom || 'default';
            var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom;
            var theme = new Theme(name);
            if (parentTheme) {
              angular.forEach(parentTheme.colors, function(color, colorType) {
                theme.colors[colorType] = {
                  name: color.name,
                  hues: angular.extend({}, color.hues)
                };
              });
            }
            THEMES[name] = theme;
            return theme;
          }
          function Theme(name) {
            var self = this;
            self.name = name;
            self.colors = {};
            self.dark = setDark;
            setDark(false);
            function setDark(isDark) {
              isDark = arguments.length === 0 ? true : !!isDark;
              if (isDark === self.isDark)
                return;
              self.isDark = isDark;
              self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
              self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
              var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
              var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
              angular.forEach(newDefaultHues, function(newDefaults, colorType) {
                var color = self.colors[colorType];
                var oldDefaults = oldDefaultHues[colorType];
                if (color) {
                  for (var hueName in color.hues) {
                    if (color.hues[hueName] === oldDefaults[hueName]) {
                      color.hues[hueName] = newDefaults[hueName];
                    }
                  }
                }
              });
              return self;
            }
            THEME_COLOR_TYPES.forEach(function(colorType) {
              var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
              self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {
                var color = self.colors[colorType] = {
                  name: paletteName,
                  hues: angular.extend({}, defaultHues, hues)
                };
                Object.keys(color.hues).forEach(function(name) {
                  if (!defaultHues[name]) {
                    throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace('%1', name).replace('%2', self.name).replace('%3', paletteName).replace('%4', Object.keys(defaultHues).join(', ')));
                  }
                });
                Object.keys(color.hues).map(function(key) {
                  return color.hues[key];
                }).forEach(function(hueValue) {
                  if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {
                    throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace('%1', hueValue).replace('%2', self.name).replace('%3', colorType).replace('%4', paletteName).replace('%5', VALID_HUE_VALUES.join(', ')));
                  }
                });
                return self;
              };
              self[colorType + 'Color'] = function() {
                var args = Array.prototype.slice.call(arguments);
                console.warn('$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' + 'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.');
                return self[colorType + 'Palette'].apply(self, args);
              };
            });
          }
          function ThemingService($rootScope, $log) {
            applyTheme.inherit = function(el, parent) {
              var ctrl = parent.controller('mdTheme');
              var attrThemeValue = el.attr('md-theme-watch');
              if ((alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != 'false') {
                var deregisterWatch = $rootScope.$watch(function() {
                  return ctrl && ctrl.$mdTheme || (defaultTheme == 'default' ? '' : defaultTheme);
                }, changeTheme);
                el.on('$destroy', deregisterWatch);
              } else {
                var theme = ctrl && ctrl.$mdTheme || (defaultTheme == 'default' ? '' : defaultTheme);
                changeTheme(theme);
              }
              function changeTheme(theme) {
                if (!theme)
                  return;
                if (!registered(theme)) {
                  $log.warn('Attempted to use unregistered theme \'' + theme + '\'. ' + 'Register it with $mdThemingProvider.theme().');
                }
                var oldTheme = el.data('$mdThemeName');
                if (oldTheme)
                  el.removeClass('md-' + oldTheme + '-theme');
                el.addClass('md-' + theme + '-theme');
                el.data('$mdThemeName', theme);
                if (ctrl) {
                  el.data('$mdThemeController', ctrl);
                }
              }
            };
            applyTheme.THEMES = angular.extend({}, THEMES);
            applyTheme.defaultTheme = function() {
              return defaultTheme;
            };
            applyTheme.registered = registered;
            applyTheme.generateTheme = generateTheme;
            return applyTheme;
            function registered(themeName) {
              if (themeName === undefined || themeName === '')
                return true;
              return applyTheme.THEMES[themeName] !== undefined;
            }
            function applyTheme(scope, el) {
              if (el === undefined) {
                el = scope;
                scope = undefined;
              }
              if (scope === undefined) {
                scope = $rootScope;
              }
              applyTheme.inherit(el, el);
            }
          }
        }
        ThemingProvider.$inject = ["$mdColorPalette"];
        function ThemingDirective($mdTheming, $interpolate, $log) {
          return {
            priority: 100,
            link: {pre: function(scope, el, attrs) {
                var ctrl = {$setTheme: function(theme) {
                    if (!$mdTheming.registered(theme)) {
                      $log.warn('attempted to use unregistered theme \'' + theme + '\'');
                    }
                    ctrl.$mdTheme = theme;
                  }};
                el.data('$mdThemeController', ctrl);
                ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
                attrs.$observe('mdTheme', ctrl.$setTheme);
              }}
          };
        }
        ThemingDirective.$inject = ["$mdTheming", "$interpolate", "$log"];
        function ThemableDirective($mdTheming) {
          return $mdTheming;
        }
        ThemableDirective.$inject = ["$mdTheming"];
        function parseRules(theme, colorType, rules) {
          checkValidPalette(theme, colorType);
          rules = rules.replace(/THEME_NAME/g, theme.name);
          var generatedRules = [];
          var color = theme.colors[colorType];
          var themeNameRegex = new RegExp('.md-' + theme.name + '-theme', 'g');
          var hueRegex = new RegExp('(\'|")?{{\\s*(' + colorType + ')-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|\')?', 'g');
          var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g;
          var palette = PALETTES[color.name];
          rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity, contrast) {
            if (colorType === 'foreground') {
              if (hue == 'shadow') {
                return theme.foregroundShadow;
              } else {
                return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];
              }
            }
            if (hue.indexOf('hue') === 0) {
              hue = theme.colors[colorType].hues[hue];
            }
            return rgba((PALETTES[theme.colors[colorType].name][hue] || '')[contrast ? 'contrast' : 'value'], opacity);
          });
          angular.forEach(color.hues, function(hueValue, hueName) {
            var newRule = rules.replace(hueRegex, function(match, _, colorType, hueType, opacity) {
              return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);
            });
            if (hueName !== 'default') {
              newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);
            }
            if (theme.name == 'default') {
              var themeRuleRegex = /((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;
              newRule = newRule.replace(themeRuleRegex, function(match, prefix, target, suffix) {
                return match + ', ' + prefix + target + suffix;
              });
            }
            generatedRules.push(newRule);
          });
          return generatedRules;
        }
        var rulesByType = {};
        function generateAllThemes($injector) {
          var head = document.head;
          var firstChild = head ? head.firstElementChild : null;
          var themeCss = $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : '';
          if (!firstChild)
            return;
          if (themeCss.length === 0)
            return;
          angular.forEach(PALETTES, sanitizePalette);
          var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function(rule) {
            return rule && rule.length;
          }).map(function(rule) {
            return rule.trim() + '}';
          });
          var ruleMatchRegex = new RegExp('md-(' + THEME_COLOR_TYPES.join('|') + ')', 'g');
          THEME_COLOR_TYPES.forEach(function(type) {
            rulesByType[type] = '';
          });
          rules.forEach(function(rule) {
            var match = rule.match(ruleMatchRegex);
            for (var i = 0,
                type; type = THEME_COLOR_TYPES[i]; i++) {
              if (rule.indexOf('.md-' + type) > -1) {
                return rulesByType[type] += rule;
              }
            }
            for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {
              if (rule.indexOf(type) > -1) {
                return rulesByType[type] += rule;
              }
            }
            return rulesByType[DEFAULT_COLOR_TYPE] += rule;
          });
          if (generateOnDemand)
            return;
          angular.forEach(THEMES, function(theme) {
            if (!GENERATED[theme.name]) {
              generateTheme(theme.name);
            }
          });
          function sanitizePalette(palette) {
            var defaultContrast = palette.contrastDefaultColor;
            var lightColors = palette.contrastLightColors || [];
            var strongLightColors = palette.contrastStrongLightColors || [];
            var darkColors = palette.contrastDarkColors || [];
            if (typeof lightColors === 'string')
              lightColors = lightColors.split(' ');
            if (typeof strongLightColors === 'string')
              strongLightColors = strongLightColors.split(' ');
            if (typeof darkColors === 'string')
              darkColors = darkColors.split(' ');
            delete palette.contrastDefaultColor;
            delete palette.contrastLightColors;
            delete palette.contrastStrongLightColors;
            delete palette.contrastDarkColors;
            angular.forEach(palette, function(hueValue, hueName) {
              if (angular.isObject(hueValue))
                return;
              var rgbValue = colorToRgbaArray(hueValue);
              if (!rgbValue) {
                throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace('%1', hueValue).replace('%2', palette.name).replace('%3', hueName));
              }
              palette[hueName] = {
                value: rgbValue,
                contrast: getContrastColor()
              };
              function getContrastColor() {
                if (defaultContrast === 'light') {
                  if (darkColors.indexOf(hueName) > -1) {
                    return DARK_CONTRAST_COLOR;
                  } else {
                    return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                  }
                } else {
                  if (lightColors.indexOf(hueName) > -1) {
                    return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                  } else {
                    return DARK_CONTRAST_COLOR;
                  }
                }
              }
            });
          }
        }
        generateAllThemes.$inject = ["$injector"];
        function generateTheme(name) {
          var theme = THEMES[name];
          var head = document.head;
          var firstChild = head ? head.firstElementChild : null;
          if (!GENERATED[name]) {
            THEME_COLOR_TYPES.forEach(function(colorType) {
              var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);
              while (styleStrings.length) {
                var styleContent = styleStrings.shift();
                if (styleContent) {
                  var style = document.createElement('style');
                  style.setAttribute('md-theme-style', '');
                  style.appendChild(document.createTextNode(styleContent));
                  head.insertBefore(style, firstChild);
                }
              }
            });
            if (theme.colors.primary.name == theme.colors.accent.name) {
              console.warn('$mdThemingProvider: Using the same palette for primary and' + ' accent. This violates the material design spec.');
            }
            GENERATED[theme.name] = true;
          }
        }
        function checkValidPalette(theme, colorType) {
          if (!PALETTES[(theme.colors[colorType] || {}).name]) {
            throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace('%1', theme.name).replace('%2', colorType).replace('%3', Object.keys(PALETTES).join(', ')));
          }
        }
        function colorToRgbaArray(clr) {
          if (angular.isArray(clr) && clr.length == 3)
            return clr;
          if (/^rgb/.test(clr)) {
            return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, '').split(',').map(function(value, i) {
              return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);
            });
          }
          if (clr.charAt(0) == '#')
            clr = clr.substring(1);
          if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr))
            return;
          var dig = clr.length / 3;
          var red = clr.substr(0, dig);
          var grn = clr.substr(dig, dig);
          var blu = clr.substr(dig * 2);
          if (dig === 1) {
            red += red;
            grn += grn;
            blu += blu;
          }
          return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];
        }
        function rgba(rgbArray, opacity) {
          if (!rgbArray)
            return "rgb('0,0,0')";
          if (rgbArray.length == 4) {
            rgbArray = angular.copy(rgbArray);
            opacity ? rgbArray.pop() : opacity = rgbArray.pop();
          }
          return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ? 'rgba(' + rgbArray.join(',') + ',' + opacity + ')' : 'rgb(' + rgbArray.join(',') + ')';
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$$mdAnimate', ["$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss) {
          return function($mdUtil) {
            return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss);
          };
        }]);
        function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
          var self;
          return self = {
            translate3d: function(target, from, to, options) {
              return $animateCss(target, {
                from: from,
                to: to,
                addClass: options.transitionInClass
              }).start().then(function() {
                return reverseTranslate;
              });
              function reverseTranslate(newFrom) {
                return $animateCss(target, {
                  to: newFrom || from,
                  addClass: options.transitionOutClass,
                  removeClass: options.transitionInClass
                }).start();
              }
            },
            waitTransitionEnd: function(element, opts) {
              var TIMEOUT = 3000;
              return $q(function(resolve, reject) {
                opts = opts || {};
                var timer = $timeout(finished, opts.timeout || TIMEOUT);
                element.on($mdConstant.CSS.TRANSITIONEND, finished);
                function finished(ev) {
                  if (ev && ev.target !== element[0])
                    return;
                  if (ev)
                    $timeout.cancel(timer);
                  element.off($mdConstant.CSS.TRANSITIONEND, finished);
                  resolve();
                }
              });
            },
            calculateZoomToOrigin: function(element, originator) {
              var origin = originator.element;
              var bounds = originator.bounds;
              var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )";
              var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);
              var zoomStyle = buildZoom({
                centerX: 0,
                centerY: 0,
                scaleX: 0.5,
                scaleY: 0.5
              });
              if (origin || bounds) {
                var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds);
                var dialogRect = self.copyRect(element[0].getBoundingClientRect());
                var dialogCenterPt = self.centerPointFor(dialogRect);
                var originCenterPt = self.centerPointFor(originBnds);
                zoomStyle = buildZoom({
                  centerX: originCenterPt.x - dialogCenterPt.x,
                  centerY: originCenterPt.y - dialogCenterPt.y,
                  scaleX: Math.round(100 * Math.min(0.5, originBnds.width / dialogRect.width)) / 100,
                  scaleY: Math.round(100 * Math.min(0.5, originBnds.height / dialogRect.height)) / 100
                });
              }
              return zoomStyle;
              function currentBounds() {
                var cntr = element ? element.parent() : null;
                var parent = cntr ? cntr.parent() : null;
                return parent ? self.clientRect(parent) : null;
              }
            },
            toCss: function(raw) {
              var css = {};
              var lookups = 'left top right bottom width height x y min-width min-height max-width max-height';
              angular.forEach(raw, function(value, key) {
                if (angular.isUndefined(value))
                  return;
                if (lookups.indexOf(key) >= 0) {
                  css[key] = value + 'px';
                } else {
                  switch (key) {
                    case 'transition':
                      convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
                      break;
                    case 'transform':
                      convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
                      break;
                    case 'transformOrigin':
                      convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
                      break;
                  }
                }
              });
              return css;
              function convertToVendor(key, vendor, value) {
                angular.forEach(vendor.split(' '), function(key) {
                  css[key] = value;
                });
              }
            },
            toTransformCss: function(transform, addTransition, transition) {
              var css = {};
              angular.forEach($mdConstant.CSS.TRANSFORM.split(' '), function(key) {
                css[key] = transform;
              });
              if (addTransition) {
                transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
                css['transition'] = transition;
              }
              return css;
            },
            copyRect: function(source, destination) {
              if (!source)
                return null;
              destination = destination || {};
              angular.forEach('left top right bottom width height'.split(' '), function(key) {
                destination[key] = Math.round(source[key]);
              });
              destination.width = destination.width || (destination.right - destination.left);
              destination.height = destination.height || (destination.bottom - destination.top);
              return destination;
            },
            clientRect: function(element) {
              var bounds = angular.element(element)[0].getBoundingClientRect();
              var isPositiveSizeClientRect = function(rect) {
                return rect && (rect.width > 0) && (rect.height > 0);
              };
              return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
            },
            centerPointFor: function(targetRect) {
              return targetRect ? {
                x: Math.round(targetRect.left + (targetRect.width / 2)),
                y: Math.round(targetRect.top + (targetRect.height / 2))
              } : {
                x: 0,
                y: 0
              };
            }
          };
        }
        ;
      })();
      (function() {
        "use strict";
        "use strict";
        if (angular.version.minor >= 4) {
          angular.module('material.core.animate', []);
        } else {
          (function() {
            var forEach = angular.forEach;
            var WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance);
            var TRANSITION_PROP = WEBKIT ? 'WebkitTransition' : 'transition';
            var ANIMATION_PROP = WEBKIT ? 'WebkitAnimation' : 'animation';
            var PREFIX = WEBKIT ? '-webkit-' : '';
            var TRANSITION_EVENTS = (WEBKIT ? 'webkitTransitionEnd ' : '') + 'transitionend';
            var ANIMATION_EVENTS = (WEBKIT ? 'webkitAnimationEnd ' : '') + 'animationend';
            var $$ForceReflowFactory = ['$document', function($document) {
              return function() {
                return $document[0].body.clientWidth + 1;
              };
            }];
            var $$rAFMutexFactory = ['$$rAF', function($$rAF) {
              return function() {
                var passed = false;
                $$rAF(function() {
                  passed = true;
                });
                return function(fn) {
                  passed ? fn() : $$rAF(fn);
                };
              };
            }];
            var $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {
              var INITIAL_STATE = 0;
              var DONE_PENDING_STATE = 1;
              var DONE_COMPLETE_STATE = 2;
              function AnimateRunner(host) {
                this.setHost(host);
                this._doneCallbacks = [];
                this._runInAnimationFrame = $$rAFMutex();
                this._state = 0;
              }
              AnimateRunner.prototype = {
                setHost: function(host) {
                  this.host = host || {};
                },
                done: function(fn) {
                  if (this._state === DONE_COMPLETE_STATE) {
                    fn();
                  } else {
                    this._doneCallbacks.push(fn);
                  }
                },
                progress: angular.noop,
                getPromise: function() {
                  if (!this.promise) {
                    var self = this;
                    this.promise = $q(function(resolve, reject) {
                      self.done(function(status) {
                        status === false ? reject() : resolve();
                      });
                    });
                  }
                  return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                  return this.getPromise().then(resolveHandler, rejectHandler);
                },
                'catch': function(handler) {
                  return this.getPromise()['catch'](handler);
                },
                'finally': function(handler) {
                  return this.getPromise()['finally'](handler);
                },
                pause: function() {
                  if (this.host.pause) {
                    this.host.pause();
                  }
                },
                resume: function() {
                  if (this.host.resume) {
                    this.host.resume();
                  }
                },
                end: function() {
                  if (this.host.end) {
                    this.host.end();
                  }
                  this._resolve(true);
                },
                cancel: function() {
                  if (this.host.cancel) {
                    this.host.cancel();
                  }
                  this._resolve(false);
                },
                complete: function(response) {
                  var self = this;
                  if (self._state === INITIAL_STATE) {
                    self._state = DONE_PENDING_STATE;
                    self._runInAnimationFrame(function() {
                      self._resolve(response);
                    });
                  }
                },
                _resolve: function(response) {
                  if (this._state !== DONE_COMPLETE_STATE) {
                    forEach(this._doneCallbacks, function(fn) {
                      fn(response);
                    });
                    this._doneCallbacks.length = 0;
                    this._state = DONE_COMPLETE_STATE;
                  }
                }
              };
              return AnimateRunner;
            }];
            angular.module('material.core.animate', []).factory('$$forceReflow', $$ForceReflowFactory).factory('$$AnimateRunner', $$AnimateRunnerFactory).factory('$$rAFMutex', $$rAFMutexFactory).factory('$animateCss', ['$window', '$$rAF', '$$AnimateRunner', '$$forceReflow', '$$jqLite', '$timeout', function($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout) {
              function init(element, options) {
                var temporaryStyles = [];
                var node = getDomNode(element);
                if (options.transitionStyle) {
                  temporaryStyles.push([PREFIX + 'transition', options.transitionStyle]);
                }
                if (options.keyframeStyle) {
                  temporaryStyles.push([PREFIX + 'animation', options.keyframeStyle]);
                }
                if (options.delay) {
                  temporaryStyles.push([PREFIX + 'transition-delay', options.delay + 's']);
                }
                if (options.duration) {
                  temporaryStyles.push([PREFIX + 'transition-duration', options.duration + 's']);
                }
                var hasCompleteStyles = options.keyframeStyle || (options.to && (options.duration > 0 || options.transitionStyle));
                var hasCompleteClasses = !!options.addClass || !!options.removeClass;
                var hasCompleteAnimation = hasCompleteStyles || hasCompleteClasses;
                blockTransition(element, true);
                applyAnimationFromStyles(element, options);
                var animationClosed = false;
                var events,
                    eventFn;
                return {
                  close: $window.close,
                  start: function() {
                    var runner = new $$AnimateRunner();
                    waitUntilQuiet(function() {
                      blockTransition(element, false);
                      if (!hasCompleteAnimation) {
                        return close();
                      }
                      forEach(temporaryStyles, function(entry) {
                        var key = entry[0];
                        var value = entry[1];
                        node.style[camelCase(key)] = value;
                      });
                      applyClasses(element, options);
                      var timings = computeTimings(element);
                      if (timings.duration === 0) {
                        return close();
                      }
                      var moreStyles = [];
                      if (options.easing) {
                        if (timings.transitionDuration) {
                          moreStyles.push([PREFIX + 'transition-timing-function', options.easing]);
                        }
                        if (timings.animationDuration) {
                          moreStyles.push([PREFIX + 'animation-timing-function', options.easing]);
                        }
                      }
                      if (options.delay && timings.animationDelay) {
                        moreStyles.push([PREFIX + 'animation-delay', options.delay + 's']);
                      }
                      if (options.duration && timings.animationDuration) {
                        moreStyles.push([PREFIX + 'animation-duration', options.duration + 's']);
                      }
                      forEach(moreStyles, function(entry) {
                        var key = entry[0];
                        var value = entry[1];
                        node.style[camelCase(key)] = value;
                        temporaryStyles.push(entry);
                      });
                      var maxDelay = timings.delay;
                      var maxDelayTime = maxDelay * 1000;
                      var maxDuration = timings.duration;
                      var maxDurationTime = maxDuration * 1000;
                      var startTime = Date.now();
                      events = [];
                      if (timings.transitionDuration) {
                        events.push(TRANSITION_EVENTS);
                      }
                      if (timings.animationDuration) {
                        events.push(ANIMATION_EVENTS);
                      }
                      events = events.join(' ');
                      eventFn = function(event) {
                        event.stopPropagation();
                        var ev = event.originalEvent || event;
                        var timeStamp = ev.timeStamp || Date.now();
                        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                          close();
                        }
                      };
                      element.on(events, eventFn);
                      applyAnimationToStyles(element, options);
                      $timeout(close, maxDelayTime + maxDurationTime * 1.5, false);
                    });
                    return runner;
                    function close() {
                      if (animationClosed)
                        return;
                      animationClosed = true;
                      if (events && eventFn) {
                        element.off(events, eventFn);
                      }
                      applyClasses(element, options);
                      applyAnimationStyles(element, options);
                      forEach(temporaryStyles, function(entry) {
                        node.style[camelCase(entry[0])] = '';
                      });
                      runner.complete(true);
                      return runner;
                    }
                  }
                };
              }
              function applyClasses(element, options) {
                if (options.addClass) {
                  $$jqLite.addClass(element, options.addClass);
                  options.addClass = null;
                }
                if (options.removeClass) {
                  $$jqLite.removeClass(element, options.removeClass);
                  options.removeClass = null;
                }
              }
              function computeTimings(element) {
                var node = getDomNode(element);
                var cs = $window.getComputedStyle(node);
                var tdr = parseMaxTime(cs[prop('transitionDuration')]);
                var adr = parseMaxTime(cs[prop('animationDuration')]);
                var tdy = parseMaxTime(cs[prop('transitionDelay')]);
                var ady = parseMaxTime(cs[prop('animationDelay')]);
                adr *= (parseInt(cs[prop('animationIterationCount')], 10) || 1);
                var duration = Math.max(adr, tdr);
                var delay = Math.max(ady, tdy);
                return {
                  duration: duration,
                  delay: delay,
                  animationDuration: adr,
                  transitionDuration: tdr,
                  animationDelay: ady,
                  transitionDelay: tdy
                };
                function prop(key) {
                  return WEBKIT ? 'Webkit' + key.charAt(0).toUpperCase() + key.substr(1) : key;
                }
              }
              function parseMaxTime(str) {
                var maxValue = 0;
                var values = (str || "").split(/\s*,\s*/);
                forEach(values, function(value) {
                  if (value.charAt(value.length - 1) == 's') {
                    value = value.substring(0, value.length - 1);
                  }
                  value = parseFloat(value) || 0;
                  maxValue = maxValue ? Math.max(value, maxValue) : value;
                });
                return maxValue;
              }
              var cancelLastRAFRequest;
              var rafWaitQueue = [];
              function waitUntilQuiet(callback) {
                if (cancelLastRAFRequest) {
                  cancelLastRAFRequest();
                }
                rafWaitQueue.push(callback);
                cancelLastRAFRequest = $$rAF(function() {
                  cancelLastRAFRequest = null;
                  var pageWidth = $$forceReflow();
                  for (var i = 0; i < rafWaitQueue.length; i++) {
                    rafWaitQueue[i](pageWidth);
                  }
                  rafWaitQueue.length = 0;
                });
              }
              function applyAnimationStyles(element, options) {
                applyAnimationFromStyles(element, options);
                applyAnimationToStyles(element, options);
              }
              function applyAnimationFromStyles(element, options) {
                if (options.from) {
                  element.css(options.from);
                  options.from = null;
                }
              }
              function applyAnimationToStyles(element, options) {
                if (options.to) {
                  element.css(options.to);
                  options.to = null;
                }
              }
              function getDomNode(element) {
                for (var i = 0; i < element.length; i++) {
                  if (element[i].nodeType === 1)
                    return element[i];
                }
              }
              function blockTransition(element, bool) {
                var node = getDomNode(element);
                var key = camelCase(PREFIX + 'transition-delay');
                node.style[key] = bool ? '-9999s' : '';
              }
              return init;
            }]);
            function camelCase(str) {
              return str.replace(/-[a-z]/g, function(str) {
                return str.charAt(1).toUpperCase();
              });
            }
          })();
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.bottomSheet', ['material.core', 'material.components.backdrop']).directive('mdBottomSheet', MdBottomSheetDirective).provider('$mdBottomSheet', MdBottomSheetProvider);
        function MdBottomSheetDirective($mdBottomSheet) {
          return {
            restrict: 'E',
            link: function postLink(scope, element, attr) {
              scope.$on('$destroy', function() {
                $mdBottomSheet.destroy();
              });
            }
          };
        }
        MdBottomSheetDirective.$inject = ["$mdBottomSheet"];
        function MdBottomSheetProvider($$interimElementProvider) {
          var CLOSING_VELOCITY = 0.5;
          var PADDING = 80;
          bottomSheetDefaults.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture"];
          return $$interimElementProvider('$mdBottomSheet').setDefaults({
            methods: ['disableParentScroll', 'escapeToClose', 'clickOutsideToClose'],
            options: bottomSheetDefaults
          });
          function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture) {
            var backdrop;
            return {
              themable: true,
              onShow: onShow,
              onRemove: onRemove,
              escapeToClose: true,
              clickOutsideToClose: true,
              disableParentScroll: true
            };
            function onShow(scope, element, options, controller) {
              element = $mdUtil.extractElementByName(element, 'md-bottom-sheet');
              backdrop = $mdUtil.createBackdrop(scope, "md-bottom-sheet-backdrop md-opaque");
              if (options.clickOutsideToClose) {
                backdrop.on('click', function() {
                  $mdUtil.nextTick($mdBottomSheet.cancel, true);
                });
              }
              $mdTheming.inherit(backdrop, options.parent);
              $animate.enter(backdrop, options.parent, null);
              var bottomSheet = new BottomSheet(element, options.parent);
              options.bottomSheet = bottomSheet;
              $mdTheming.inherit(bottomSheet.element, options.parent);
              if (options.disableParentScroll) {
                options.restoreScroll = $mdUtil.disableScrollAround(bottomSheet.element, options.parent);
              }
              return $animate.enter(bottomSheet.element, options.parent).then(function() {
                var focusable = $mdUtil.findFocusTarget(element) || angular.element(element[0].querySelector('button') || element[0].querySelector('a') || element[0].querySelector('[ng-click]'));
                focusable.focus();
                if (options.escapeToClose) {
                  options.rootElementKeyupCallback = function(e) {
                    if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                      $mdUtil.nextTick($mdBottomSheet.cancel, true);
                    }
                  };
                  $rootElement.on('keyup', options.rootElementKeyupCallback);
                }
              });
            }
            function onRemove(scope, element, options) {
              var bottomSheet = options.bottomSheet;
              $animate.leave(backdrop);
              return $animate.leave(bottomSheet.element).then(function() {
                if (options.disableParentScroll) {
                  options.restoreScroll();
                  delete options.restoreScroll;
                }
                bottomSheet.cleanup();
              });
            }
            function BottomSheet(element, parent) {
              var deregister = $mdGesture.register(parent, 'drag', {horizontal: false});
              parent.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
              return {
                element: element,
                cleanup: function cleanup() {
                  deregister();
                  parent.off('$md.dragstart', onDragStart);
                  parent.off('$md.drag', onDrag);
                  parent.off('$md.dragend', onDragEnd);
                }
              };
              function onDragStart(ev) {
                element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');
              }
              function onDrag(ev) {
                var transform = ev.pointer.distanceY;
                if (transform < 5) {
                  transform = Math.max(-PADDING, transform / 2);
                }
                element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');
              }
              function onDragEnd(ev) {
                if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
                  var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY;
                  var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * 0.75, 500);
                  element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms');
                  $mdUtil.nextTick($mdBottomSheet.cancel, true);
                } else {
                  element.css($mdConstant.CSS.TRANSITION_DURATION, '');
                  element.css($mdConstant.CSS.TRANSFORM, '');
                }
              }
            }
          }
        }
        MdBottomSheetProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.backdrop', ['material.core']).directive('mdBackdrop', ["$mdTheming", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function BackdropDirective($mdTheming, $animate, $rootElement, $window, $log, $$rAF, $document) {
          var ERROR_CSS_POSITION = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container.";
          return {
            restrict: 'E',
            link: postLink
          };
          function postLink(scope, element, attrs) {
            var body = $window.getComputedStyle($document[0].body);
            if (body.position == 'fixed') {
              var hViewport = parseInt(body.height, 10) + Math.abs(parseInt(body.top, 10));
              element.css({height: hViewport + 'px'});
            }
            if ($animate.pin)
              $animate.pin(element, $rootElement);
            $$rAF(function() {
              var parent = element.parent()[0];
              if (parent) {
                if (parent.nodeName == 'BODY') {
                  element.css({position: 'fixed'});
                }
                var styles = $window.getComputedStyle(parent);
                if (styles.position == 'static') {
                  $log.warn(ERROR_CSS_POSITION);
                }
              }
              $mdTheming.inherit(element, element.parent());
            });
          }
        }]);
      })();
      (function() {
        "use strict";
        angular.module('material.components.button', ['material.core']).directive('mdButton', MdButtonDirective);
        function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {
          return {
            restrict: 'EA',
            replace: true,
            transclude: true,
            template: getTemplate,
            link: postLink
          };
          function isAnchor(attr) {
            return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);
          }
          function getTemplate(element, attr) {
            if (isAnchor(attr)) {
              return '<a class="md-button" ng-transclude></a>';
            } else {
              var btnType = (typeof attr.type === 'undefined') ? 'button' : attr.type;
              return '<button class="md-button" type="' + btnType + '" ng-transclude></button>';
            }
          }
          function postLink(scope, element, attr) {
            var node = element[0];
            $mdTheming(element);
            $mdButtonInkRipple.attach(scope, element);
            var elementHasText = node.textContent.trim();
            if (!elementHasText) {
              $mdAria.expect(element, 'aria-label');
            }
            if (isAnchor(attr) && angular.isDefined(attr.ngDisabled)) {
              scope.$watch(attr.ngDisabled, function(isDisabled) {
                element.attr('tabindex', isDisabled ? -1 : 0);
              });
            }
            element.on('click', function(e) {
              if (attr.disabled === true) {
                e.preventDefault();
                e.stopImmediatePropagation();
              }
            });
            scope.mouseActive = false;
            element.on('mousedown', function() {
              scope.mouseActive = true;
              $timeout(function() {
                scope.mouseActive = false;
              }, 100);
            }).on('focus', function() {
              if (scope.mouseActive === false) {
                element.addClass('md-focused');
              }
            }).on('blur', function(ev) {
              element.removeClass('md-focused');
            });
          }
        }
        MdButtonDirective.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.card', ['material.core']).directive('mdCard', mdCardDirective);
        function mdCardDirective($mdTheming) {
          return {
            restrict: 'E',
            link: function($scope, $element) {
              $mdTheming($element);
            }
          };
        }
        mdCardDirective.$inject = ["$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.checkbox', ['material.core']).directive('mdCheckbox', MdCheckboxDirective);
        function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {
          inputDirective = inputDirective[0];
          var CHECKED_CSS = 'md-checked';
          return {
            restrict: 'E',
            transclude: true,
            require: '?ngModel',
            priority: 210,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-icon"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            compile: compile
          };
          function compile(tElement, tAttrs) {
            tAttrs.type = 'checkbox';
            tAttrs.tabindex = tAttrs.tabindex || '0';
            tElement.attr('role', tAttrs.type);
            tElement.on('click', function(event) {
              if (this.hasAttribute('disabled')) {
                event.stopImmediatePropagation();
              }
            });
            return function postLink(scope, element, attr, ngModelCtrl) {
              ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();
              $mdTheming(element);
              if (attr.ngChecked) {
                scope.$watch(scope.$eval.bind(scope, attr.ngChecked), ngModelCtrl.$setViewValue.bind(ngModelCtrl));
              }
              $$watchExpr('ngDisabled', 'tabindex', {
                true: '-1',
                false: attr.tabindex
              });
              $mdAria.expectWithText(element, 'aria-label');
              inputDirective.link.pre(scope, {
                on: angular.noop,
                0: {}
              }, attr, [ngModelCtrl]);
              scope.mouseActive = false;
              element.on('click', listener).on('keypress', keypressHandler).on('mousedown', function() {
                scope.mouseActive = true;
                $timeout(function() {
                  scope.mouseActive = false;
                }, 100);
              }).on('focus', function() {
                if (scope.mouseActive === false) {
                  element.addClass('md-focused');
                }
              }).on('blur', function() {
                element.removeClass('md-focused');
              });
              ngModelCtrl.$render = render;
              function $$watchExpr(expr, htmlAttr, valueOpts) {
                if (attr[expr]) {
                  scope.$watch(attr[expr], function(val) {
                    if (valueOpts[val]) {
                      element.attr(htmlAttr, valueOpts[val]);
                    }
                  });
                }
              }
              function keypressHandler(ev) {
                var keyCode = ev.which || ev.keyCode;
                if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {
                  ev.preventDefault();
                  if (!element.hasClass('md-focused')) {
                    element.addClass('md-focused');
                  }
                  listener(ev);
                }
              }
              function listener(ev) {
                if (element[0].hasAttribute('disabled')) {
                  return;
                }
                scope.$apply(function() {
                  var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;
                  ngModelCtrl.$setViewValue(viewValue, ev && ev.type);
                  ngModelCtrl.$render();
                });
              }
              function render() {
                if (ngModelCtrl.$viewValue) {
                  element.addClass(CHECKED_CSS);
                } else {
                  element.removeClass(CHECKED_CSS);
                }
              }
            };
          }
        }
        MdCheckboxDirective.$inject = ["inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips', ['material.core', 'material.components.autocomplete']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.content', ['material.core']).directive('mdContent', mdContentDirective);
        function mdContentDirective($mdTheming) {
          return {
            restrict: 'E',
            controller: ['$scope', '$element', ContentController],
            link: function(scope, element, attr) {
              var node = element[0];
              $mdTheming(element);
              scope.$broadcast('$mdContentLoaded', element);
              iosScrollFix(element[0]);
            }
          };
          function ContentController($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
          }
        }
        mdContentDirective.$inject = ["$mdTheming"];
        function iosScrollFix(node) {
          angular.element(node).on('$md.pressdown', function(ev) {
            if (ev.pointer.type !== 't')
              return;
            if (ev.$materialScrollFixed)
              return;
            ev.$materialScrollFixed = true;
            if (node.scrollTop === 0) {
              node.scrollTop = 1;
            } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {
              node.scrollTop -= 1;
            }
          });
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']).directive('mdCalendar', calendarDirective);
          var TBODY_HEIGHT = 265;
          var TBODY_SINGLE_ROW_HEIGHT = 45;
          function calendarDirective() {
            return {
              template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table>' + '<div class="md-calendar-scroll-mask">' + '<md-virtual-repeat-container class="md-calendar-scroll-container" ' + 'md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '">' + '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' + '<tbody role="rowgroup" md-virtual-repeat="i in ctrl.items" md-calendar-month ' + 'md-month-offset="$index" class="md-calendar-month" ' + 'md-start-index="ctrl.getSelectedMonthIndex()" ' + 'md-item-size="' + TBODY_HEIGHT + '"></tbody>' + '</table>' + '</md-virtual-repeat-container>' + '</div>',
              scope: {
                minDate: '=mdMinDate',
                maxDate: '=mdMaxDate',
                dateFilter: '=mdDateFilter'
              },
              require: ['ngModel', 'mdCalendar'],
              controller: CalendarCtrl,
              controllerAs: 'ctrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var ngModelCtrl = controllers[0];
                var mdCalendarCtrl = controllers[1];
                mdCalendarCtrl.configureNgModel(ngModelCtrl);
              }
            };
          }
          var SELECTED_DATE_CLASS = 'md-calendar-selected-date';
          var FOCUSED_DATE_CLASS = 'md-focus';
          var nextUniqueId = 0;
          var firstRenderableDate = null;
          function CalendarCtrl($element, $attrs, $scope, $animate, $q, $mdConstant, $mdTheming, $$mdDateUtil, $mdDateLocale, $mdInkRipple, $mdUtil) {
            $mdTheming($element);
            this.items = {length: 2000};
            if (this.maxDate && this.minDate) {
              var numMonths = $$mdDateUtil.getMonthDistance(this.minDate, this.maxDate) + 1;
              numMonths = Math.max(numMonths, 1);
              numMonths += 1;
              this.items.length = numMonths;
            }
            this.$animate = $animate;
            this.$q = $q;
            this.$mdInkRipple = $mdInkRipple;
            this.$mdUtil = $mdUtil;
            this.keyCode = $mdConstant.KEY_CODE;
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.$element = $element;
            this.$scope = $scope;
            this.calendarElement = $element[0].querySelector('.md-calendar');
            this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller');
            this.today = this.dateUtil.createDateAtMidnight();
            this.firstRenderableDate = this.dateUtil.incrementMonths(this.today, -this.items.length / 2);
            if (this.minDate && this.minDate > this.firstRenderableDate) {
              this.firstRenderableDate = this.minDate;
            } else if (this.maxDate) {
              var monthDifference = this.items.length - 2;
              this.firstRenderableDate = this.dateUtil.incrementMonths(this.maxDate, -(this.items.length - 2));
            }
            this.id = nextUniqueId++;
            this.ngModelCtrl = null;
            this.selectedDate = null;
            this.displayDate = null;
            this.focusDate = null;
            this.isInitialized = false;
            this.isMonthTransitionInProgress = false;
            if (!$attrs['tabindex']) {
              $element.attr('tabindex', '-1');
            }
            var self = this;
            this.cellClickHandler = function() {
              var cellElement = this;
              if (this.hasAttribute('data-timestamp')) {
                $scope.$apply(function() {
                  var timestamp = Number(cellElement.getAttribute('data-timestamp'));
                  self.setNgModelValue(self.dateUtil.createDateAtMidnight(timestamp));
                });
              }
            };
            this.attachCalendarEventListeners();
          }
          CalendarCtrl.$inject = ["$element", "$attrs", "$scope", "$animate", "$q", "$mdConstant", "$mdTheming", "$$mdDateUtil", "$mdDateLocale", "$mdInkRipple", "$mdUtil"];
          CalendarCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            this.ngModelCtrl = ngModelCtrl;
            var self = this;
            ngModelCtrl.$render = function() {
              self.changeSelectedDate(self.ngModelCtrl.$viewValue);
            };
          };
          CalendarCtrl.prototype.buildInitialCalendarDisplay = function() {
            this.buildWeekHeader();
            this.hideVerticalScrollbar();
            this.displayDate = this.selectedDate || this.today;
            this.isInitialized = true;
          };
          CalendarCtrl.prototype.hideVerticalScrollbar = function() {
            var element = this.$element[0];
            var scrollMask = element.querySelector('.md-calendar-scroll-mask');
            var scroller = this.calendarScroller;
            var headerWidth = element.querySelector('.md-calendar-day-header').clientWidth;
            var scrollbarWidth = scroller.offsetWidth - scroller.clientWidth;
            scrollMask.style.width = headerWidth + 'px';
            scroller.style.width = (headerWidth + scrollbarWidth) + 'px';
            scroller.style.paddingRight = scrollbarWidth + 'px';
          };
          CalendarCtrl.prototype.attachCalendarEventListeners = function() {
            this.$element.on('keydown', angular.bind(this, this.handleKeyEvent));
          };
          CalendarCtrl.prototype.handleKeyEvent = function(event) {
            var self = this;
            this.$scope.$apply(function() {
              if (event.which == self.keyCode.ESCAPE || event.which == self.keyCode.TAB) {
                self.$scope.$emit('md-calendar-close');
                if (event.which == self.keyCode.TAB) {
                  event.preventDefault();
                }
                return;
              }
              if (event.which === self.keyCode.ENTER) {
                self.setNgModelValue(self.displayDate);
                event.preventDefault();
                return;
              }
              var date = self.getFocusDateFromKeyEvent(event);
              if (date) {
                date = self.boundDateByMinAndMax(date);
                event.preventDefault();
                event.stopPropagation();
                self.changeDisplayDate(date).then(function() {
                  self.focus(date);
                });
              }
            });
          };
          CalendarCtrl.prototype.getFocusDateFromKeyEvent = function(event) {
            var dateUtil = this.dateUtil;
            var keyCode = this.keyCode;
            switch (event.which) {
              case keyCode.RIGHT_ARROW:
                return dateUtil.incrementDays(this.displayDate, 1);
              case keyCode.LEFT_ARROW:
                return dateUtil.incrementDays(this.displayDate, -1);
              case keyCode.DOWN_ARROW:
                return event.metaKey ? dateUtil.incrementMonths(this.displayDate, 1) : dateUtil.incrementDays(this.displayDate, 7);
              case keyCode.UP_ARROW:
                return event.metaKey ? dateUtil.incrementMonths(this.displayDate, -1) : dateUtil.incrementDays(this.displayDate, -7);
              case keyCode.PAGE_DOWN:
                return dateUtil.incrementMonths(this.displayDate, 1);
              case keyCode.PAGE_UP:
                return dateUtil.incrementMonths(this.displayDate, -1);
              case keyCode.HOME:
                return dateUtil.getFirstDateOfMonth(this.displayDate);
              case keyCode.END:
                return dateUtil.getLastDateOfMonth(this.displayDate);
              default:
                return null;
            }
          };
          CalendarCtrl.prototype.getSelectedMonthIndex = function() {
            return this.dateUtil.getMonthDistance(this.firstRenderableDate, this.selectedDate || this.today);
          };
          CalendarCtrl.prototype.scrollToMonth = function(date) {
            if (!this.dateUtil.isValidDate(date)) {
              return;
            }
            var monthDistance = this.dateUtil.getMonthDistance(this.firstRenderableDate, date);
            this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
          };
          CalendarCtrl.prototype.setNgModelValue = function(date) {
            this.$scope.$emit('md-calendar-change', date);
            this.ngModelCtrl.$setViewValue(date);
            this.ngModelCtrl.$render();
          };
          CalendarCtrl.prototype.focus = function(opt_date) {
            var date = opt_date || this.selectedDate || this.today;
            var previousFocus = this.calendarElement.querySelector('.md-focus');
            if (previousFocus) {
              previousFocus.classList.remove(FOCUSED_DATE_CLASS);
            }
            var cellId = this.getDateId(date);
            var cell = document.getElementById(cellId);
            if (cell) {
              cell.classList.add(FOCUSED_DATE_CLASS);
              cell.focus();
            } else {
              this.focusDate = date;
            }
          };
          CalendarCtrl.prototype.boundDateByMinAndMax = function(date) {
            var boundDate = date;
            if (this.minDate && date < this.minDate) {
              boundDate = new Date(this.minDate.getTime());
            }
            if (this.maxDate && date > this.maxDate) {
              boundDate = new Date(this.maxDate.getTime());
            }
            return boundDate;
          };
          CalendarCtrl.prototype.changeSelectedDate = function(date) {
            var self = this;
            var previousSelectedDate = this.selectedDate;
            this.selectedDate = date;
            this.changeDisplayDate(date).then(function() {
              if (previousSelectedDate) {
                var prevDateCell = document.getElementById(self.getDateId(previousSelectedDate));
                if (prevDateCell) {
                  prevDateCell.classList.remove(SELECTED_DATE_CLASS);
                  prevDateCell.setAttribute('aria-selected', 'false');
                }
              }
              if (date) {
                var dateCell = document.getElementById(self.getDateId(date));
                if (dateCell) {
                  dateCell.classList.add(SELECTED_DATE_CLASS);
                  dateCell.setAttribute('aria-selected', 'true');
                }
              }
            });
          };
          CalendarCtrl.prototype.changeDisplayDate = function(date) {
            if (!this.isInitialized) {
              this.buildInitialCalendarDisplay();
              return this.$q.when();
            }
            if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) {
              return this.$q.when();
            }
            this.isMonthTransitionInProgress = true;
            var animationPromise = this.animateDateChange(date);
            this.displayDate = date;
            var self = this;
            animationPromise.then(function() {
              self.isMonthTransitionInProgress = false;
            });
            return animationPromise;
          };
          CalendarCtrl.prototype.animateDateChange = function(date) {
            this.scrollToMonth(date);
            return this.$q.when();
          };
          CalendarCtrl.prototype.buildWeekHeader = function() {
            var firstDayOfWeek = this.dateLocale.firstDayOfWeek;
            var shortDays = this.dateLocale.shortDays;
            var row = document.createElement('tr');
            for (var i = 0; i < 7; i++) {
              var th = document.createElement('th');
              th.textContent = shortDays[(i + firstDayOfWeek) % 7];
              row.appendChild(th);
            }
            this.$element.find('thead').append(row);
          };
          CalendarCtrl.prototype.getDateId = function(date) {
            return ['md', this.id, date.getFullYear(), date.getMonth(), date.getDate()].join('-');
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdCalendarMonth', mdCalendarMonthDirective);
          function mdCalendarMonthDirective() {
            return {
              require: ['^^mdCalendar', 'mdCalendarMonth'],
              scope: {offset: '=mdMonthOffset'},
              controller: CalendarMonthCtrl,
              controllerAs: 'mdMonthCtrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var calendarCtrl = controllers[0];
                var monthCtrl = controllers[1];
                monthCtrl.calendarCtrl = calendarCtrl;
                monthCtrl.generateContent();
                scope.$watch(function() {
                  return monthCtrl.offset;
                }, function(offset, oldOffset) {
                  if (offset != oldOffset) {
                    monthCtrl.generateContent();
                  }
                });
              }
            };
          }
          var TODAY_CLASS = 'md-calendar-date-today';
          var SELECTED_DATE_CLASS = 'md-calendar-selected-date';
          var FOCUSED_DATE_CLASS = 'md-focus';
          function CalendarMonthCtrl($element, $$mdDateUtil, $mdDateLocale) {
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.$element = $element;
            this.calendarCtrl = null;
            this.offset;
            this.focusAfterAppend = null;
          }
          CalendarMonthCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
          CalendarMonthCtrl.prototype.generateContent = function() {
            var calendarCtrl = this.calendarCtrl;
            var date = this.dateUtil.incrementMonths(calendarCtrl.firstRenderableDate, this.offset);
            this.$element.empty();
            this.$element.append(this.buildCalendarForMonth(date));
            if (this.focusAfterAppend) {
              this.focusAfterAppend.classList.add(FOCUSED_DATE_CLASS);
              this.focusAfterAppend.focus();
              this.focusAfterAppend = null;
            }
          };
          CalendarMonthCtrl.prototype.buildDateCell = function(opt_date) {
            var calendarCtrl = this.calendarCtrl;
            var cell = document.createElement('td');
            cell.tabIndex = -1;
            cell.classList.add('md-calendar-date');
            cell.setAttribute('role', 'gridcell');
            if (opt_date) {
              cell.setAttribute('tabindex', '-1');
              cell.setAttribute('aria-label', this.dateLocale.longDateFormatter(opt_date));
              cell.id = calendarCtrl.getDateId(opt_date);
              cell.setAttribute('data-timestamp', opt_date.getTime());
              if (this.dateUtil.isSameDay(opt_date, calendarCtrl.today)) {
                cell.classList.add(TODAY_CLASS);
              }
              if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate)) {
                cell.classList.add(SELECTED_DATE_CLASS);
                cell.setAttribute('aria-selected', 'true');
              }
              var cellText = this.dateLocale.dates[opt_date.getDate()];
              if (this.isDateEnabled(opt_date)) {
                var selectionIndicator = document.createElement('span');
                cell.appendChild(selectionIndicator);
                selectionIndicator.classList.add('md-calendar-date-selection-indicator');
                selectionIndicator.textContent = cellText;
                cell.addEventListener('click', calendarCtrl.cellClickHandler);
                if (calendarCtrl.focusDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.focusDate)) {
                  this.focusAfterAppend = cell;
                }
              } else {
                cell.classList.add('md-calendar-date-disabled');
                cell.textContent = cellText;
              }
            }
            return cell;
          };
          CalendarMonthCtrl.prototype.isDateEnabled = function(opt_date) {
            return this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date));
          };
          CalendarMonthCtrl.prototype.buildDateRow = function(rowNumber) {
            var row = document.createElement('tr');
            row.setAttribute('role', 'row');
            row.setAttribute('aria-label', this.dateLocale.weekNumberFormatter(rowNumber));
            return row;
          };
          CalendarMonthCtrl.prototype.buildCalendarForMonth = function(opt_dateInMonth) {
            var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date();
            var firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date);
            var firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth);
            var numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date);
            var monthBody = document.createDocumentFragment();
            var rowNumber = 1;
            var row = this.buildDateRow(rowNumber);
            monthBody.appendChild(row);
            var isFinalMonth = this.offset === this.calendarCtrl.items.length - 1;
            var blankCellOffset = 0;
            var monthLabelCell = document.createElement('td');
            monthLabelCell.classList.add('md-calendar-month-label');
            if (this.calendarCtrl.maxDate && firstDayOfMonth > this.calendarCtrl.maxDate) {
              monthLabelCell.classList.add('md-calendar-month-label-disabled');
            }
            monthLabelCell.textContent = this.dateLocale.monthHeaderFormatter(date);
            if (firstDayOfTheWeek <= 2) {
              monthLabelCell.setAttribute('colspan', '7');
              var monthLabelRow = this.buildDateRow();
              monthLabelRow.appendChild(monthLabelCell);
              monthBody.insertBefore(monthLabelRow, row);
              if (isFinalMonth) {
                return monthBody;
              }
            } else {
              blankCellOffset = 2;
              monthLabelCell.setAttribute('colspan', '2');
              row.appendChild(monthLabelCell);
            }
            for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) {
              row.appendChild(this.buildDateCell());
            }
            var dayOfWeek = firstDayOfTheWeek;
            var iterationDate = firstDayOfMonth;
            for (var d = 1; d <= numberOfDaysInMonth; d++) {
              if (dayOfWeek === 7) {
                if (isFinalMonth) {
                  return monthBody;
                }
                dayOfWeek = 0;
                rowNumber++;
                row = this.buildDateRow(rowNumber);
                monthBody.appendChild(row);
              }
              iterationDate.setDate(d);
              var cell = this.buildDateCell(iterationDate);
              row.appendChild(cell);
              dayOfWeek++;
            }
            while (row.childNodes.length < 7) {
              row.appendChild(this.buildDateCell());
            }
            while (monthBody.childNodes.length < 6) {
              var whitespaceRow = this.buildDateRow();
              for (var i = 0; i < 7; i++) {
                whitespaceRow.appendChild(this.buildDateCell());
              }
              monthBody.appendChild(whitespaceRow);
            }
            return monthBody;
          };
          CalendarMonthCtrl.prototype.getLocaleDay_ = function(date) {
            return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').config(["$provide", function($provide) {
            function DateLocaleProvider() {
              this.months = null;
              this.shortMonths = null;
              this.days = null;
              this.shortDays = null;
              this.dates = null;
              this.firstDayOfWeek = 0;
              this.formatDate = null;
              this.parseDate = null;
              this.monthHeaderFormatter = null;
              this.weekNumberFormatter = null;
              this.longDateFormatter = null;
              this.msgCalendar = '';
              this.msgOpenCalendar = '';
            }
            DateLocaleProvider.prototype.$get = function($locale) {
              function defaultFormatDate(date) {
                if (!date) {
                  return '';
                }
                var localeTime = date.toLocaleTimeString();
                var formatDate = date;
                if (date.getHours() == 0 && (localeTime.indexOf('11:') !== -1 || localeTime.indexOf('23:') !== -1)) {
                  formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0);
                }
                return formatDate.toLocaleDateString();
              }
              function defaultParseDate(dateString) {
                return new Date(dateString);
              }
              function defaultIsDateComplete(dateString) {
                dateString = dateString.trim();
                var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
                return re.test(dateString);
              }
              function defaultMonthHeaderFormatter(date) {
                return service.shortMonths[date.getMonth()] + ' ' + date.getFullYear();
              }
              function defaultWeekNumberFormatter(number) {
                return 'Week ' + number;
              }
              function defaultLongDateFormatter(date) {
                return [service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear()].join(' ');
              }
              var defaultShortDays = $locale.DATETIME_FORMATS.DAY.map(function(day) {
                return day[0];
              });
              var defaultDates = Array(32);
              for (var i = 1; i <= 31; i++) {
                defaultDates[i] = i;
              }
              var defaultMsgCalendar = 'Calendar';
              var defaultMsgOpenCalendar = 'Open calendar';
              var service = {
                months: this.months || $locale.DATETIME_FORMATS.MONTH,
                shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
                days: this.days || $locale.DATETIME_FORMATS.DAY,
                shortDays: this.shortDays || defaultShortDays,
                dates: this.dates || defaultDates,
                firstDayOfWeek: this.firstDayOfWeek || 0,
                formatDate: this.formatDate || defaultFormatDate,
                parseDate: this.parseDate || defaultParseDate,
                isDateComplete: this.isDateComplete || defaultIsDateComplete,
                monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter,
                weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter,
                longDateFormatter: this.longDateFormatter || defaultLongDateFormatter,
                msgCalendar: this.msgCalendar || defaultMsgCalendar,
                msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar
              };
              return service;
            };
            DateLocaleProvider.prototype.$get.$inject = ["$locale"];
            $provide.provider('$mdDateLocale', new DateLocaleProvider());
          }]);
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdDatepicker', datePickerDirective);
          function datePickerDirective() {
            return {
              template: '<md-button class="md-datepicker-button md-icon-button" type="button" ' + 'tabindex="-1" aria-hidden="true" ' + 'ng-click="ctrl.openCalendarPane($event)">' + '<md-icon class="md-datepicker-calendar-icon" md-svg-icon="md-calendar"></md-icon>' + '</md-button>' + '<div class="md-datepicker-input-container" ' + 'ng-class="{\'md-datepicker-focused\': ctrl.isFocused}">' + '<input class="md-datepicker-input" aria-haspopup="true" ' + 'ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)">' + '<md-button type="button" md-no-ink ' + 'class="md-datepicker-triangle-button md-icon-button" ' + 'ng-click="ctrl.openCalendarPane($event)" ' + 'aria-label="{{::ctrl.dateLocale.msgOpenCalendar}}">' + '<div class="md-datepicker-expand-triangle"></div>' + '</md-button>' + '</div>' + '<div class="md-datepicker-calendar-pane md-whiteframe-z1">' + '<div class="md-datepicker-input-mask">' + '<div class="md-datepicker-input-mask-opaque"></div>' + '</div>' + '<div class="md-datepicker-calendar">' + '<md-calendar role="dialog" aria-label="{{::ctrl.dateLocale.msgCalendar}}" ' + 'md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate"' + 'md-date-filter="ctrl.dateFilter"' + 'ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen">' + '</md-calendar>' + '</div>' + '</div>',
              require: ['ngModel', 'mdDatepicker', '?^mdInputContainer'],
              scope: {
                minDate: '=mdMinDate',
                maxDate: '=mdMaxDate',
                placeholder: '@mdPlaceholder',
                dateFilter: '=mdDateFilter'
              },
              controller: DatePickerCtrl,
              controllerAs: 'ctrl',
              bindToController: true,
              link: function(scope, element, attr, controllers) {
                var ngModelCtrl = controllers[0];
                var mdDatePickerCtrl = controllers[1];
                var mdInputContainer = controllers[2];
                if (mdInputContainer) {
                  throw Error('md-datepicker should not be placed inside md-input-container.');
                }
                mdDatePickerCtrl.configureNgModel(ngModelCtrl);
              }
            };
          }
          var EXTRA_INPUT_SIZE = 3;
          var INVALID_CLASS = 'md-datepicker-invalid';
          var DEFAULT_DEBOUNCE_INTERVAL = 500;
          var CALENDAR_PANE_HEIGHT = 368;
          var CALENDAR_PANE_WIDTH = 360;
          function DatePickerCtrl($scope, $element, $attrs, $compile, $timeout, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF) {
            this.$compile = $compile;
            this.$timeout = $timeout;
            this.$window = $window;
            this.dateLocale = $mdDateLocale;
            this.dateUtil = $$mdDateUtil;
            this.$mdConstant = $mdConstant;
            this.$mdUtil = $mdUtil;
            this.$$rAF = $$rAF;
            this.documentElement = angular.element(document.documentElement);
            this.ngModelCtrl = null;
            this.inputElement = $element[0].querySelector('input');
            this.ngInputElement = angular.element(this.inputElement);
            this.inputContainer = $element[0].querySelector('.md-datepicker-input-container');
            this.calendarPane = $element[0].querySelector('.md-datepicker-calendar-pane');
            this.calendarButton = $element[0].querySelector('.md-datepicker-button');
            this.inputMask = $element[0].querySelector('.md-datepicker-input-mask-opaque');
            this.$element = $element;
            this.$attrs = $attrs;
            this.$scope = $scope;
            this.date = null;
            this.isFocused = false;
            this.isDisabled;
            this.setDisabled($element[0].disabled || angular.isString($attrs['disabled']));
            this.isCalendarOpen = false;
            this.calendarPaneOpenedFrom = null;
            this.calendarPane.id = 'md-date-pane' + $mdUtil.nextUid();
            $mdTheming($element);
            this.bodyClickHandler = angular.bind(this, this.handleBodyClick);
            this.windowResizeHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100);
            if (!$attrs['tabindex']) {
              $element.attr('tabindex', '-1');
            }
            this.installPropertyInterceptors();
            this.attachChangeListeners();
            this.attachInteractionListeners();
            var self = this;
            $scope.$on('$destroy', function() {
              self.detachCalendarPane();
            });
          }
          DatePickerCtrl.$inject = ["$scope", "$element", "$attrs", "$compile", "$timeout", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF"];
          DatePickerCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            this.ngModelCtrl = ngModelCtrl;
            var self = this;
            ngModelCtrl.$render = function() {
              var value = self.ngModelCtrl.$viewValue;
              if (value && !(value instanceof Date)) {
                throw Error('The ng-model for md-datepicker must be a Date instance. ' + 'Currently the model is a: ' + (typeof value));
              }
              self.date = value;
              self.inputElement.value = self.dateLocale.formatDate(value);
              self.resizeInputElement();
              self.updateErrorState();
            };
          };
          DatePickerCtrl.prototype.attachChangeListeners = function() {
            var self = this;
            self.$scope.$on('md-calendar-change', function(event, date) {
              self.ngModelCtrl.$setViewValue(date);
              self.date = date;
              self.inputElement.value = self.dateLocale.formatDate(date);
              self.closeCalendarPane();
              self.resizeInputElement();
              self.updateErrorState();
            });
            self.ngInputElement.on('input', angular.bind(self, self.resizeInputElement));
            self.ngInputElement.on('input', self.$mdUtil.debounce(self.handleInputEvent, DEFAULT_DEBOUNCE_INTERVAL, self));
          };
          DatePickerCtrl.prototype.attachInteractionListeners = function() {
            var self = this;
            var $scope = this.$scope;
            var keyCodes = this.$mdConstant.KEY_CODE;
            self.ngInputElement.on('keydown', function(event) {
              if (event.altKey && event.keyCode == keyCodes.DOWN_ARROW) {
                self.openCalendarPane(event);
                $scope.$digest();
              }
            });
            $scope.$on('md-calendar-close', function() {
              self.closeCalendarPane();
            });
          };
          DatePickerCtrl.prototype.installPropertyInterceptors = function() {
            var self = this;
            if (this.$attrs['ngDisabled']) {
              var scope = this.$mdUtil.validateScope(this.$element) ? this.$element.scope() : null;
              if (scope) {
                scope.$watch(this.$attrs['ngDisabled'], function(isDisabled) {
                  self.setDisabled(isDisabled);
                });
              }
            }
            Object.defineProperty(this, 'placeholder', {
              get: function() {
                return self.inputElement.placeholder;
              },
              set: function(value) {
                self.inputElement.placeholder = value || '';
              }
            });
          };
          DatePickerCtrl.prototype.setDisabled = function(isDisabled) {
            this.isDisabled = isDisabled;
            this.inputElement.disabled = isDisabled;
            this.calendarButton.disabled = isDisabled;
          };
          DatePickerCtrl.prototype.updateErrorState = function(opt_date) {
            var date = opt_date || this.date;
            this.clearErrorState();
            if (this.dateUtil.isValidDate(date)) {
              if (this.dateUtil.isValidDate(this.minDate)) {
                this.ngModelCtrl.$setValidity('mindate', date >= this.minDate);
              }
              if (this.dateUtil.isValidDate(this.maxDate)) {
                this.ngModelCtrl.$setValidity('maxdate', date <= this.maxDate);
              }
              if (angular.isFunction(this.dateFilter)) {
                this.ngModelCtrl.$setValidity('filtered', this.dateFilter(date));
              }
            } else {
              this.ngModelCtrl.$setValidity('valid', date == null);
            }
            if (!this.ngModelCtrl.$valid) {
              this.inputContainer.classList.add(INVALID_CLASS);
            }
          };
          DatePickerCtrl.prototype.clearErrorState = function() {
            this.inputContainer.classList.remove(INVALID_CLASS);
            ['mindate', 'maxdate', 'filtered', 'valid'].forEach(function(field) {
              this.ngModelCtrl.$setValidity(field, true);
            }, this);
          };
          DatePickerCtrl.prototype.resizeInputElement = function() {
            this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE;
          };
          DatePickerCtrl.prototype.handleInputEvent = function() {
            var inputString = this.inputElement.value;
            var parsedDate = inputString ? this.dateLocale.parseDate(inputString) : null;
            this.dateUtil.setDateTimeToMidnight(parsedDate);
            var isValidInput = inputString == '' || (this.dateUtil.isValidDate(parsedDate) && this.dateLocale.isDateComplete(inputString) && this.isDateEnabled(parsedDate));
            if (isValidInput) {
              this.ngModelCtrl.$setViewValue(parsedDate);
              this.date = parsedDate;
            }
            this.updateErrorState(parsedDate);
          };
          DatePickerCtrl.prototype.isDateEnabled = function(opt_date) {
            return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date));
          };
          DatePickerCtrl.prototype.attachCalendarPane = function() {
            var calendarPane = this.calendarPane;
            calendarPane.style.transform = '';
            this.$element.addClass('md-datepicker-open');
            var elementRect = this.inputContainer.getBoundingClientRect();
            var bodyRect = document.body.getBoundingClientRect();
            var paneTop = elementRect.top - bodyRect.top;
            var paneLeft = elementRect.left - bodyRect.left;
            var viewportTop = (bodyRect.top < 0 && document.body.scrollTop == 0) ? -bodyRect.top : document.body.scrollTop;
            var viewportLeft = (bodyRect.left < 0 && document.body.scrollLeft == 0) ? -bodyRect.left : document.body.scrollLeft;
            var viewportBottom = viewportTop + this.$window.innerHeight;
            var viewportRight = viewportLeft + this.$window.innerWidth;
            if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight) {
              if (viewportRight - CALENDAR_PANE_WIDTH > 0) {
                paneLeft = viewportRight - CALENDAR_PANE_WIDTH;
              } else {
                paneLeft = viewportLeft;
                var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH;
                calendarPane.style.transform = 'scale(' + scale + ')';
              }
              calendarPane.classList.add('md-datepicker-pos-adjusted');
            }
            if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom && viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop) {
              paneTop = viewportBottom - CALENDAR_PANE_HEIGHT;
              calendarPane.classList.add('md-datepicker-pos-adjusted');
            }
            calendarPane.style.left = paneLeft + 'px';
            calendarPane.style.top = paneTop + 'px';
            document.body.appendChild(calendarPane);
            this.inputMask.style.left = elementRect.width + 'px';
            this.$$rAF(function() {
              calendarPane.classList.add('md-pane-open');
            });
          };
          DatePickerCtrl.prototype.detachCalendarPane = function() {
            this.$element.removeClass('md-datepicker-open');
            this.calendarPane.classList.remove('md-pane-open');
            this.calendarPane.classList.remove('md-datepicker-pos-adjusted');
            if (this.calendarPane.parentNode) {
              this.calendarPane.parentNode.removeChild(this.calendarPane);
            }
          };
          DatePickerCtrl.prototype.openCalendarPane = function(event) {
            if (!this.isCalendarOpen && !this.isDisabled) {
              this.isCalendarOpen = true;
              this.calendarPaneOpenedFrom = event.target;
              this.$mdUtil.disableScrollAround(this.calendarPane);
              this.attachCalendarPane();
              this.focusCalendar();
              var self = this;
              this.$mdUtil.nextTick(function() {
                self.documentElement.on('click touchstart', self.bodyClickHandler);
              }, false);
              window.addEventListener('resize', this.windowResizeHandler);
            }
          };
          DatePickerCtrl.prototype.closeCalendarPane = function() {
            if (this.isCalendarOpen) {
              this.isCalendarOpen = false;
              this.detachCalendarPane();
              this.calendarPaneOpenedFrom.focus();
              this.calendarPaneOpenedFrom = null;
              this.$mdUtil.enableScrolling();
              this.documentElement.off('click touchstart', this.bodyClickHandler);
              window.removeEventListener('resize', this.windowResizeHandler);
            }
          };
          DatePickerCtrl.prototype.getCalendarCtrl = function() {
            return angular.element(this.calendarPane.querySelector('md-calendar')).controller('mdCalendar');
          };
          DatePickerCtrl.prototype.focusCalendar = function() {
            var self = this;
            this.$mdUtil.nextTick(function() {
              self.getCalendarCtrl().focus();
            }, false);
          };
          DatePickerCtrl.prototype.setFocused = function(isFocused) {
            this.isFocused = isFocused;
          };
          DatePickerCtrl.prototype.handleBodyClick = function(event) {
            if (this.isCalendarOpen) {
              var isInCalendar = this.$mdUtil.getClosest(event.target, 'md-calendar');
              if (!isInCalendar) {
                this.closeCalendarPane();
              }
              this.$scope.$digest();
            }
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').factory('$$mdDateUtil', function() {
            return {
              getFirstDateOfMonth: getFirstDateOfMonth,
              getNumberOfDaysInMonth: getNumberOfDaysInMonth,
              getDateInNextMonth: getDateInNextMonth,
              getDateInPreviousMonth: getDateInPreviousMonth,
              isInNextMonth: isInNextMonth,
              isInPreviousMonth: isInPreviousMonth,
              getDateMidpoint: getDateMidpoint,
              isSameMonthAndYear: isSameMonthAndYear,
              getWeekOfMonth: getWeekOfMonth,
              incrementDays: incrementDays,
              incrementMonths: incrementMonths,
              getLastDateOfMonth: getLastDateOfMonth,
              isSameDay: isSameDay,
              getMonthDistance: getMonthDistance,
              isValidDate: isValidDate,
              setDateTimeToMidnight: setDateTimeToMidnight,
              createDateAtMidnight: createDateAtMidnight,
              isDateWithinRange: isDateWithinRange
            };
            function getFirstDateOfMonth(date) {
              return new Date(date.getFullYear(), date.getMonth(), 1);
            }
            function getNumberOfDaysInMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            }
            function getDateInNextMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 1);
            }
            function getDateInPreviousMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() - 1, 1);
            }
            function isSameMonthAndYear(d1, d2) {
              return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
            }
            function isSameDay(d1, d2) {
              return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);
            }
            function isInNextMonth(startDate, endDate) {
              var nextMonth = getDateInNextMonth(startDate);
              return isSameMonthAndYear(nextMonth, endDate);
            }
            function isInPreviousMonth(startDate, endDate) {
              var previousMonth = getDateInPreviousMonth(startDate);
              return isSameMonthAndYear(endDate, previousMonth);
            }
            function getDateMidpoint(d1, d2) {
              return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
            }
            function getWeekOfMonth(date) {
              var firstDayOfMonth = getFirstDateOfMonth(date);
              return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
            }
            function incrementDays(date, numberOfDays) {
              return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);
            }
            function incrementMonths(date, numberOfMonths) {
              var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1);
              var numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
              if (numberOfDaysInMonth < date.getDate()) {
                dateInTargetMonth.setDate(numberOfDaysInMonth);
              } else {
                dateInTargetMonth.setDate(date.getDate());
              }
              return dateInTargetMonth;
            }
            function getMonthDistance(start, end) {
              return (12 * (end.getFullYear() - start.getFullYear())) + (end.getMonth() - start.getMonth());
            }
            function getLastDateOfMonth(date) {
              return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));
            }
            function isValidDate(date) {
              return date != null && date.getTime && !isNaN(date.getTime());
            }
            function setDateTimeToMidnight(date) {
              if (isValidDate(date)) {
                date.setHours(0, 0, 0, 0);
              }
            }
            function createDateAtMidnight(opt_value) {
              var date;
              if (angular.isUndefined(opt_value)) {
                date = new Date();
              } else {
                date = new Date(opt_value);
              }
              setDateTimeToMidnight(date);
              return date;
            }
            function isDateWithinRange(date, minDate, maxDate) {
              return (!angular.isDate(minDate) || minDate <= date) && (!angular.isDate(maxDate) || maxDate >= date);
            }
          });
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.dialog', ['material.core', 'material.components.backdrop']).directive('mdDialog', MdDialogDirective).provider('$mdDialog', MdDialogProvider);
        function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {
          return {
            restrict: 'E',
            link: function(scope, element, attr) {
              $mdTheming(element);
              $$rAF(function() {
                var images;
                var content = element[0].querySelector('md-dialog-content');
                if (content) {
                  images = content.getElementsByTagName('img');
                  addOverflowClass();
                  angular.element(images).on('load', addOverflowClass);
                }
                scope.$on('$destroy', function() {
                  $mdDialog.destroy(element);
                });
                function addOverflowClass() {
                  element.toggleClass('md-content-overflow', content.scrollHeight > content.clientHeight);
                }
              });
            }
          };
        }
        MdDialogDirective.$inject = ["$$rAF", "$mdTheming", "$mdDialog"];
        function MdDialogProvider($$interimElementProvider) {
          var topFocusTrap,
              bottomFocusTrap;
          advancedDialogOptions.$inject = ["$mdDialog", "$mdTheming"];
          dialogDefaultOptions.$inject = ["$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector"];
          return $$interimElementProvider('$mdDialog').setDefaults({
            methods: ['disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent', 'closeTo', 'openFrom', 'parent', 'fullscreen'],
            options: dialogDefaultOptions
          }).addPreset('alert', {
            methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'theme', 'css'],
            options: advancedDialogOptions
          }).addPreset('confirm', {
            methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'cancel', 'theme', 'css'],
            options: advancedDialogOptions
          });
          function advancedDialogOptions($mdDialog, $mdTheming) {
            return {
              template: ['<md-dialog md-theme="{{ dialog.theme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', '        ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', '      <p>{{::dialog.mdTextContent}}</p>', '    </div>', '  </md-dialog-content>', '  <md-dialog-actions>', '    <md-button ng-if="dialog.$type == \'confirm\'"' + '               ng-click="dialog.abort()" class="md-primary">', '      {{ dialog.cancel }}', '    </md-button>', '    <md-button ng-click="dialog.hide()" class="md-primary" md-autofocus="dialog.$type!=\'confirm\'">', '      {{ dialog.ok }}', '    </md-button>', '  </md-dialog-actions>', '</md-dialog>'].join('').replace(/\s\s+/g, ''),
              controller: function mdDialogCtrl() {
                this.hide = function() {
                  $mdDialog.hide(true);
                };
                this.abort = function() {
                  $mdDialog.cancel();
                };
              },
              controllerAs: 'dialog',
              bindToController: true,
              theme: $mdTheming.defaultTheme()
            };
          }
          function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector) {
            return {
              hasBackdrop: true,
              isolateScope: true,
              onShow: onShow,
              onShowing: beforeShow,
              onRemove: onRemove,
              clickOutsideToClose: false,
              escapeToClose: true,
              targetEvent: null,
              closeTo: null,
              openFrom: null,
              focusOnOpen: true,
              disableParentScroll: true,
              autoWrap: true,
              fullscreen: false,
              transformTemplate: function(template, options) {
                return '<div class="md-dialog-container">' + validatedTemplate(template) + '</div>';
                function validatedTemplate(template) {
                  if (options.autoWrap && !/<\/md-dialog>/g.test(template)) {
                    return '<md-dialog>' + (template || '') + '</md-dialog>';
                  } else {
                    return template || '';
                  }
                }
              }
            };
            function beforeShow(scope, element, options, controller) {
              if (controller) {
                controller.mdHtmlContent = controller.htmlContent || options.htmlContent || '';
                controller.mdTextContent = controller.textContent || options.textContent || controller.content || options.content || '';
                if (controller.mdHtmlContent && !$injector.has('$sanitize')) {
                  throw Error('The ngSanitize module must be loaded in order to use htmlContent.');
                }
                if (controller.mdHtmlContent && controller.mdTextContent) {
                  throw Error('md-dialog cannot have both `htmlContent` and `textContent`');
                }
              }
            }
            function onShow(scope, element, options, controller) {
              angular.element($document[0].body).addClass('md-dialog-is-showing');
              captureParentAndFromToElements(options);
              configureAria(element.find('md-dialog'), options);
              showBackdrop(scope, element, options);
              return dialogPopIn(element, options).then(function() {
                activateListeners(element, options);
                lockScreenReader(element, options);
                warnDeprecatedActions();
                focusOnOpen();
              });
              function warnDeprecatedActions() {
                var badActions = element[0].querySelectorAll('.md-actions');
                if (badActions.length > 0) {
                  $log.warn('Using a class of md-actions is deprected, please use <md-dialog-actions>.');
                }
              }
              function focusOnOpen() {
                if (options.focusOnOpen) {
                  var target = $mdUtil.findFocusTarget(element) || findCloseButton();
                  target.focus();
                }
                function findCloseButton() {
                  var closeButton = element[0].querySelector('.dialog-close');
                  if (!closeButton) {
                    var actionButtons = element[0].querySelectorAll('.md-actions button, md-dialog-actions button');
                    closeButton = actionButtons[actionButtons.length - 1];
                  }
                  return angular.element(closeButton);
                }
              }
            }
            function onRemove(scope, element, options) {
              options.deactivateListeners();
              options.unlockScreenReader();
              options.hideBackdrop(options.$destroy);
              if (topFocusTrap && topFocusTrap.parentNode) {
                topFocusTrap.parentNode.removeChild(topFocusTrap);
              }
              if (bottomFocusTrap && bottomFocusTrap.parentNode) {
                bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
              }
              return !!options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);
              function animateRemoval() {
                return dialogPopOut(element, options);
              }
              function detachAndClean() {
                angular.element($document[0].body).removeClass('md-dialog-is-showing');
                element.remove();
                if (!options.$destroy)
                  options.origin.focus();
              }
            }
            function captureParentAndFromToElements(options) {
              options.origin = angular.extend({
                element: null,
                bounds: null,
                focus: angular.noop
              }, options.origin || {});
              options.parent = getDomElement(options.parent, $rootElement);
              options.closeTo = getBoundingClientRect(getDomElement(options.closeTo));
              options.openFrom = getBoundingClientRect(getDomElement(options.openFrom));
              if (options.targetEvent) {
                options.origin = getBoundingClientRect(options.targetEvent.target, options.origin);
              }
              function getBoundingClientRect(element, orig) {
                var source = angular.element((element || {}));
                if (source && source.length) {
                  var bounds = {
                    top: 0,
                    left: 0,
                    height: 0,
                    width: 0
                  };
                  var hasFn = angular.isFunction(source[0].getBoundingClientRect);
                  return angular.extend(orig || {}, {
                    element: hasFn ? source : undefined,
                    bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend({}, bounds, source[0]),
                    focus: angular.bind(source, source.focus)
                  });
                }
              }
              function getDomElement(element, defaultElement) {
                if (angular.isString(element)) {
                  var simpleSelector = element,
                      container = $document[0].querySelectorAll(simpleSelector);
                  element = container.length ? container[0] : null;
                }
                return angular.element(element || defaultElement);
              }
            }
            function activateListeners(element, options) {
              var window = angular.element($window);
              var onWindowResize = $mdUtil.debounce(function() {
                stretchDialogContainerToViewport(element, options);
              }, 60);
              var removeListeners = [];
              var smartClose = function() {
                var closeFn = (options.$type == 'alert') ? $mdDialog.hide : $mdDialog.cancel;
                $mdUtil.nextTick(closeFn, true);
              };
              if (options.escapeToClose) {
                var target = options.parent;
                var keyHandlerFn = function(ev) {
                  if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    smartClose();
                  }
                };
                element.on('keydown', keyHandlerFn);
                target.on('keydown', keyHandlerFn);
                window.on('resize', onWindowResize);
                removeListeners.push(function() {
                  element.off('keydown', keyHandlerFn);
                  target.off('keydown', keyHandlerFn);
                  window.off('resize', onWindowResize);
                });
              }
              if (options.clickOutsideToClose) {
                var target = element;
                var sourceElem;
                var mousedownHandler = function(ev) {
                  sourceElem = ev.target;
                };
                var mouseupHandler = function(ev) {
                  if (sourceElem === target[0] && ev.target === target[0]) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    smartClose();
                  }
                };
                target.on('mousedown', mousedownHandler);
                target.on('mouseup', mouseupHandler);
                removeListeners.push(function() {
                  target.off('mousedown', mousedownHandler);
                  target.off('mouseup', mouseupHandler);
                });
              }
              options.deactivateListeners = function() {
                removeListeners.forEach(function(removeFn) {
                  removeFn();
                });
                options.deactivateListeners = null;
              };
            }
            function showBackdrop(scope, element, options) {
              if (options.disableParentScroll) {
                options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent);
              }
              if (options.hasBackdrop) {
                options.backdrop = $mdUtil.createBackdrop(scope, "md-dialog-backdrop md-opaque");
                $animate.enter(options.backdrop, options.parent);
              }
              options.hideBackdrop = function hideBackdrop($destroy) {
                if (options.backdrop) {
                  if (!!$destroy)
                    options.backdrop.remove();
                  else
                    $animate.leave(options.backdrop);
                }
                if (options.disableParentScroll) {
                  options.restoreScroll();
                  delete options.restoreScroll;
                }
                options.hideBackdrop = null;
              };
            }
            function configureAria(element, options) {
              var role = (options.$type === 'alert') ? 'alertdialog' : 'dialog';
              var dialogContent = element.find('md-dialog-content');
              var dialogId = element.attr('id') || ('dialog_' + $mdUtil.nextUid());
              element.attr({
                'role': role,
                'tabIndex': '-1'
              });
              if (dialogContent.length === 0) {
                dialogContent = element;
              }
              dialogContent.attr('id', dialogId);
              element.attr('aria-describedby', dialogId);
              if (options.ariaLabel) {
                $mdAria.expect(element, 'aria-label', options.ariaLabel);
              } else {
                $mdAria.expectAsync(element, 'aria-label', function() {
                  var words = dialogContent.text().split(/\s+/);
                  if (words.length > 3)
                    words = words.slice(0, 3).concat('...');
                  return words.join(' ');
                });
              }
              topFocusTrap = document.createElement('div');
              topFocusTrap.classList.add('md-dialog-focus-trap');
              topFocusTrap.tabIndex = 0;
              bottomFocusTrap = topFocusTrap.cloneNode(false);
              var focusHandler = function() {
                element.focus();
              };
              topFocusTrap.addEventListener('focus', focusHandler);
              bottomFocusTrap.addEventListener('focus', focusHandler);
              element[0].parentNode.insertBefore(topFocusTrap, element[0]);
              element.append(bottomFocusTrap);
            }
            function lockScreenReader(element, options) {
              var isHidden = true;
              walkDOM(element[0]);
              options.unlockScreenReader = function() {
                isHidden = false;
                walkDOM(element[0]);
                options.unlockScreenReader = null;
              };
              function walkDOM(element) {
                while (element.parentNode) {
                  if (element === document.body) {
                    return;
                  }
                  var children = element.parentNode.children;
                  for (var i = 0; i < children.length; i++) {
                    if (element !== children[i] && !isNodeOneOf(children[i], ['SCRIPT', 'STYLE'])) {
                      children[i].setAttribute('aria-hidden', isHidden);
                    }
                  }
                  walkDOM(element = element.parentNode);
                }
              }
            }
            function stretchDialogContainerToViewport(container, options) {
              var isFixed = $window.getComputedStyle($document[0].body).position == 'fixed';
              var backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null;
              var height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0;
              container.css({
                top: (isFixed ? $mdUtil.scrollTop(options.parent) : 0) + 'px',
                height: height ? height + 'px' : '100%'
              });
              return container;
            }
            function dialogPopIn(container, options) {
              options.parent.append(container);
              stretchDialogContainerToViewport(container, options);
              var dialogEl = container.find('md-dialog');
              var animator = $mdUtil.dom.animator;
              var buildTranslateToOrigin = animator.calculateZoomToOrigin;
              var translateOptions = {
                transitionInClass: 'md-transition-in',
                transitionOutClass: 'md-transition-out'
              };
              var from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin));
              var to = animator.toTransformCss("");
              if (options.fullscreen) {
                dialogEl.addClass('md-dialog-fullscreen');
              }
              return animator.translate3d(dialogEl, from, to, translateOptions).then(function(animateReversal) {
                options.reverseAnimate = function() {
                  delete options.reverseAnimate;
                  if (options.closeTo) {
                    translateOptions = {
                      transitionInClass: 'md-transition-out',
                      transitionOutClass: 'md-transition-in'
                    };
                    from = to;
                    to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo));
                    return animator.translate3d(dialogEl, from, to, translateOptions);
                  }
                  return animateReversal(animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.origin)));
                };
                return true;
              });
            }
            function dialogPopOut(container, options) {
              return options.reverseAnimate();
            }
            function isNodeOneOf(elem, nodeTypeArray) {
              if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {
                return true;
              }
            }
          }
        }
        MdDialogProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.divider', ['material.core']).directive('mdDivider', MdDividerDirective);
        function MdDividerDirective($mdTheming) {
          return {
            restrict: 'E',
            link: $mdTheming
          };
        }
        MdDividerDirective.$inject = ["$mdTheming"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabActions', ['material.core']).directive('mdFabActions', MdFabActionsDirective);
          function MdFabActionsDirective() {
            return {
              restrict: 'E',
              require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],
              compile: function(element, attributes) {
                var children = element.children();
                var hasNgRepeat = false;
                angular.forEach(['', 'data-', 'x-'], function(prefix) {
                  hasNgRepeat = hasNgRepeat || (children.attr(prefix + 'ng-repeat') ? true : false);
                });
                if (hasNgRepeat) {
                  children.addClass('md-fab-action-item');
                } else {
                  children.wrap('<div class="md-fab-action-item">');
                }
              }
            };
          }
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabShared', ['material.core']).controller('FabController', FabController);
          function FabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {
            var vm = this;
            vm.open = function() {
              $scope.$evalAsync("vm.isOpen = true");
            };
            vm.close = function() {
              $scope.$evalAsync("vm.isOpen = false");
              $element.find('md-fab-trigger')[0].focus();
            };
            vm.toggle = function() {
              $scope.$evalAsync("vm.isOpen = !vm.isOpen");
            };
            setupDefaults();
            setupListeners();
            setupWatchers();
            var initialAnimationAttempts = 0;
            fireInitialAnimations();
            function setupDefaults() {
              vm.direction = vm.direction || 'down';
              vm.isOpen = vm.isOpen || false;
              resetActionIndex();
              $element.addClass('md-animations-waiting');
            }
            function setupListeners() {
              var eventTypes = ['click', 'focusin', 'focusout'];
              angular.forEach(eventTypes, function(eventType) {
                $element.on(eventType, parseEvents);
              });
              $scope.$on('$destroy', function() {
                angular.forEach(eventTypes, function(eventType) {
                  $element.off(eventType, parseEvents);
                });
                disableKeyboard();
              });
            }
            var closeTimeout;
            function parseEvents(event) {
              if (event.type == 'click') {
                handleItemClick(event);
              }
              if (event.type == 'focusout' && !closeTimeout) {
                closeTimeout = $timeout(function() {
                  vm.close();
                }, 100, false);
              }
              if (event.type == 'focusin' && closeTimeout) {
                $timeout.cancel(closeTimeout);
                closeTimeout = null;
              }
            }
            function resetActionIndex() {
              vm.currentActionIndex = -1;
            }
            function setupWatchers() {
              $scope.$watch('vm.direction', function(newDir, oldDir) {
                $animate.removeClass($element, 'md-' + oldDir);
                $animate.addClass($element, 'md-' + newDir);
                resetActionIndex();
              });
              var trigger,
                  actions;
              $scope.$watch('vm.isOpen', function(isOpen) {
                resetActionIndex();
                if (!trigger || !actions) {
                  trigger = getTriggerElement();
                  actions = getActionsElement();
                }
                if (isOpen) {
                  enableKeyboard();
                } else {
                  disableKeyboard();
                }
                var toAdd = isOpen ? 'md-is-open' : '';
                var toRemove = isOpen ? '' : 'md-is-open';
                trigger.attr('aria-haspopup', true);
                trigger.attr('aria-expanded', isOpen);
                actions.attr('aria-hidden', !isOpen);
                $animate.setClass($element, toAdd, toRemove);
              });
            }
            function fireInitialAnimations() {
              if ($element[0].scrollHeight > 0) {
                $animate.addClass($element, 'md-animations-ready').then(function() {
                  $element.removeClass('md-animations-waiting');
                });
              } else if (initialAnimationAttempts < 10) {
                $timeout(fireInitialAnimations, 100);
                initialAnimationAttempts = initialAnimationAttempts + 1;
              }
            }
            function enableKeyboard() {
              $element.on('keydown', keyPressed);
              $mdUtil.nextTick(function() {
                angular.element(document).on('click touchend', checkForOutsideClick);
              });
            }
            function disableKeyboard() {
              $element.off('keydown', keyPressed);
              angular.element(document).off('click touchend', checkForOutsideClick);
            }
            function checkForOutsideClick(event) {
              if (event.target) {
                var closestTrigger = $mdUtil.getClosest(event.target, 'md-fab-trigger');
                var closestActions = $mdUtil.getClosest(event.target, 'md-fab-actions');
                if (!closestTrigger && !closestActions) {
                  vm.close();
                }
              }
            }
            function keyPressed(event) {
              switch (event.which) {
                case $mdConstant.KEY_CODE.ESCAPE:
                  vm.close();
                  event.preventDefault();
                  return false;
                case $mdConstant.KEY_CODE.LEFT_ARROW:
                  doKeyLeft(event);
                  return false;
                case $mdConstant.KEY_CODE.UP_ARROW:
                  doKeyUp(event);
                  return false;
                case $mdConstant.KEY_CODE.RIGHT_ARROW:
                  doKeyRight(event);
                  return false;
                case $mdConstant.KEY_CODE.DOWN_ARROW:
                  doKeyDown(event);
                  return false;
              }
            }
            function doActionPrev(event) {
              focusAction(event, -1);
            }
            function doActionNext(event) {
              focusAction(event, 1);
            }
            function focusAction(event, direction) {
              var actions = resetActionTabIndexes();
              vm.currentActionIndex = vm.currentActionIndex + direction;
              vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex);
              vm.currentActionIndex = Math.max(0, vm.currentActionIndex);
              var focusElement = angular.element(actions[vm.currentActionIndex]).children()[0];
              angular.element(focusElement).attr('tabindex', 0);
              focusElement.focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            }
            function resetActionTabIndexes() {
              var actions = getActionsElement()[0].querySelectorAll('.md-fab-action-item');
              angular.forEach(actions, function(action) {
                angular.element(angular.element(action).children()[0]).attr('tabindex', -1);
              });
              return actions;
            }
            function doKeyLeft(event) {
              if (vm.direction === 'left') {
                doActionNext(event);
              } else {
                doActionPrev(event);
              }
            }
            function doKeyUp(event) {
              if (vm.direction === 'down') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function doKeyRight(event) {
              if (vm.direction === 'left') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function doKeyDown(event) {
              if (vm.direction === 'up') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function isTrigger(element) {
              return $mdUtil.getClosest(element, 'md-fab-trigger');
            }
            function isAction(element) {
              return $mdUtil.getClosest(element, 'md-fab-actions');
            }
            function handleItemClick(event) {
              if (isTrigger(event.target)) {
                vm.toggle();
              }
              if (isAction(event.target)) {
                vm.close();
              }
            }
            function getTriggerElement() {
              return $element.find('md-fab-trigger');
            }
            function getActionsElement() {
              return $element.find('md-fab-actions');
            }
          }
          FabController.$inject = ["$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          var cssAnimationDuration = 300;
          angular.module('material.components.fabSpeedDial', ['material.core', 'material.components.fabShared', 'material.components.fabTrigger', 'material.components.fabActions']).directive('mdFabSpeedDial', MdFabSpeedDialDirective).animation('.md-fling', MdFabSpeedDialFlingAnimation).animation('.md-scale', MdFabSpeedDialScaleAnimation).service('mdFabSpeedDialFlingAnimation', MdFabSpeedDialFlingAnimation).service('mdFabSpeedDialScaleAnimation', MdFabSpeedDialScaleAnimation);
          function MdFabSpeedDialDirective() {
            return {
              restrict: 'E',
              scope: {
                direction: '@?mdDirection',
                isOpen: '=?mdOpen'
              },
              bindToController: true,
              controller: 'FabController',
              controllerAs: 'vm',
              link: FabSpeedDialLink
            };
            function FabSpeedDialLink(scope, element) {
              element.prepend('<div class="md-css-variables"></div>');
            }
          }
          function MdFabSpeedDialFlingAnimation($timeout) {
            function delayDone(done) {
              $timeout(done, cssAnimationDuration, false);
            }
            function runAnimation(element) {
              if (element.hasClass('md-animations-waiting') && !element.hasClass('md-animations-ready')) {
                return;
              }
              var el = element[0];
              var ctrl = element.controller('mdFabSpeedDial');
              var items = el.querySelectorAll('.md-fab-action-item');
              var triggerElement = el.querySelector('md-fab-trigger');
              var variablesElement = el.querySelector('.md-css-variables');
              var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
              angular.forEach(items, function(item, index) {
                var styles = item.style;
                styles.transform = styles.webkitTransform = '';
                styles.transitionDelay = '';
                styles.opacity = 1;
                styles.zIndex = (items.length - index) + startZIndex;
              });
              triggerElement.style.zIndex = startZIndex + items.length + 1;
              if (!ctrl.isOpen) {
                angular.forEach(items, function(item, index) {
                  var newPosition,
                      axis;
                  var styles = item.style;
                  var triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2;
                  var triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;
                  switch (ctrl.direction) {
                    case 'up':
                      newPosition = (item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                      axis = 'Y';
                      break;
                    case 'down':
                      newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                      axis = 'Y';
                      break;
                    case 'left':
                      newPosition = (item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                      axis = 'X';
                      break;
                    case 'right':
                      newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                      axis = 'X';
                      break;
                  }
                  var newTranslate = 'translate' + axis + '(' + newPosition + 'px)';
                  styles.transform = styles.webkitTransform = newTranslate;
                });
              }
            }
            return {
              addClass: function(element, className, done) {
                if (element.hasClass('md-fling')) {
                  runAnimation(element);
                  delayDone(done);
                } else {
                  done();
                }
              },
              removeClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              }
            };
          }
          MdFabSpeedDialFlingAnimation.$inject = ["$timeout"];
          function MdFabSpeedDialScaleAnimation($timeout) {
            function delayDone(done) {
              $timeout(done, cssAnimationDuration, false);
            }
            var delay = 65;
            function runAnimation(element) {
              var el = element[0];
              var ctrl = element.controller('mdFabSpeedDial');
              var items = el.querySelectorAll('.md-fab-action-item');
              var variablesElement = el.querySelector('.md-css-variables');
              var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
              angular.forEach(items, function(item, index) {
                var styles = item.style,
                    offsetDelay = index * delay;
                styles.opacity = ctrl.isOpen ? 1 : 0;
                styles.transform = styles.webkitTransform = ctrl.isOpen ? 'scale(1)' : 'scale(0.1)';
                styles.transitionDelay = (ctrl.isOpen ? offsetDelay : (items.length - offsetDelay)) + 'ms';
                styles.zIndex = (items.length - index) + startZIndex;
              });
            }
            return {
              addClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              },
              removeClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              }
            };
          }
          MdFabSpeedDialScaleAnimation.$inject = ["$timeout"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabToolbar', ['material.core', 'material.components.fabShared', 'material.components.fabTrigger', 'material.components.fabActions']).directive('mdFabToolbar', MdFabToolbarDirective).animation('.md-fab-toolbar', MdFabToolbarAnimation).service('mdFabToolbarAnimation', MdFabToolbarAnimation);
          function MdFabToolbarDirective() {
            return {
              restrict: 'E',
              transclude: true,
              template: '<div class="md-fab-toolbar-wrapper">' + '  <div class="md-fab-toolbar-content" ng-transclude></div>' + '</div>',
              scope: {
                direction: '@?mdDirection',
                isOpen: '=?mdOpen'
              },
              bindToController: true,
              controller: 'FabController',
              controllerAs: 'vm',
              link: link
            };
            function link(scope, element, attributes) {
              element.addClass('md-fab-toolbar');
              element.find('md-fab-trigger').find('button').prepend('<div class="md-fab-toolbar-background"></div>');
            }
          }
          function MdFabToolbarAnimation() {
            function runAnimation(element, className, done) {
              if (!className) {
                return;
              }
              var el = element[0];
              var ctrl = element.controller('mdFabToolbar');
              var backgroundElement = el.querySelector('.md-fab-toolbar-background');
              var triggerElement = el.querySelector('md-fab-trigger button');
              var toolbarElement = el.querySelector('md-toolbar');
              var iconElement = el.querySelector('md-fab-trigger button md-icon');
              var actions = element.find('md-fab-actions').children();
              if (triggerElement && backgroundElement) {
                var color = window.getComputedStyle(triggerElement).getPropertyValue('background-color');
                var width = el.offsetWidth;
                var height = el.offsetHeight;
                var scale = 2 * (width / triggerElement.offsetWidth);
                backgroundElement.style.backgroundColor = color;
                backgroundElement.style.borderRadius = width + 'px';
                if (ctrl.isOpen) {
                  toolbarElement.style.pointerEvents = 'initial';
                  backgroundElement.style.width = triggerElement.offsetWidth + 'px';
                  backgroundElement.style.height = triggerElement.offsetHeight + 'px';
                  backgroundElement.style.transform = 'scale(' + scale + ')';
                  backgroundElement.style.transitionDelay = '0ms';
                  iconElement && (iconElement.style.transitionDelay = '.3s');
                  angular.forEach(actions, function(action, index) {
                    action.style.transitionDelay = (actions.length - index) * 25 + 'ms';
                  });
                } else {
                  toolbarElement.style.pointerEvents = 'none';
                  backgroundElement.style.transform = 'scale(1)';
                  backgroundElement.style.top = '0';
                  if (element.hasClass('md-right')) {
                    backgroundElement.style.left = '0';
                    backgroundElement.style.right = null;
                  }
                  if (element.hasClass('md-left')) {
                    backgroundElement.style.right = '0';
                    backgroundElement.style.left = null;
                  }
                  backgroundElement.style.transitionDelay = '200ms';
                  iconElement && (iconElement.style.transitionDelay = '0ms');
                  angular.forEach(actions, function(action, index) {
                    action.style.transitionDelay = 200 + (index * 25) + 'ms';
                  });
                }
              }
            }
            return {
              addClass: function(element, className, done) {
                runAnimation(element, className, done);
                done();
              },
              removeClass: function(element, className, done) {
                runAnimation(element, className, done);
                done();
              }
            };
          }
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabTrigger', ['material.core']).directive('mdFabTrigger', MdFabTriggerDirective);
          function MdFabTriggerDirective() {
            return {
              restrict: 'E',
              require: ['^?mdFabSpeedDial', '^?mdFabToolbar']
            };
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.gridList', ['material.core']).directive('mdGridList', GridListDirective).directive('mdGridTile', GridTileDirective).directive('mdGridTileFooter', GridTileCaptionDirective).directive('mdGridTileHeader', GridTileCaptionDirective).factory('$mdGridLayout', GridLayoutFactory);
        function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {
          return {
            restrict: 'E',
            controller: GridListController,
            scope: {mdOnLayout: '&'},
            link: postLink
          };
          function postLink(scope, element, attrs, ctrl) {
            element.attr('role', 'list');
            ctrl.layoutDelegate = layoutDelegate;
            var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),
                unwatchAttrs = watchMedia();
            scope.$on('$destroy', unwatchMedia);
            function watchMedia() {
              for (var mediaName in $mdConstant.MEDIA) {
                $mdMedia(mediaName);
                $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);
              }
              return $mdMedia.watchResponsiveAttributes(['md-cols', 'md-row-height', 'md-gutter'], attrs, layoutIfMediaMatch);
            }
            function unwatchMedia() {
              ctrl.layoutDelegate = angular.noop;
              unwatchAttrs();
              for (var mediaName in $mdConstant.MEDIA) {
                $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);
              }
            }
            function layoutIfMediaMatch(mediaName) {
              if (mediaName == null) {
                ctrl.invalidateLayout();
              } else if ($mdMedia(mediaName)) {
                ctrl.invalidateLayout();
              }
            }
            var lastLayoutProps;
            function layoutDelegate(tilesInvalidated) {
              var tiles = getTileElements();
              var props = {
                tileSpans: getTileSpans(tiles),
                colCount: getColumnCount(),
                rowMode: getRowMode(),
                rowHeight: getRowHeight(),
                gutter: getGutter()
              };
              if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {
                return;
              }
              var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles).map(function(tilePositions, rowCount) {
                return {
                  grid: {
                    element: element,
                    style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                  },
                  tiles: tilePositions.map(function(ps, i) {
                    return {
                      element: angular.element(tiles[i]),
                      style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                    };
                  })
                };
              }).reflow().performance();
              scope.mdOnLayout({$event: {performance: performance}});
              lastLayoutProps = props;
            }
            var startSymbol = $interpolate.startSymbol();
            var endSymbol = $interpolate.endSymbol();
            function expr(exprStr) {
              return startSymbol + exprStr + endSymbol;
            }
            var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');
            var POSITION = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');
            var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');
            function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
              var hShare = (1 / colCount) * 100;
              var hGutterShare = (colCount - 1) / colCount;
              var hUnit = UNIT({
                share: hShare,
                gutterShare: hGutterShare,
                gutter: gutter
              });
              var style = {
                left: POSITION({
                  unit: hUnit,
                  offset: position.col,
                  gutter: gutter
                }),
                width: DIMENSION({
                  unit: hUnit,
                  span: spans.col,
                  gutter: gutter
                }),
                paddingTop: '',
                marginTop: '',
                top: '',
                height: ''
              };
              switch (rowMode) {
                case 'fixed':
                  style.top = POSITION({
                    unit: rowHeight,
                    offset: position.row,
                    gutter: gutter
                  });
                  style.height = DIMENSION({
                    unit: rowHeight,
                    span: spans.row,
                    gutter: gutter
                  });
                  break;
                case 'ratio':
                  var vShare = hShare / rowHeight;
                  var vUnit = UNIT({
                    share: vShare,
                    gutterShare: hGutterShare,
                    gutter: gutter
                  });
                  style.paddingTop = DIMENSION({
                    unit: vUnit,
                    span: spans.row,
                    gutter: gutter
                  });
                  style.marginTop = POSITION({
                    unit: vUnit,
                    offset: position.row,
                    gutter: gutter
                  });
                  break;
                case 'fit':
                  var vGutterShare = (rowCount - 1) / rowCount;
                  var vShare = (1 / rowCount) * 100;
                  var vUnit = UNIT({
                    share: vShare,
                    gutterShare: vGutterShare,
                    gutter: gutter
                  });
                  style.top = POSITION({
                    unit: vUnit,
                    offset: position.row,
                    gutter: gutter
                  });
                  style.height = DIMENSION({
                    unit: vUnit,
                    span: spans.row,
                    gutter: gutter
                  });
                  break;
              }
              return style;
            }
            function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
              var style = {};
              switch (rowMode) {
                case 'fixed':
                  style.height = DIMENSION({
                    unit: rowHeight,
                    span: rowCount,
                    gutter: gutter
                  });
                  style.paddingBottom = '';
                  break;
                case 'ratio':
                  var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,
                      hShare = (1 / colCount) * 100,
                      vShare = hShare * (1 / rowHeight),
                      vUnit = UNIT({
                        share: vShare,
                        gutterShare: hGutterShare,
                        gutter: gutter
                      });
                  style.height = '';
                  style.paddingBottom = DIMENSION({
                    unit: vUnit,
                    span: rowCount,
                    gutter: gutter
                  });
                  break;
                case 'fit':
                  break;
              }
              return style;
            }
            function getTileElements() {
              return [].filter.call(element.children(), function(ele) {
                return ele.tagName == 'MD-GRID-TILE' && !ele.$$mdDestroyed;
              });
            }
            function getTileSpans(tileElements) {
              return [].map.call(tileElements, function(ele) {
                var ctrl = angular.element(ele).controller('mdGridTile');
                return {
                  row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,
                  col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1
                };
              });
            }
            function getColumnCount() {
              var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);
              if (isNaN(colCount)) {
                throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';
              }
              return colCount;
            }
            function getGutter() {
              return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);
            }
            function getRowHeight() {
              var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
              switch (getRowMode()) {
                case 'fixed':
                  return applyDefaultUnit(rowHeight);
                case 'ratio':
                  var whRatio = rowHeight.split(':');
                  return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);
                case 'fit':
                  return 0;
              }
            }
            function getRowMode() {
              var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
              if (rowHeight == 'fit') {
                return 'fit';
              } else if (rowHeight.indexOf(':') !== -1) {
                return 'ratio';
              } else {
                return 'fixed';
              }
            }
            function applyDefaultUnit(val) {
              return /\D$/.test(val) ? val : val + 'px';
            }
          }
        }
        GridListDirective.$inject = ["$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia"];
        function GridListController($mdUtil) {
          this.layoutInvalidated = false;
          this.tilesInvalidated = false;
          this.$timeout_ = $mdUtil.nextTick;
          this.layoutDelegate = angular.noop;
        }
        GridListController.$inject = ["$mdUtil"];
        GridListController.prototype = {
          invalidateTiles: function() {
            this.tilesInvalidated = true;
            this.invalidateLayout();
          },
          invalidateLayout: function() {
            if (this.layoutInvalidated) {
              return;
            }
            this.layoutInvalidated = true;
            this.$timeout_(angular.bind(this, this.layout));
          },
          layout: function() {
            try {
              this.layoutDelegate(this.tilesInvalidated);
            } finally {
              this.layoutInvalidated = false;
              this.tilesInvalidated = false;
            }
          }
        };
        function GridLayoutFactory($mdUtil) {
          var defaultAnimator = GridTileAnimator;
          GridLayout.animateWith = function(customAnimator) {
            defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;
          };
          return GridLayout;
          function GridLayout(colCount, tileSpans) {
            var self,
                layoutInfo,
                gridStyles,
                layoutTime,
                mapTime,
                reflowTime;
            layoutTime = $mdUtil.time(function() {
              layoutInfo = calculateGridFor(colCount, tileSpans);
            });
            return self = {
              layoutInfo: function() {
                return layoutInfo;
              },
              map: function(updateFn) {
                mapTime = $mdUtil.time(function() {
                  var info = self.layoutInfo();
                  gridStyles = updateFn(info.positioning, info.rowCount);
                });
                return self;
              },
              reflow: function(animatorFn) {
                reflowTime = $mdUtil.time(function() {
                  var animator = animatorFn || defaultAnimator;
                  animator(gridStyles.grid, gridStyles.tiles);
                });
                return self;
              },
              performance: function() {
                return {
                  tileCount: tileSpans.length,
                  layoutTime: layoutTime,
                  mapTime: mapTime,
                  reflowTime: reflowTime,
                  totalTime: layoutTime + mapTime + reflowTime
                };
              }
            };
          }
          function GridTileAnimator(grid, tiles) {
            grid.element.css(grid.style);
            tiles.forEach(function(t) {
              t.element.css(t.style);
            });
          }
          function calculateGridFor(colCount, tileSpans) {
            var curCol = 0,
                curRow = 0,
                spaceTracker = newSpaceTracker();
            return {
              positioning: tileSpans.map(function(spans, i) {
                return {
                  spans: spans,
                  position: reserveSpace(spans, i)
                };
              }),
              rowCount: curRow + Math.max.apply(Math, spaceTracker)
            };
            function reserveSpace(spans, i) {
              if (spans.col > colCount) {
                throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' + '(' + spans.col + ') that exceeds the column count ' + '(' + colCount + ')';
              }
              var start = 0,
                  end = 0;
              while (end - start < spans.col) {
                if (curCol >= colCount) {
                  nextRow();
                  continue;
                }
                start = spaceTracker.indexOf(0, curCol);
                if (start === -1 || (end = findEnd(start + 1)) === -1) {
                  start = end = 0;
                  nextRow();
                  continue;
                }
                curCol = end + 1;
              }
              adjustRow(start, spans.col, spans.row);
              curCol = start + spans.col;
              return {
                col: start,
                row: curRow
              };
            }
            function nextRow() {
              curCol = 0;
              curRow++;
              adjustRow(0, colCount, -1);
            }
            function adjustRow(from, cols, by) {
              for (var i = from; i < from + cols; i++) {
                spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
              }
            }
            function findEnd(start) {
              var i;
              for (i = start; i < spaceTracker.length; i++) {
                if (spaceTracker[i] !== 0) {
                  return i;
                }
              }
              if (i === spaceTracker.length) {
                return i;
              }
            }
            function newSpaceTracker() {
              var tracker = [];
              for (var i = 0; i < colCount; i++) {
                tracker.push(0);
              }
              return tracker;
            }
          }
        }
        GridLayoutFactory.$inject = ["$mdUtil"];
        function GridTileDirective($mdMedia) {
          return {
            restrict: 'E',
            require: '^mdGridList',
            template: '<figure ng-transclude></figure>',
            transclude: true,
            scope: {},
            controller: ["$attrs", function($attrs) {
              this.$attrs = $attrs;
            }],
            link: postLink
          };
          function postLink(scope, element, attrs, gridCtrl) {
            element.attr('role', 'listitem');
            var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
            gridCtrl.invalidateTiles();
            scope.$on('$destroy', function() {
              element[0].$$mdDestroyed = true;
              unwatchAttrs();
              gridCtrl.invalidateLayout();
            });
            if (angular.isDefined(scope.$parent.$index)) {
              scope.$watch(function() {
                return scope.$parent.$index;
              }, function indexChanged(newIdx, oldIdx) {
                if (newIdx === oldIdx) {
                  return;
                }
                gridCtrl.invalidateTiles();
              });
            }
          }
        }
        GridTileDirective.$inject = ["$mdMedia"];
        function GridTileCaptionDirective() {
          return {
            template: '<figcaption ng-transclude></figcaption>',
            transclude: true
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon', ['material.core']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.input', ['material.core']).directive('mdInputContainer', mdInputContainerDirective).directive('label', labelDirective).directive('input', inputTextareaDirective).directive('textarea', inputTextareaDirective).directive('mdMaxlength', mdMaxlengthDirective).directive('placeholder', placeholderDirective).directive('ngMessages', ngMessagesDirective).directive('ngMessage', ngMessageDirective).directive('ngMessageExp', ngMessageDirective).animation('.md-input-invalid', mdInputInvalidMessagesAnimation).animation('.md-input-messages-animation', ngMessagesAnimation).animation('.md-input-message-animation', ngMessageAnimation);
        function mdInputContainerDirective($mdTheming, $parse) {
          ContainerCtrl.$inject = ["$scope", "$element", "$attrs", "$animate"];
          return {
            restrict: 'E',
            link: postLink,
            controller: ContainerCtrl
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            if (element.find('md-icon').length)
              element.addClass('md-has-icon');
          }
          function ContainerCtrl($scope, $element, $attrs, $animate) {
            var self = this;
            self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);
            self.delegateClick = function() {
              self.input.focus();
            };
            self.element = $element;
            self.setFocused = function(isFocused) {
              $element.toggleClass('md-input-focused', !!isFocused);
            };
            self.setHasValue = function(hasValue) {
              $element.toggleClass('md-input-has-value', !!hasValue);
            };
            self.setHasPlaceholder = function(hasPlaceholder) {
              $element.toggleClass('md-input-has-placeholder', !!hasPlaceholder);
            };
            self.setInvalid = function(isInvalid) {
              if (isInvalid) {
                $animate.addClass($element, 'md-input-invalid');
              } else {
                $animate.removeClass($element, 'md-input-invalid');
              }
            };
            $scope.$watch(function() {
              return self.label && self.input;
            }, function(hasLabelAndInput) {
              if (hasLabelAndInput && !self.label.attr('for')) {
                self.label.attr('for', self.input.attr('id'));
              }
            });
          }
        }
        mdInputContainerDirective.$inject = ["$mdTheming", "$parse"];
        function labelDirective() {
          return {
            restrict: 'E',
            require: '^?mdInputContainer',
            link: function(scope, element, attr, containerCtrl) {
              if (!containerCtrl || attr.mdNoFloat || element.hasClass('md-container-ignore'))
                return;
              containerCtrl.label = element;
              scope.$on('$destroy', function() {
                containerCtrl.label = null;
              });
            }
          };
        }
        function inputTextareaDirective($mdUtil, $window, $mdAria) {
          return {
            restrict: 'E',
            require: ['^?mdInputContainer', '?ngModel'],
            link: postLink
          };
          function postLink(scope, element, attr, ctrls) {
            var containerCtrl = ctrls[0];
            var hasNgModel = !!ctrls[1];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            var isReadonly = angular.isDefined(attr.readonly);
            if (!containerCtrl)
              return;
            if (containerCtrl.input) {
              throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
            }
            containerCtrl.input = element;
            var errorsSpacer = angular.element('<div class="md-errors-spacer">');
            element.after(errorsSpacer);
            if (!containerCtrl.label) {
              $mdAria.expect(element, 'aria-label', element.attr('placeholder'));
            }
            element.addClass('md-input');
            if (!element.attr('id')) {
              element.attr('id', 'input_' + $mdUtil.nextUid());
            }
            if (element[0].tagName.toLowerCase() === 'textarea') {
              setupTextarea();
            }
            if (!hasNgModel) {
              inputCheckValue();
            }
            var isErrorGetter = containerCtrl.isErrorGetter || function() {
              return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (ngModelCtrl.$$parentForm && ngModelCtrl.$$parentForm.$submitted));
            };
            scope.$watch(isErrorGetter, containerCtrl.setInvalid);
            ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
            ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);
            element.on('input', inputCheckValue);
            if (!isReadonly) {
              element.on('focus', function(ev) {
                containerCtrl.setFocused(true);
              }).on('blur', function(ev) {
                containerCtrl.setFocused(false);
                inputCheckValue();
              });
            }
            scope.$on('$destroy', function() {
              containerCtrl.setFocused(false);
              containerCtrl.setHasValue(false);
              containerCtrl.input = null;
            });
            function ngModelPipelineCheckValue(arg) {
              containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
              return arg;
            }
            function inputCheckValue() {
              containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
            }
            function setupTextarea() {
              if (angular.isDefined(element.attr('md-no-autogrow'))) {
                return;
              }
              var node = element[0];
              var container = containerCtrl.element[0];
              var min_rows = NaN;
              var lineHeight = null;
              if (node.hasAttribute('rows')) {
                min_rows = parseInt(node.getAttribute('rows'));
              }
              var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);
              function pipelineListener(value) {
                onChangeTextarea();
                return value;
              }
              if (ngModelCtrl) {
                ngModelCtrl.$formatters.push(pipelineListener);
                ngModelCtrl.$viewChangeListeners.push(pipelineListener);
              } else {
                onChangeTextarea();
              }
              element.on('keydown input', onChangeTextarea);
              if (isNaN(min_rows)) {
                element.attr('rows', '1');
                element.on('scroll', onScroll);
              }
              angular.element($window).on('resize', onChangeTextarea);
              scope.$on('$destroy', function() {
                angular.element($window).off('resize', onChangeTextarea);
              });
              function growTextarea() {
                container.style.height = container.offsetHeight + 'px';
                element.addClass('md-no-flex');
                if (isNaN(min_rows)) {
                  node.style.height = "auto";
                  node.scrollTop = 0;
                  var height = getHeight();
                  if (height)
                    node.style.height = height + 'px';
                } else {
                  node.setAttribute("rows", 1);
                  if (!lineHeight) {
                    node.style.minHeight = '0';
                    lineHeight = element.prop('clientHeight');
                    node.style.minHeight = null;
                  }
                  var rows = Math.min(min_rows, Math.round(node.scrollHeight / lineHeight));
                  node.setAttribute("rows", rows);
                  node.style.height = lineHeight * rows + "px";
                }
                element.removeClass('md-no-flex');
                container.style.height = 'auto';
              }
              function getHeight() {
                var line = node.scrollHeight - node.offsetHeight;
                return node.offsetHeight + (line > 0 ? line : 0);
              }
              function onScroll(e) {
                node.scrollTop = 0;
                var line = node.scrollHeight - node.offsetHeight;
                var height = node.offsetHeight + line;
                node.style.height = height + 'px';
              }
              if (angular.isDefined(element.attr('md-detect-hidden'))) {
                var handleHiddenChange = function() {
                  var wasHidden = false;
                  return function() {
                    var isHidden = node.offsetHeight === 0;
                    if (isHidden === false && wasHidden === true) {
                      growTextarea();
                    }
                    wasHidden = isHidden;
                  };
                }();
                scope.$watch(function() {
                  $mdUtil.nextTick(handleHiddenChange, false);
                  return true;
                });
              }
            }
          }
        }
        inputTextareaDirective.$inject = ["$mdUtil", "$window", "$mdAria"];
        function mdMaxlengthDirective($animate, $mdUtil) {
          return {
            restrict: 'A',
            require: ['ngModel', '^mdInputContainer'],
            link: postLink
          };
          function postLink(scope, element, attr, ctrls) {
            var maxlength;
            var ngModelCtrl = ctrls[0];
            var containerCtrl = ctrls[1];
            var charCountEl,
                errorsSpacer;
            $mdUtil.nextTick(function() {
              errorsSpacer = angular.element(containerCtrl.element[0].querySelector('.md-errors-spacer'));
              charCountEl = angular.element('<div class="md-char-counter">');
              errorsSpacer.append(charCountEl);
              attr.$set('ngTrim', 'false');
              ngModelCtrl.$formatters.push(renderCharCount);
              ngModelCtrl.$viewChangeListeners.push(renderCharCount);
              element.on('input keydown keyup', function() {
                renderCharCount();
              });
              scope.$watch(attr.mdMaxlength, function(value) {
                maxlength = value;
                if (angular.isNumber(value) && value > 0) {
                  if (!charCountEl.parent().length) {
                    $animate.enter(charCountEl, errorsSpacer);
                  }
                  renderCharCount();
                } else {
                  $animate.leave(charCountEl);
                }
              });
              ngModelCtrl.$validators['md-maxlength'] = function(modelValue, viewValue) {
                if (!angular.isNumber(maxlength) || maxlength < 0) {
                  return true;
                }
                return (modelValue || element.val() || viewValue || '').length <= maxlength;
              };
            });
            function renderCharCount(value) {
              if (!charCountEl.parent) {
                return value;
              }
              charCountEl.text(String(element.val() || value || '').length + '/' + maxlength);
              return value;
            }
          }
        }
        mdMaxlengthDirective.$inject = ["$animate", "$mdUtil"];
        function placeholderDirective($log) {
          return {
            restrict: 'A',
            require: '^^?mdInputContainer',
            priority: 200,
            link: postLink
          };
          function postLink(scope, element, attr, inputContainer) {
            if (!inputContainer)
              return;
            var label = inputContainer.element.find('label');
            var hasNoFloat = angular.isDefined(inputContainer.element.attr('md-no-float'));
            if ((label && label.length) || hasNoFloat) {
              inputContainer.setHasPlaceholder(true);
              return;
            }
            var placeholderText = attr.placeholder;
            element.removeAttr('placeholder');
            if (inputContainer.input && inputContainer.input[0].nodeName != 'MD-SELECT') {
              var placeholder = '<label ng-click="delegateClick()">' + placeholderText + '</label>';
              inputContainer.element.addClass('md-icon-float');
              inputContainer.element.prepend(placeholder);
            }
          }
        }
        placeholderDirective.$inject = ["$log"];
        var visibilityDirectives = ['ngIf', 'ngShow', 'ngHide', 'ngSwitchWhen', 'ngSwitchDefault'];
        function ngMessagesDirective() {
          return {
            restrict: 'EA',
            link: postLink,
            require: '^^?mdInputContainer'
          };
          function postLink(scope, element, attrs, inputContainer) {
            if (!inputContainer)
              return;
            element.toggleClass('md-input-messages-animation', true);
            element.toggleClass('md-auto-hide', true);
            if (attrs.mdAutoHide == 'false' || hasVisibiltyDirective(attrs)) {
              element.toggleClass('md-auto-hide', false);
            }
          }
          function hasVisibiltyDirective(attrs) {
            return visibilityDirectives.some(function(attr) {
              return attrs[attr];
            });
          }
        }
        function ngMessageDirective($mdUtil) {
          return {
            restrict: 'EA',
            compile: compile,
            priority: 100
          };
          function compile(element) {
            var inputContainer = $mdUtil.getClosest(element, "md-input-container");
            if (!inputContainer)
              return;
            element.toggleClass('md-input-message-animation', true);
            return {};
          }
        }
        ngMessageDirective.$inject = ["$mdUtil"];
        function mdInputInvalidMessagesAnimation($q, $animateCss) {
          return {addClass: function(element, className, done) {
              var messages = getMessagesElement(element);
              if (className == "md-input-invalid" && messages.hasClass('md-auto-hide')) {
                showInputMessages(element, $animateCss, $q).finally(done);
              }
            }};
        }
        mdInputInvalidMessagesAnimation.$inject = ["$q", "$animateCss"];
        function ngMessagesAnimation($q, $animateCss) {
          return {
            enter: function(element, done) {
              showInputMessages(element, $animateCss, $q).finally(done);
            },
            leave: function(element, done) {
              hideInputMessages(element, $animateCss, $q).finally(done);
            },
            addClass: function(element, className, done) {
              if (className == "ng-hide") {
                hideInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            },
            removeClass: function(element, className, done) {
              if (className == "ng-hide") {
                showInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            }
          };
        }
        ngMessagesAnimation.$inject = ["$q", "$animateCss"];
        function ngMessageAnimation($animateCss) {
          return {
            enter: function(element, done) {
              var messages = getMessagesElement(element);
              if (messages.hasClass('md-auto-hide')) {
                done();
                return;
              }
              return showMessage(element, $animateCss);
            },
            leave: function(element, done) {
              return hideMessage(element, $animateCss);
            }
          };
        }
        ngMessageAnimation.$inject = ["$animateCss"];
        function showInputMessages(element, $animateCss, $q) {
          var animators = [],
              animator;
          var messages = getMessagesElement(element);
          angular.forEach(messages.children(), function(child) {
            animator = showMessage(angular.element(child), $animateCss);
            animators.push(animator.start());
          });
          return $q.all(animators);
        }
        function hideInputMessages(element, $animateCss, $q) {
          var animators = [],
              animator;
          var messages = getMessagesElement(element);
          angular.forEach(messages.children(), function(child) {
            animator = hideMessage(angular.element(child), $animateCss);
            animators.push(animator.start());
          });
          return $q.all(animators);
        }
        function showMessage(element, $animateCss) {
          var height = element[0].offsetHeight;
          return $animateCss(element, {
            event: 'enter',
            structural: true,
            from: {
              "opacity": 0,
              "margin-top": -height + "px"
            },
            to: {
              "opacity": 1,
              "margin-top": "0"
            },
            duration: 0.3
          });
        }
        function hideMessage(element, $animateCss) {
          var height = element[0].offsetHeight;
          var styles = window.getComputedStyle(element[0]);
          if (styles.opacity == 0) {
            return $animateCss(element, {});
          }
          return $animateCss(element, {
            event: 'leave',
            structural: true,
            from: {
              "opacity": 1,
              "margin-top": 0
            },
            to: {
              "opacity": 0,
              "margin-top": -height + "px"
            },
            duration: 0.3
          });
        }
        function getInputElement(element) {
          var inputContainer = element.controller('mdInputContainer');
          return inputContainer.element;
        }
        function getMessagesElement(element) {
          var input = getInputElement(element);
          var selector = 'ng-messages,data-ng-messages,x-ng-messages,' + '[ng-messages],[data-ng-messages],[x-ng-messages]';
          return angular.element(input[0].querySelector(selector));
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.list', ['material.core']).controller('MdListController', MdListController).directive('mdList', mdListDirective).directive('mdListItem', mdListItemDirective);
        function mdListDirective($mdTheming) {
          return {
            restrict: 'E',
            compile: function(tEl) {
              tEl[0].setAttribute('role', 'list');
              return $mdTheming;
            }
          };
        }
        mdListDirective.$inject = ["$mdTheming"];
        function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {
          var proxiedTypes = ['md-checkbox', 'md-switch'];
          return {
            restrict: 'E',
            controller: 'MdListController',
            compile: function(tEl, tAttrs) {
              var secondaryItem = tEl[0].querySelector('.md-secondary');
              var hasProxiedElement;
              var proxyElement;
              tEl[0].setAttribute('role', 'listitem');
              if (tAttrs.ngClick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) {
                wrapIn('button');
              } else {
                for (var i = 0,
                    type; type = proxiedTypes[i]; ++i) {
                  if (proxyElement = tEl[0].querySelector(type)) {
                    hasProxiedElement = true;
                    break;
                  }
                }
                if (hasProxiedElement) {
                  wrapIn('div');
                } else if (!tEl[0].querySelector('md-button:not(.md-secondary):not(.md-exclude)')) {
                  tEl.addClass('md-no-proxy');
                }
              }
              wrapSecondary();
              setupToggleAria();
              function setupToggleAria() {
                var toggleTypes = ['md-switch', 'md-checkbox'];
                var toggle;
                for (var i = 0,
                    toggleType; toggleType = toggleTypes[i]; ++i) {
                  if (toggle = tEl.find(toggleType)[0]) {
                    if (!toggle.hasAttribute('aria-label')) {
                      var p = tEl.find('p')[0];
                      if (!p)
                        return;
                      toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);
                    }
                  }
                }
              }
              function wrapIn(type) {
                var container;
                if (type == 'div') {
                  container = angular.element('<div class="md-no-style md-list-item-inner">');
                  container.append(tEl.contents());
                  tEl.addClass('md-proxy-focus');
                } else {
                  container = angular.element('<md-button class="md-no-style"><div class="md-list-item-inner"></div></md-button>');
                  copyAttributes(tEl[0], container[0]);
                  container.children().eq(0).append(tEl.contents());
                }
                tEl[0].setAttribute('tabindex', '-1');
                tEl.append(container);
              }
              function wrapSecondary() {
                if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute('ng-click')) {
                  $mdAria.expect(secondaryItem, 'aria-label');
                  var buttonWrapper = angular.element('<md-button class="md-secondary-container md-icon-button">');
                  copyAttributes(secondaryItem, buttonWrapper[0]);
                  secondaryItem.setAttribute('tabindex', '-1');
                  secondaryItem.classList.remove('md-secondary');
                  buttonWrapper.append(secondaryItem);
                  secondaryItem = buttonWrapper[0];
                }
                if (secondaryItem && (secondaryItem.hasAttribute('ng-click') || (tAttrs.ngClick && isProxiedElement(secondaryItem)))) {
                  tEl.addClass('md-with-secondary');
                  tEl.append(secondaryItem);
                }
              }
              function copyAttributes(item, wrapper) {
                var copiedAttrs = ['ng-if', 'ng-click', 'aria-label', 'ng-disabled', 'ui-sref', 'href', 'ng-href', 'ng-attr-ui-sref'];
                angular.forEach(copiedAttrs, function(attr) {
                  if (item.hasAttribute(attr)) {
                    wrapper.setAttribute(attr, item.getAttribute(attr));
                    item.removeAttribute(attr);
                  }
                });
              }
              function isProxiedElement(el) {
                return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;
              }
              function isButton(el) {
                var nodeName = el.nodeName.toUpperCase();
                return nodeName == "MD-BUTTON" || nodeName == "BUTTON";
              }
              return postLink;
              function postLink($scope, $element, $attr, ctrl) {
                var proxies = [],
                    firstChild = $element[0].firstElementChild,
                    hasClick = firstChild && hasClickEvent(firstChild);
                computeProxies();
                computeClickable();
                if ($element.hasClass('md-proxy-focus') && proxies.length) {
                  angular.forEach(proxies, function(proxy) {
                    proxy = angular.element(proxy);
                    $scope.mouseActive = false;
                    proxy.on('mousedown', function() {
                      $scope.mouseActive = true;
                      $timeout(function() {
                        $scope.mouseActive = false;
                      }, 100);
                    }).on('focus', function() {
                      if ($scope.mouseActive === false) {
                        $element.addClass('md-focused');
                      }
                      proxy.on('blur', function proxyOnBlur() {
                        $element.removeClass('md-focused');
                        proxy.off('blur', proxyOnBlur);
                      });
                    });
                  });
                }
                function hasClickEvent(element) {
                  var attr = element.attributes;
                  for (var i = 0; i < attr.length; i++) {
                    if ($attr.$normalize(attr[i].name) === 'ngClick')
                      return true;
                  }
                  return false;
                }
                function computeProxies() {
                  var children = $element.children();
                  if (children.length && !children[0].hasAttribute('ng-click')) {
                    angular.forEach(proxiedTypes, function(type) {
                      angular.forEach(firstChild.querySelectorAll(type), function(child) {
                        proxies.push(child);
                      });
                    });
                  }
                }
                function computeClickable() {
                  if (proxies.length == 1 || hasClick) {
                    $element.addClass('md-clickable');
                    if (!hasClick) {
                      ctrl.attachRipple($scope, angular.element($element[0].querySelector('.md-no-style')));
                    }
                  }
                }
                if (!hasClick && !proxies.length) {
                  firstChild && firstChild.addEventListener('keypress', function(e) {
                    if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA') {
                      var keyCode = e.which || e.keyCode;
                      if (keyCode == $mdConstant.KEY_CODE.SPACE) {
                        if (firstChild) {
                          firstChild.click();
                          e.preventDefault();
                          e.stopPropagation();
                        }
                      }
                    }
                  });
                }
                $element.off('click');
                $element.off('keypress');
                if (proxies.length == 1 && firstChild) {
                  $element.children().eq(0).on('click', function(e) {
                    var parentButton = $mdUtil.getClosest(e.target, 'BUTTON');
                    if (!parentButton && firstChild.contains(e.target)) {
                      angular.forEach(proxies, function(proxy) {
                        if (e.target !== proxy && !proxy.contains(e.target)) {
                          angular.element(proxy).triggerHandler('click');
                        }
                      });
                    }
                  });
                }
              }
            }
          };
        }
        mdListItemDirective.$inject = ["$mdAria", "$mdConstant", "$mdUtil", "$timeout"];
        function MdListController($scope, $element, $mdListInkRipple) {
          var ctrl = this;
          ctrl.attachRipple = attachRipple;
          function attachRipple(scope, element) {
            var options = {};
            $mdListInkRipple.attach(scope, element, options);
          }
        }
        MdListController.$inject = ["$scope", "$element", "$mdListInkRipple"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu', ['material.core', 'material.components.backdrop']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar', ['material.core', 'material.components.menu']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressCircular', ['material.core']).directive('mdProgressCircular', MdProgressCircularDirective);
        function MdProgressCircularDirective($mdTheming, $mdUtil, $log) {
          var DEFAULT_PROGRESS_SIZE = 100;
          var DEFAULT_SCALING = 0.5;
          var MODE_DETERMINATE = "determinate",
              MODE_INDETERMINATE = "indeterminate";
          return {
            restrict: 'E',
            scope: true,
            template: '<div class="md-scale-wrapper">' + '<div class="md-spinner-wrapper">' + '<div class="md-inner">' + '<div class="md-gap"></div>' + '<div class="md-left">' + '<div class="md-half-circle"></div>' + '</div>' + '<div class="md-right">' + '<div class="md-half-circle"></div>' + '</div>' + '</div>' + '</div>' + '</div>',
            compile: compile
          };
          function compile(tElement) {
            tElement.attr('aria-valuemin', 0);
            tElement.attr('aria-valuemax', 100);
            tElement.attr('role', 'progressbar');
            return postLink;
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var circle = element;
            var spinnerWrapper = angular.element(element.children()[0]);
            var lastMode,
                toVendorCSS = $mdUtil.dom.animator.toCss;
            element.attr('md-mode', mode());
            updateScale();
            validateMode();
            watchAttributes();
            function watchAttributes() {
              attr.$observe('value', function(value) {
                var percentValue = clamp(value);
                element.attr('aria-valuenow', percentValue);
                if (mode() == MODE_DETERMINATE) {
                  animateIndicator(percentValue);
                }
              });
              attr.$observe('mdMode', function(mode) {
                switch (mode) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    spinnerWrapper.removeClass('ng-hide');
                    if (lastMode)
                      spinnerWrapper.removeClass(lastMode);
                    spinnerWrapper.addClass(lastMode = "md-mode-" + mode);
                    break;
                  default:
                    if (lastMode)
                      spinnerWrapper.removeClass(lastMode);
                    spinnerWrapper.addClass('ng-hide');
                    lastMode = undefined;
                    break;
                }
              });
            }
            function updateScale() {
              circle.css({
                width: (100 * getDiameterRatio()) + 'px',
                height: (100 * getDiameterRatio()) + 'px'
              });
              circle.children().eq(0).css(toVendorCSS({transform: $mdUtil.supplant('translate(-50%, -50%) scale( {0} )', [getDiameterRatio()])}));
            }
            function validateMode() {
              if (angular.isUndefined(attr.mdMode)) {
                var hasValue = angular.isDefined(attr.value);
                var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
                var info = "Auto-adding the missing md-mode='{0}' to the ProgressCircular element";
                $log.debug($mdUtil.supplant(info, [mode]));
                element.attr("md-mode", mode);
                attr['mdMode'] = mode;
              }
            }
            var leftC,
                rightC,
                gap;
            function animateIndicator(value) {
              if (!mode())
                return;
              leftC = leftC || angular.element(element[0].querySelector('.md-left > .md-half-circle'));
              rightC = rightC || angular.element(element[0].querySelector('.md-right > .md-half-circle'));
              gap = gap || angular.element(element[0].querySelector('.md-gap'));
              var gapStyles = removeEmptyValues({
                borderBottomColor: (value <= 50) ? "transparent !important" : "",
                transition: (value <= 50) ? "" : "borderBottomColor 0.1s linear"
              }),
                  leftStyles = removeEmptyValues({
                    transition: (value <= 50) ? "transform 0.1s linear" : "",
                    transform: $mdUtil.supplant("rotate({0}deg)", [value <= 50 ? 135 : (((value - 50) / 50 * 180) + 135)])
                  }),
                  rightStyles = removeEmptyValues({
                    transition: (value >= 50) ? "transform 0.1s linear" : "",
                    transform: $mdUtil.supplant("rotate({0}deg)", [value >= 50 ? 45 : (value / 50 * 180 - 135)])
                  });
              leftC.css(toVendorCSS(leftStyles));
              rightC.css(toVendorCSS(rightStyles));
              gap.css(toVendorCSS(gapStyles));
            }
            function getDiameterRatio() {
              if (!attr.mdDiameter)
                return DEFAULT_SCALING;
              var match = /([0-9]*)%/.exec(attr.mdDiameter);
              var value = Math.max(0, (match && match[1] / 100) || parseFloat(attr.mdDiameter));
              return (value > 1) ? value / DEFAULT_PROGRESS_SIZE : value;
            }
            function mode() {
              var value = (attr.mdMode || "").trim();
              if (value) {
                switch (value) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    break;
                  default:
                    value = undefined;
                    break;
                }
              }
              return value;
            }
          }
          function clamp(value) {
            return Math.max(0, Math.min(value || 0, 100));
          }
          function removeEmptyValues(target) {
            for (var key in target) {
              if (target.hasOwnProperty(key)) {
                if (target[key] == "")
                  delete target[key];
              }
            }
            return target;
          }
        }
        MdProgressCircularDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressLinear', ['material.core']).directive('mdProgressLinear', MdProgressLinearDirective);
        function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {
          var MODE_DETERMINATE = "determinate",
              MODE_INDETERMINATE = "indeterminate",
              MODE_BUFFER = "buffer",
              MODE_QUERY = "query";
          return {
            restrict: 'E',
            template: '<div class="md-container">' + '<div class="md-dashed"></div>' + '<div class="md-bar md-bar1"></div>' + '<div class="md-bar md-bar2"></div>' + '</div>',
            compile: compile
          };
          function compile(tElement, tAttrs, transclude) {
            tElement.attr('aria-valuemin', 0);
            tElement.attr('aria-valuemax', 100);
            tElement.attr('role', 'progressbar');
            return postLink;
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var lastMode,
                toVendorCSS = $mdUtil.dom.animator.toCss;
            var bar1 = angular.element(element[0].querySelector('.md-bar1')),
                bar2 = angular.element(element[0].querySelector('.md-bar2')),
                container = angular.element(element[0].querySelector('.md-container'));
            element.attr('md-mode', mode());
            validateMode();
            watchAttributes();
            function watchAttributes() {
              attr.$observe('value', function(value) {
                var percentValue = clamp(value);
                element.attr('aria-valuenow', percentValue);
                if (mode() != MODE_QUERY)
                  animateIndicator(bar2, percentValue);
              });
              attr.$observe('mdBufferValue', function(value) {
                animateIndicator(bar1, clamp(value));
              });
              attr.$observe('mdMode', function(mode) {
                switch (mode) {
                  case MODE_QUERY:
                  case MODE_BUFFER:
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    container.removeClass('ng-hide' + ' ' + lastMode);
                    container.addClass(lastMode = "md-mode-" + mode);
                    break;
                  default:
                    if (lastMode)
                      container.removeClass(lastMode);
                    container.addClass('ng-hide');
                    lastMode = undefined;
                    break;
                }
              });
            }
            function validateMode() {
              if (angular.isUndefined(attr.mdMode)) {
                var hasValue = angular.isDefined(attr.value);
                var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
                var info = "Auto-adding the missing md-mode='{0}' to the ProgressLinear element";
                $log.debug($mdUtil.supplant(info, [mode]));
                element.attr("md-mode", mode);
                attr['mdMode'] = mode;
              }
            }
            function mode() {
              var value = (attr.mdMode || "").trim();
              if (value) {
                switch (value) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                  case MODE_BUFFER:
                  case MODE_QUERY:
                    break;
                  default:
                    value = undefined;
                    break;
                }
              }
              return value;
            }
            function animateIndicator(target, value) {
              if (!mode())
                return;
              var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [(value - 100) / 2, value / 100]);
              var styles = toVendorCSS({transform: to});
              angular.element(target).css(styles);
            }
          }
          function clamp(value) {
            return Math.max(0, Math.min(value || 0, 100));
          }
        }
        MdProgressLinearDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.radioButton', ['material.core']).directive('mdRadioGroup', mdRadioGroupDirective).directive('mdRadioButton', mdRadioButtonDirective);
        function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {
          RadioGroupController.prototype = createRadioGroupControllerProto();
          return {
            restrict: 'E',
            controller: ['$element', RadioGroupController],
            require: ['mdRadioGroup', '?ngModel'],
            link: {pre: linkRadioGroup}
          };
          function linkRadioGroup(scope, element, attr, ctrls) {
            $mdTheming(element);
            var rgCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            rgCtrl.init(ngModelCtrl);
            scope.mouseActive = false;
            element.attr({
              'role': 'radiogroup',
              'tabIndex': element.attr('tabindex') || '0'
            }).on('keydown', keydownListener).on('mousedown', function(event) {
              scope.mouseActive = true;
              $timeout(function() {
                scope.mouseActive = false;
              }, 100);
            }).on('focus', function() {
              if (scope.mouseActive === false) {
                rgCtrl.$element.addClass('md-focused');
              }
            }).on('blur', function() {
              rgCtrl.$element.removeClass('md-focused');
            });
            function setFocus() {
              if (!element.hasClass('md-focused')) {
                element.addClass('md-focused');
              }
            }
            function keydownListener(ev) {
              var keyCode = ev.which || ev.keyCode;
              if (keyCode != $mdConstant.KEY_CODE.ENTER && ev.currentTarget != ev.target) {
                return;
              }
              switch (keyCode) {
                case $mdConstant.KEY_CODE.LEFT_ARROW:
                case $mdConstant.KEY_CODE.UP_ARROW:
                  ev.preventDefault();
                  rgCtrl.selectPrevious();
                  setFocus();
                  break;
                case $mdConstant.KEY_CODE.RIGHT_ARROW:
                case $mdConstant.KEY_CODE.DOWN_ARROW:
                  ev.preventDefault();
                  rgCtrl.selectNext();
                  setFocus();
                  break;
                case $mdConstant.KEY_CODE.ENTER:
                  var form = angular.element($mdUtil.getClosest(element[0], 'form'));
                  if (form.length > 0) {
                    form.triggerHandler('submit');
                  }
                  break;
              }
            }
          }
          function RadioGroupController($element) {
            this._radioButtonRenderFns = [];
            this.$element = $element;
          }
          function createRadioGroupControllerProto() {
            return {
              init: function(ngModelCtrl) {
                this._ngModelCtrl = ngModelCtrl;
                this._ngModelCtrl.$render = angular.bind(this, this.render);
              },
              add: function(rbRender) {
                this._radioButtonRenderFns.push(rbRender);
              },
              remove: function(rbRender) {
                var index = this._radioButtonRenderFns.indexOf(rbRender);
                if (index !== -1) {
                  this._radioButtonRenderFns.splice(index, 1);
                }
              },
              render: function() {
                this._radioButtonRenderFns.forEach(function(rbRender) {
                  rbRender();
                });
              },
              setViewValue: function(value, eventType) {
                this._ngModelCtrl.$setViewValue(value, eventType);
                this.render();
              },
              getViewValue: function() {
                return this._ngModelCtrl.$viewValue;
              },
              selectNext: function() {
                return changeSelectedButton(this.$element, 1);
              },
              selectPrevious: function() {
                return changeSelectedButton(this.$element, -1);
              },
              setActiveDescendant: function(radioId) {
                this.$element.attr('aria-activedescendant', radioId);
              }
            };
          }
          function changeSelectedButton(parent, increment) {
            var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true);
            if (buttons.count()) {
              var validate = function(button) {
                return !angular.element(button).attr("disabled");
              };
              var selected = parent[0].querySelector('md-radio-button.md-checked');
              var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first();
              angular.element(target).triggerHandler('click');
            }
          }
        }
        mdRadioGroupDirective.$inject = ["$mdUtil", "$mdConstant", "$mdTheming", "$timeout"];
        function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
          var CHECKED_CSS = 'md-checked';
          return {
            restrict: 'E',
            require: '^mdRadioGroup',
            transclude: true,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-off"></div>' + '<div class="md-on"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            link: link
          };
          function link(scope, element, attr, rgCtrl) {
            var lastChecked;
            $mdTheming(element);
            configureAria(element, scope);
            initialize();
            function initialize(controller) {
              if (!rgCtrl) {
                throw 'RadioGroupController not found.';
              }
              rgCtrl.add(render);
              attr.$observe('value', render);
              element.on('click', listener).on('$destroy', function() {
                rgCtrl.remove(render);
              });
            }
            function listener(ev) {
              if (element[0].hasAttribute('disabled'))
                return;
              scope.$apply(function() {
                rgCtrl.setViewValue(attr.value, ev && ev.type);
              });
            }
            function render() {
              var checked = (rgCtrl.getViewValue() == attr.value);
              if (checked === lastChecked) {
                return;
              }
              lastChecked = checked;
              element.attr('aria-checked', checked);
              if (checked) {
                markParentAsChecked(true);
                element.addClass(CHECKED_CSS);
                rgCtrl.setActiveDescendant(element.attr('id'));
              } else {
                markParentAsChecked(false);
                element.removeClass(CHECKED_CSS);
              }
              function markParentAsChecked(addClass) {
                if (element.parent()[0].nodeName != "MD-RADIO-GROUP") {
                  element.parent()[!!addClass ? 'addClass' : 'removeClass'](CHECKED_CSS);
                }
              }
            }
            function configureAria(element, scope) {
              scope.ariaId = buildAriaID();
              element.attr({
                'id': scope.ariaId,
                'role': 'radio',
                'aria-checked': 'false'
              });
              $mdAria.expectWithText(element, 'aria-label');
              function buildAriaID() {
                return attr.id || ('radio' + "_" + $mdUtil.nextUid());
              }
            }
          }
        }
        mdRadioButtonDirective.$inject = ["$mdAria", "$mdUtil", "$mdTheming"];
      })();
      (function() {
        "use strict";
        var SELECT_EDGE_MARGIN = 8;
        var selectNextId = 0;
        angular.module('material.components.select', ['material.core', 'material.components.backdrop']).directive('mdSelect', SelectDirective).directive('mdSelectMenu', SelectMenuDirective).directive('mdOption', OptionDirective).directive('mdOptgroup', OptgroupDirective).provider('$mdSelect', SelectProvider);
        function SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $compile, $parse) {
          return {
            restrict: 'E',
            require: ['^?mdInputContainer', 'mdSelect', 'ngModel', '?^form'],
            compile: compile,
            controller: function() {}
          };
          function compile(element, attr) {
            var valueEl = angular.element('<md-select-value><span></span></md-select-value>');
            valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>');
            valueEl.addClass('md-select-value');
            if (!valueEl[0].hasAttribute('id')) {
              valueEl.attr('id', 'select_value_label_' + $mdUtil.nextUid());
            }
            if (!element.find('md-content').length) {
              element.append(angular.element('<md-content>').append(element.contents()));
            }
            if (attr.mdOnOpen) {
              element.find('md-content').prepend(angular.element('<div>' + ' <md-progress-circular md-mode="{{progressMode}}" ng-hide="$$loadingAsyncDone"></md-progress-circular>' + '</div>'));
              element.find('md-option').attr('ng-show', '$$loadingAsyncDone');
            }
            if (attr.name) {
              var autofillClone = angular.element('<select class="md-visually-hidden">');
              autofillClone.attr({
                'name': '.' + attr.name,
                'ng-model': attr.ngModel,
                'aria-hidden': 'true',
                'tabindex': '-1'
              });
              var opts = element.find('md-option');
              angular.forEach(opts, function(el) {
                var newEl = angular.element('<option>' + el.innerHTML + '</option>');
                if (el.hasAttribute('ng-value'))
                  newEl.attr('ng-value', el.getAttribute('ng-value'));
                else if (el.hasAttribute('value'))
                  newEl.attr('value', el.getAttribute('value'));
                autofillClone.append(newEl);
              });
              element.parent().append(autofillClone);
            }
            var multiple = angular.isDefined(attr.multiple) ? 'multiple' : '';
            var selectTemplate = '' + '<div class="md-select-menu-container" aria-hidden="true">' + '<md-select-menu {0}>{1}</md-select-menu>' + '</div>';
            selectTemplate = $mdUtil.supplant(selectTemplate, [multiple, element.html()]);
            element.empty().append(valueEl);
            element.append(selectTemplate);
            attr.tabindex = attr.tabindex || '0';
            return function postLink(scope, element, attr, ctrls) {
              var untouched = true;
              var isDisabled,
                  ariaLabelBase;
              var containerCtrl = ctrls[0];
              var mdSelectCtrl = ctrls[1];
              var ngModelCtrl = ctrls[2];
              var formCtrl = ctrls[3];
              var valueEl = element.find('md-select-value');
              var isReadonly = angular.isDefined(attr.readonly);
              if (containerCtrl) {
                var isErrorGetter = containerCtrl.isErrorGetter || function() {
                  return ngModelCtrl.$invalid && ngModelCtrl.$touched;
                };
                if (containerCtrl.input) {
                  throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
                }
                containerCtrl.input = element;
                if (!containerCtrl.label) {
                  $mdAria.expect(element, 'aria-label', element.attr('placeholder'));
                }
                scope.$watch(isErrorGetter, containerCtrl.setInvalid);
              }
              var selectContainer,
                  selectScope,
                  selectMenuCtrl;
              findSelectContainer();
              $mdTheming(element);
              if (attr.name && formCtrl) {
                var selectEl = element.parent()[0].querySelector('select[name=".' + attr.name + '"]');
                $mdUtil.nextTick(function() {
                  var controller = angular.element(selectEl).controller('ngModel');
                  if (controller) {
                    formCtrl.$removeControl(controller);
                  }
                });
              }
              if (formCtrl) {
                $mdUtil.nextTick(function() {
                  formCtrl.$setPristine();
                });
              }
              var originalRender = ngModelCtrl.$render;
              ngModelCtrl.$render = function() {
                originalRender();
                syncLabelText();
                syncAriaLabel();
                inputCheckValue();
              };
              attr.$observe('placeholder', ngModelCtrl.$render);
              mdSelectCtrl.setLabelText = function(text) {
                mdSelectCtrl.setIsPlaceholder(!text);
                var tmpPlaceholder = attr.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : '');
                text = text || tmpPlaceholder || '';
                var target = valueEl.children().eq(0);
                target.html(text);
              };
              mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
                if (isPlaceholder) {
                  valueEl.addClass('md-select-placeholder');
                  if (containerCtrl && containerCtrl.label) {
                    containerCtrl.label.addClass('md-placeholder');
                  }
                } else {
                  valueEl.removeClass('md-select-placeholder');
                  if (containerCtrl && containerCtrl.label) {
                    containerCtrl.label.removeClass('md-placeholder');
                  }
                }
              };
              if (!isReadonly) {
                element.on('focus', function(ev) {
                  if (containerCtrl && containerCtrl.element.hasClass('md-input-has-value')) {
                    containerCtrl.setFocused(true);
                  }
                });
                $mdUtil.nextTick(function() {
                  element.on('blur', function() {
                    if (untouched) {
                      untouched = false;
                      ngModelCtrl.$setUntouched();
                    }
                    if (selectScope.isOpen)
                      return;
                    containerCtrl && containerCtrl.setFocused(false);
                    inputCheckValue();
                  });
                });
              }
              mdSelectCtrl.triggerClose = function() {
                $parse(attr.mdOnClose)(scope);
              };
              scope.$$postDigest(function() {
                initAriaLabel();
                syncLabelText();
                syncAriaLabel();
              });
              function initAriaLabel() {
                var labelText = element.attr('aria-label') || element.attr('placeholder');
                if (!labelText && containerCtrl && containerCtrl.label) {
                  labelText = containerCtrl.label.text();
                }
                ariaLabelBase = labelText;
                $mdAria.expect(element, 'aria-label', labelText);
              }
              scope.$watch(selectMenuCtrl.selectedLabels, syncLabelText);
              function syncLabelText() {
                if (selectContainer) {
                  selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu');
                  mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
                }
              }
              function syncAriaLabel() {
                if (!ariaLabelBase)
                  return;
                var ariaLabels = selectMenuCtrl.selectedLabels({mode: 'aria'});
                element.attr('aria-label', ariaLabels.length ? ariaLabelBase + ': ' + ariaLabels : ariaLabelBase);
              }
              var deregisterWatcher;
              attr.$observe('ngMultiple', function(val) {
                if (deregisterWatcher)
                  deregisterWatcher();
                var parser = $parse(val);
                deregisterWatcher = scope.$watch(function() {
                  return parser(scope);
                }, function(multiple, prevVal) {
                  if (multiple === undefined && prevVal === undefined)
                    return;
                  if (multiple) {
                    element.attr('multiple', 'multiple');
                  } else {
                    element.removeAttr('multiple');
                  }
                  element.attr('aria-multiselectable', multiple ? 'true' : 'false');
                  if (selectContainer) {
                    selectMenuCtrl.setMultiple(multiple);
                    originalRender = ngModelCtrl.$render;
                    ngModelCtrl.$render = function() {
                      originalRender();
                      syncLabelText();
                      syncAriaLabel();
                      inputCheckValue();
                    };
                    ngModelCtrl.$render();
                  }
                });
              });
              attr.$observe('disabled', function(disabled) {
                if (angular.isString(disabled)) {
                  disabled = true;
                }
                if (isDisabled !== undefined && isDisabled === disabled) {
                  return;
                }
                isDisabled = disabled;
                if (disabled) {
                  element.attr({
                    'tabindex': -1,
                    'aria-disabled': 'true'
                  });
                  element.off('click', openSelect);
                  element.off('keydown', handleKeypress);
                } else {
                  element.attr({
                    'tabindex': attr.tabindex,
                    'aria-disabled': 'false'
                  });
                  element.on('click', openSelect);
                  element.on('keydown', handleKeypress);
                }
              });
              if (!attr.disabled && !attr.ngDisabled) {
                element.attr({
                  'tabindex': attr.tabindex,
                  'aria-disabled': 'false'
                });
                element.on('click', openSelect);
                element.on('keydown', handleKeypress);
              }
              var ariaAttrs = {
                role: 'listbox',
                'aria-expanded': 'false',
                'aria-multiselectable': attr.multiple !== undefined && !attr.ngMultiple ? 'true' : 'false'
              };
              if (!element[0].hasAttribute('id')) {
                ariaAttrs.id = 'select_' + $mdUtil.nextUid();
              }
              var containerId = 'select_container_' + $mdUtil.nextUid();
              selectContainer.attr('id', containerId);
              ariaAttrs['aria-owns'] = containerId;
              element.attr(ariaAttrs);
              scope.$on('$destroy', function() {
                $mdSelect.destroy().finally(function() {
                  if (containerCtrl) {
                    containerCtrl.setFocused(false);
                    containerCtrl.setHasValue(false);
                    containerCtrl.input = null;
                  }
                  ngModelCtrl.$setTouched();
                });
              });
              function inputCheckValue() {
                containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity || {}).badInput);
              }
              function findSelectContainer() {
                selectContainer = angular.element(element[0].querySelector('.md-select-menu-container'));
                selectScope = scope;
                if (element.attr('md-container-class')) {
                  var value = selectContainer[0].getAttribute('class') + ' ' + element.attr('md-container-class');
                  selectContainer[0].setAttribute('class', value);
                }
                selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu');
                selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
                element.on('$destroy', function() {
                  selectContainer.remove();
                });
              }
              function handleKeypress(e) {
                var allowedCodes = [32, 13, 38, 40];
                if (allowedCodes.indexOf(e.keyCode) != -1) {
                  e.preventDefault();
                  openSelect(e);
                } else {
                  if (e.keyCode <= 90 && e.keyCode >= 31) {
                    e.preventDefault();
                    var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
                    if (!node)
                      return;
                    var optionCtrl = angular.element(node).controller('mdOption');
                    if (!selectMenuCtrl.isMultiple) {
                      selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
                    }
                    selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                    selectMenuCtrl.refreshViewValue();
                  }
                }
              }
              function openSelect() {
                selectScope.isOpen = true;
                element.attr('aria-expanded', 'true');
                $mdSelect.show({
                  scope: selectScope,
                  preserveScope: true,
                  skipCompile: true,
                  element: selectContainer,
                  target: element[0],
                  selectCtrl: mdSelectCtrl,
                  preserveElement: true,
                  hasBackdrop: true,
                  loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false
                }).finally(function() {
                  selectScope.isOpen = false;
                  element.focus();
                  element.attr('aria-expanded', 'false');
                  ngModelCtrl.$setTouched();
                });
              }
            };
          }
        }
        SelectDirective.$inject = ["$mdSelect", "$mdUtil", "$mdTheming", "$mdAria", "$compile", "$parse"];
        function SelectMenuDirective($parse, $mdUtil, $mdTheming) {
          SelectMenuController.$inject = ["$scope", "$attrs", "$element"];
          return {
            restrict: 'E',
            require: ['mdSelectMenu'],
            scope: true,
            controller: SelectMenuController,
            link: {pre: preLink}
          };
          function preLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0];
            $mdTheming(element);
            element.on('click', clickListener);
            element.on('keypress', keyListener);
            function keyListener(e) {
              if (e.keyCode == 13 || e.keyCode == 32) {
                clickListener(e);
              }
            }
            function clickListener(ev) {
              var option = $mdUtil.getClosest(ev.target, 'md-option');
              var optionCtrl = option && angular.element(option).data('$mdOptionController');
              if (!option || !optionCtrl)
                return;
              if (option.hasAttribute('disabled')) {
                ev.stopImmediatePropagation();
                return false;
              }
              var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);
              var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);
              scope.$apply(function() {
                if (selectCtrl.isMultiple) {
                  if (isSelected) {
                    selectCtrl.deselect(optionHashKey);
                  } else {
                    selectCtrl.select(optionHashKey, optionCtrl.value);
                  }
                } else {
                  if (!isSelected) {
                    selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                    selectCtrl.select(optionHashKey, optionCtrl.value);
                  }
                }
                selectCtrl.refreshViewValue();
              });
            }
          }
          function SelectMenuController($scope, $attrs, $element) {
            var self = this;
            self.isMultiple = angular.isDefined($attrs.multiple);
            self.selected = {};
            self.options = {};
            $scope.$watchCollection(function() {
              return self.options;
            }, function() {
              self.ngModel.$render();
            });
            var deregisterCollectionWatch;
            var defaultIsEmpty;
            self.setMultiple = function(isMultiple) {
              var ngModel = self.ngModel;
              defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;
              self.isMultiple = isMultiple;
              if (deregisterCollectionWatch)
                deregisterCollectionWatch();
              if (self.isMultiple) {
                ngModel.$validators['md-multiple'] = validateArray;
                ngModel.$render = renderMultiple;
                $scope.$watchCollection(self.modelBinding, function(value) {
                  if (validateArray(value))
                    renderMultiple(value);
                  self.ngModel.$setPristine();
                });
                ngModel.$isEmpty = function(value) {
                  return !value || value.length === 0;
                };
              } else {
                delete ngModel.$validators['md-multiple'];
                ngModel.$render = renderSingular;
              }
              function validateArray(modelValue, viewValue) {
                return angular.isArray(modelValue || viewValue || []);
              }
            };
            var searchStr = '';
            var clearSearchTimeout,
                optNodes,
                optText;
            var CLEAR_SEARCH_AFTER = 300;
            self.optNodeForKeyboardSearch = function(e) {
              clearSearchTimeout && clearTimeout(clearSearchTimeout);
              clearSearchTimeout = setTimeout(function() {
                clearSearchTimeout = undefined;
                searchStr = '';
                optText = undefined;
                optNodes = undefined;
              }, CLEAR_SEARCH_AFTER);
              searchStr += String.fromCharCode(e.keyCode);
              var search = new RegExp('^' + searchStr, 'i');
              if (!optNodes) {
                optNodes = $element.find('md-option');
                optText = new Array(optNodes.length);
                angular.forEach(optNodes, function(el, i) {
                  optText[i] = el.textContent.trim();
                });
              }
              for (var i = 0; i < optText.length; ++i) {
                if (search.test(optText[i])) {
                  return optNodes[i];
                }
              }
            };
            self.init = function(ngModel, binding) {
              self.ngModel = ngModel;
              self.modelBinding = binding;
              if (ngModel.$options && ngModel.$options.trackBy) {
                var trackByLocals = {};
                var trackByParsed = $parse(ngModel.$options.trackBy);
                self.hashGetter = function(value, valueScope) {
                  trackByLocals.$value = value;
                  return trackByParsed(valueScope || $scope, trackByLocals);
                };
              } else {
                self.hashGetter = function getHashValue(value) {
                  if (angular.isObject(value)) {
                    return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));
                  }
                  return value;
                };
              }
              self.setMultiple(self.isMultiple);
            };
            self.selectedLabels = function(opts) {
              opts = opts || {};
              var mode = opts.mode || 'html';
              var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll('md-option[selected]'));
              if (selectedOptionEls.length) {
                var mapFn;
                if (mode == 'html') {
                  mapFn = function(el) {
                    return el.innerHTML;
                  };
                } else if (mode == 'aria') {
                  mapFn = function(el) {
                    return el.hasAttribute('aria-label') ? el.getAttribute('aria-label') : el.textContent;
                  };
                }
                return selectedOptionEls.map(mapFn).join(', ');
              } else {
                return '';
              }
            };
            self.select = function(hashKey, hashedValue) {
              var option = self.options[hashKey];
              option && option.setSelected(true);
              self.selected[hashKey] = hashedValue;
            };
            self.deselect = function(hashKey) {
              var option = self.options[hashKey];
              option && option.setSelected(false);
              delete self.selected[hashKey];
            };
            self.addOption = function(hashKey, optionCtrl) {
              if (angular.isDefined(self.options[hashKey])) {
                throw new Error('Duplicate md-option values are not allowed in a select. ' + 'Duplicate value "' + optionCtrl.value + '" found.');
              }
              self.options[hashKey] = optionCtrl;
              if (angular.isDefined(self.selected[hashKey])) {
                self.select(hashKey, optionCtrl.value);
                self.refreshViewValue();
              }
            };
            self.removeOption = function(hashKey) {
              delete self.options[hashKey];
            };
            self.refreshViewValue = function() {
              var values = [];
              var option;
              for (var hashKey in self.selected) {
                if ((option = self.options[hashKey])) {
                  values.push(option.value);
                } else {
                  values.push(self.selected[hashKey]);
                }
              }
              var usingTrackBy = self.ngModel.$options && self.ngModel.$options.trackBy;
              var newVal = self.isMultiple ? values : values[0];
              var prevVal = self.ngModel.$modelValue;
              if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal != newVal) {
                self.ngModel.$setViewValue(newVal);
                self.ngModel.$render();
              }
            };
            function renderMultiple() {
              var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
              if (!angular.isArray(newSelectedValues))
                return;
              var oldSelected = Object.keys(self.selected);
              var newSelectedHashes = newSelectedValues.map(self.hashGetter);
              var deselected = oldSelected.filter(function(hash) {
                return newSelectedHashes.indexOf(hash) === -1;
              });
              deselected.forEach(self.deselect);
              newSelectedHashes.forEach(function(hashKey, i) {
                self.select(hashKey, newSelectedValues[i]);
              });
            }
            function renderSingular() {
              var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
              Object.keys(self.selected).forEach(self.deselect);
              self.select(self.hashGetter(value), value);
            }
          }
        }
        SelectMenuDirective.$inject = ["$parse", "$mdUtil", "$mdTheming"];
        function OptionDirective($mdButtonInkRipple, $mdUtil) {
          OptionController.$inject = ["$element"];
          return {
            restrict: 'E',
            require: ['mdOption', '^^mdSelectMenu'],
            controller: OptionController,
            compile: compile
          };
          function compile(element, attr) {
            element.append(angular.element('<div class="md-text">').append(element.contents()));
            element.attr('tabindex', attr.tabindex || '0');
            return postLink;
          }
          function postLink(scope, element, attr, ctrls) {
            var optionCtrl = ctrls[0];
            var selectCtrl = ctrls[1];
            if (angular.isDefined(attr.ngValue)) {
              scope.$watch(attr.ngValue, setOptionValue);
            } else if (angular.isDefined(attr.value)) {
              setOptionValue(attr.value);
            } else {
              scope.$watch(function() {
                return element.text();
              }, setOptionValue);
            }
            attr.$observe('disabled', function(disabled) {
              if (disabled) {
                element.attr('tabindex', '-1');
              } else {
                element.attr('tabindex', '0');
              }
            });
            scope.$$postDigest(function() {
              attr.$observe('selected', function(selected) {
                if (!angular.isDefined(selected))
                  return;
                if (typeof selected == 'string')
                  selected = true;
                if (selected) {
                  if (!selectCtrl.isMultiple) {
                    selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                  }
                  selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                } else {
                  selectCtrl.deselect(optionCtrl.hashKey);
                }
                selectCtrl.refreshViewValue();
              });
            });
            $mdButtonInkRipple.attach(scope, element);
            configureAria();
            function setOptionValue(newValue, oldValue, prevAttempt) {
              if (!selectCtrl.hashGetter) {
                if (!prevAttempt) {
                  scope.$$postDigest(function() {
                    setOptionValue(newValue, oldValue, true);
                  });
                }
                return;
              }
              var oldHashKey = selectCtrl.hashGetter(oldValue, scope);
              var newHashKey = selectCtrl.hashGetter(newValue, scope);
              optionCtrl.hashKey = newHashKey;
              optionCtrl.value = newValue;
              selectCtrl.removeOption(oldHashKey, optionCtrl);
              selectCtrl.addOption(newHashKey, optionCtrl);
            }
            scope.$on('$destroy', function() {
              selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
            });
            function configureAria() {
              var ariaAttrs = {
                'role': 'option',
                'aria-selected': 'false'
              };
              if (!element[0].hasAttribute('id')) {
                ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();
              }
              element.attr(ariaAttrs);
            }
          }
          function OptionController($element) {
            this.selected = false;
            this.setSelected = function(isSelected) {
              if (isSelected && !this.selected) {
                $element.attr({
                  'selected': 'selected',
                  'aria-selected': 'true'
                });
              } else if (!isSelected && this.selected) {
                $element.removeAttr('selected');
                $element.attr('aria-selected', 'false');
              }
              this.selected = isSelected;
            };
          }
        }
        OptionDirective.$inject = ["$mdButtonInkRipple", "$mdUtil"];
        function OptgroupDirective() {
          return {
            restrict: 'E',
            compile: compile
          };
          function compile(el, attrs) {
            var labelElement = el.find('label');
            if (!labelElement.length) {
              labelElement = angular.element('<label>');
              el.prepend(labelElement);
            }
            labelElement.addClass('md-container-ignore');
            if (attrs.label)
              labelElement.text(attrs.label);
          }
        }
        function SelectProvider($$interimElementProvider) {
          selectDefaultOptions.$inject = ["$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document"];
          return $$interimElementProvider('$mdSelect').setDefaults({
            methods: ['target'],
            options: selectDefaultOptions
          });
          function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
            var ERRROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!";
            var animator = $mdUtil.dom.animator;
            return {
              parent: 'body',
              themable: true,
              onShow: onShow,
              onRemove: onRemove,
              hasBackdrop: true,
              disableParentScroll: true
            };
            function onRemove(scope, element, opts) {
              opts = opts || {};
              opts.cleanupInteraction();
              opts.cleanupResizing();
              opts.hideBackdrop();
              return (opts.$destroy === true) ? cleanElement() : animateRemoval().then(cleanElement);
              function animateRemoval() {
                return $animateCss(element, {addClass: 'md-leave'}).start();
              }
              function cleanElement() {
                element.removeClass('md-active');
                element.attr('aria-hidden', 'true');
                element[0].style.display = 'none';
                announceClosed(opts);
                if (!opts.$destroy && opts.restoreFocus) {
                  opts.target.focus();
                }
              }
            }
            function onShow(scope, element, opts) {
              watchAsyncLoad();
              sanitizeAndConfigure(scope, opts);
              opts.hideBackdrop = showBackdrop(scope, element, opts);
              return showDropDown(scope, element, opts).then(function(response) {
                element.attr('aria-hidden', 'false');
                opts.alreadyOpen = true;
                opts.cleanupInteraction = activateInteraction();
                opts.cleanupResizing = activateResizing();
                return response;
              }, opts.hideBackdrop);
              function showDropDown(scope, element, opts) {
                opts.parent.append(element);
                return $q(function(resolve, reject) {
                  try {
                    $animateCss(element, {
                      removeClass: 'md-leave',
                      duration: 0
                    }).start().then(positionAndFocusMenu).then(resolve);
                  } catch (e) {
                    reject(e);
                  }
                });
              }
              function positionAndFocusMenu() {
                return $q(function(resolve) {
                  if (opts.isRemoved)
                    return $q.reject(false);
                  var info = calculateMenuPositions(scope, element, opts);
                  info.container.element.css(animator.toCss(info.container.styles));
                  info.dropDown.element.css(animator.toCss(info.dropDown.styles));
                  $$rAF(function() {
                    element.addClass('md-active');
                    info.dropDown.element.css(animator.toCss({transform: ''}));
                    autoFocus(opts.focusedNode);
                    resolve();
                  });
                });
              }
              function showBackdrop(scope, element, options) {
                if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
                  options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
                } else {
                  options.disableParentScroll = false;
                }
                if (options.hasBackdrop) {
                  options.backdrop = $mdUtil.createBackdrop(scope, "md-select-backdrop md-click-catcher");
                  $animate.enter(options.backdrop, $document[0].body, null, {duration: 0});
                }
                return function hideBackdrop() {
                  if (options.backdrop)
                    options.backdrop.remove();
                  if (options.disableParentScroll)
                    options.restoreScroll();
                  delete options.restoreScroll;
                };
              }
              function autoFocus(focusedNode) {
                if (focusedNode && !focusedNode.hasAttribute('disabled')) {
                  focusedNode.focus();
                }
              }
              function sanitizeAndConfigure(scope, options) {
                var selectEl = element.find('md-select-menu');
                if (!options.target) {
                  throw new Error($mdUtil.supplant(ERRROR_TARGET_EXPECTED, [options.target]));
                }
                angular.extend(options, {
                  isRemoved: false,
                  target: angular.element(options.target),
                  parent: angular.element(options.parent),
                  selectEl: selectEl,
                  contentEl: element.find('md-content'),
                  optionNodes: selectEl[0].getElementsByTagName('md-option')
                });
              }
              function activateResizing() {
                var debouncedOnResize = (function(scope, target, options) {
                  return function() {
                    if (options.isRemoved)
                      return;
                    var updates = calculateMenuPositions(scope, target, options);
                    var container = updates.container;
                    var dropDown = updates.dropDown;
                    container.element.css(animator.toCss(container.styles));
                    dropDown.element.css(animator.toCss(dropDown.styles));
                  };
                })(scope, element, opts);
                var window = angular.element($window);
                window.on('resize', debouncedOnResize);
                window.on('orientationchange', debouncedOnResize);
                return function deactivateResizing() {
                  window.off('resize', debouncedOnResize);
                  window.off('orientationchange', debouncedOnResize);
                };
              }
              function watchAsyncLoad() {
                if (opts.loadingAsync && !opts.isRemoved) {
                  scope.$$loadingAsyncDone = false;
                  scope.progressMode = 'indeterminate';
                  $q.when(opts.loadingAsync).then(function() {
                    scope.$$loadingAsyncDone = true;
                    scope.progressMode = '';
                    delete opts.loadingAsync;
                  }).then(function() {
                    $$rAF(positionAndFocusMenu);
                  });
                }
              }
              function activateInteraction() {
                if (opts.isRemoved)
                  return;
                var dropDown = opts.selectEl;
                var selectCtrl = dropDown.controller('mdSelectMenu') || {};
                element.addClass('md-clickable');
                opts.backdrop && opts.backdrop.on('click', onBackdropClick);
                dropDown.on('keydown', onMenuKeyDown);
                dropDown.on('click', checkCloseMenu);
                return function cleanupInteraction() {
                  opts.backdrop && opts.backdrop.off('click', onBackdropClick);
                  dropDown.off('keydown', onMenuKeyDown);
                  dropDown.off('click', checkCloseMenu);
                  element.removeClass('md-clickable');
                  opts.isRemoved = true;
                };
                function onBackdropClick(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  opts.restoreFocus = false;
                  $mdUtil.nextTick($mdSelect.hide, true);
                }
                function onMenuKeyDown(ev) {
                  var keyCodes = $mdConstant.KEY_CODE;
                  ev.preventDefault();
                  ev.stopPropagation();
                  switch (ev.keyCode) {
                    case keyCodes.UP_ARROW:
                      return focusPrevOption();
                    case keyCodes.DOWN_ARROW:
                      return focusNextOption();
                    case keyCodes.SPACE:
                    case keyCodes.ENTER:
                      var option = $mdUtil.getClosest(ev.target, 'md-option');
                      if (option) {
                        dropDown.triggerHandler({
                          type: 'click',
                          target: option
                        });
                        ev.preventDefault();
                      }
                      checkCloseMenu(ev);
                      break;
                    case keyCodes.TAB:
                    case keyCodes.ESCAPE:
                      ev.stopPropagation();
                      ev.preventDefault();
                      opts.restoreFocus = true;
                      $mdUtil.nextTick($mdSelect.hide, true);
                      break;
                    default:
                      if (ev.keyCode >= 31 && ev.keyCode <= 90) {
                        var optNode = dropDown.controller('mdSelectMenu').optNodeForKeyboardSearch(ev);
                        opts.focusedNode = optNode || opts.focusedNode;
                        optNode && optNode.focus();
                      }
                  }
                }
                function focusOption(direction) {
                  var optionsArray = $mdUtil.nodesToArray(opts.optionNodes);
                  var index = optionsArray.indexOf(opts.focusedNode);
                  var newOption;
                  do {
                    if (index === -1) {
                      index = 0;
                    } else if (direction === 'next' && index < optionsArray.length - 1) {
                      index++;
                    } else if (direction === 'prev' && index > 0) {
                      index--;
                    }
                    newOption = optionsArray[index];
                    if (newOption.hasAttribute('disabled'))
                      newOption = undefined;
                  } while (!newOption && index < optionsArray.length - 1 && index > 0);
                  newOption && newOption.focus();
                  opts.focusedNode = newOption;
                }
                function focusNextOption() {
                  focusOption('next');
                }
                function focusPrevOption() {
                  focusOption('prev');
                }
                function checkCloseMenu(ev) {
                  if (ev && (ev.type == 'click') && (ev.currentTarget != dropDown[0]))
                    return;
                  if (mouseOnScrollbar())
                    return;
                  var option = $mdUtil.getClosest(ev.target, 'md-option');
                  if (option && option.hasAttribute && !option.hasAttribute('disabled')) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (!selectCtrl.isMultiple) {
                      opts.restoreFocus = true;
                      $mdUtil.nextTick(function() {
                        $mdSelect.hide(selectCtrl.ngModel.$viewValue);
                      }, true);
                    }
                  }
                  function mouseOnScrollbar() {
                    var clickOnScrollbar = false;
                    if (ev && (ev.currentTarget.children.length > 0)) {
                      var child = ev.currentTarget.children[0];
                      var hasScrollbar = child.scrollHeight > child.clientHeight;
                      if (hasScrollbar && child.children.length > 0) {
                        var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
                        if (relPosX > child.querySelector('md-option').offsetWidth)
                          clickOnScrollbar = true;
                      }
                    }
                    return clickOnScrollbar;
                  }
                }
              }
            }
            function announceClosed(opts) {
              var mdSelect = opts.selectCtrl;
              if (mdSelect) {
                var menuController = opts.selectEl.controller('mdSelectMenu');
                mdSelect.setLabelText(menuController.selectedLabels());
                mdSelect.triggerClose();
              }
            }
            function calculateMenuPositions(scope, element, opts) {
              var containerNode = element[0],
                  targetNode = opts.target[0].children[0],
                  parentNode = $document[0].body,
                  selectNode = opts.selectEl[0],
                  contentNode = opts.contentEl[0],
                  parentRect = parentNode.getBoundingClientRect(),
                  targetRect = targetNode.getBoundingClientRect(),
                  shouldOpenAroundTarget = false,
                  bounds = {
                    left: parentRect.left + SELECT_EDGE_MARGIN,
                    top: SELECT_EDGE_MARGIN,
                    bottom: parentRect.height - SELECT_EDGE_MARGIN,
                    right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
                  },
                  spaceAvailable = {
                    top: targetRect.top - bounds.top,
                    left: targetRect.left - bounds.left,
                    right: bounds.right - (targetRect.left + targetRect.width),
                    bottom: bounds.bottom - (targetRect.top + targetRect.height)
                  },
                  maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,
                  selectedNode = selectNode.querySelector('md-option[selected]'),
                  optionNodes = selectNode.getElementsByTagName('md-option'),
                  optgroupNodes = selectNode.getElementsByTagName('md-optgroup'),
                  isScrollable = calculateScrollable(element, contentNode),
                  centeredNode;
              var loading = isPromiseLike(opts.loadingAsync);
              if (!loading) {
                if (selectedNode) {
                  centeredNode = selectedNode;
                } else if (optgroupNodes.length) {
                  centeredNode = optgroupNodes[0];
                } else if (optionNodes.length) {
                  centeredNode = optionNodes[0];
                } else {
                  centeredNode = contentNode.firstElementChild || contentNode;
                }
              } else {
                centeredNode = contentNode.firstElementChild || contentNode;
              }
              if (contentNode.offsetWidth > maxWidth) {
                contentNode.style['max-width'] = maxWidth + 'px';
              } else {
                contentNode.style.maxWidth = null;
              }
              if (shouldOpenAroundTarget) {
                contentNode.style['min-width'] = targetRect.width + 'px';
              }
              if (isScrollable) {
                selectNode.classList.add('md-overflow');
              }
              var focusedNode = centeredNode;
              if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {
                focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
                centeredNode = focusedNode;
              }
              opts.focusedNode = focusedNode;
              containerNode.style.display = 'block';
              var selectMenuRect = selectNode.getBoundingClientRect();
              var centeredRect = getOffsetRect(centeredNode);
              if (centeredNode) {
                var centeredStyle = $window.getComputedStyle(centeredNode);
                centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
                centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
              }
              if (isScrollable) {
                var scrollBuffer = contentNode.offsetHeight / 2;
                contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;
                if (spaceAvailable.top < scrollBuffer) {
                  contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top);
                } else if (spaceAvailable.bottom < scrollBuffer) {
                  contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom);
                }
              }
              var left,
                  top,
                  transformOrigin,
                  minWidth;
              if (shouldOpenAroundTarget) {
                left = targetRect.left;
                top = targetRect.top + targetRect.height;
                transformOrigin = '50% 0';
                if (top + selectMenuRect.height > bounds.bottom) {
                  top = targetRect.top - selectMenuRect.height;
                  transformOrigin = '50% 100%';
                }
              } else {
                left = (targetRect.left + centeredRect.left - centeredRect.paddingLeft) + 2;
                top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2;
                transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';
                minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);
              }
              var containerRect = containerNode.getBoundingClientRect();
              var scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1.0)) / 100;
              var scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1.0)) / 100;
              return {
                container: {
                  element: angular.element(containerNode),
                  styles: {
                    left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
                    top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
                    'min-width': minWidth
                  }
                },
                dropDown: {
                  element: angular.element(selectNode),
                  styles: {
                    transformOrigin: transformOrigin,
                    transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : ""
                  }
                }
              };
            }
          }
          function isPromiseLike(obj) {
            return obj && angular.isFunction(obj.then);
          }
          function clamp(min, n, max) {
            return Math.max(min, Math.min(n, max));
          }
          function getOffsetRect(node) {
            return node ? {
              left: node.offsetLeft,
              top: node.offsetTop,
              width: node.offsetWidth,
              height: node.offsetHeight
            } : {
              left: 0,
              top: 0,
              width: 0,
              height: 0
            };
          }
          function calculateScrollable(element, contentNode) {
            var isScrollable = false;
            try {
              var oldDisplay = element[0].style.display;
              element[0].style.display = 'block';
              isScrollable = contentNode.scrollHeight > contentNode.offsetHeight;
              element[0].style.display = oldDisplay;
            } finally {}
            return isScrollable;
          }
        }
        SelectProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.showHide', ['material.core']).directive('ngShow', createDirective('ngShow', true)).directive('ngHide', createDirective('ngHide', false));
        function createDirective(name, targetValue) {
          return ['$mdUtil', function($mdUtil) {
            return {
              restrict: 'A',
              multiElement: true,
              link: function($scope, $element, $attr) {
                var unregister = $scope.$on('$md-resize-enable', function() {
                  unregister();
                  $scope.$watch($attr[name], function(value) {
                    if (!!value === targetValue) {
                      $mdUtil.nextTick(function() {
                        $scope.$broadcast('$md-resize');
                      });
                      $mdUtil.dom.animator.waitTransitionEnd($element).then(function() {
                        $scope.$broadcast('$md-resize');
                      });
                    }
                  });
                });
              }
            };
          }];
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.sidenav', ['material.core', 'material.components.backdrop']).factory('$mdSidenav', SidenavService).directive('mdSidenav', SidenavDirective).directive('mdSidenavFocus', SidenavFocusDirective).controller('$mdSidenavController', SidenavController);
        function SidenavService($mdComponentRegistry, $q) {
          return function(handle) {
            var self;
            var errorMsg = "SideNav '" + handle + "' is not available!";
            var instance = $mdComponentRegistry.get(handle);
            if (!instance) {
              $mdComponentRegistry.notFoundError(handle);
            }
            return self = {
              isOpen: function() {
                return instance && instance.isOpen();
              },
              isLockedOpen: function() {
                return instance && instance.isLockedOpen();
              },
              toggle: function() {
                return instance ? instance.toggle() : $q.reject(errorMsg);
              },
              open: function() {
                return instance ? instance.open() : $q.reject(errorMsg);
              },
              close: function() {
                return instance ? instance.close() : $q.reject(errorMsg);
              },
              then: function(callbackFn) {
                var promise = instance ? $q.when(instance) : waitForInstance();
                return promise.then(callbackFn || angular.noop);
              }
            };
            function waitForInstance() {
              return $mdComponentRegistry.when(handle).then(function(it) {
                instance = it;
                return it;
              });
            }
          };
        }
        SidenavService.$inject = ["$mdComponentRegistry", "$q"];
        function SidenavFocusDirective() {
          return {
            restrict: 'A',
            require: '^mdSidenav',
            link: function(scope, element, attr, sidenavCtrl) {}
          };
        }
        function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $animate, $compile, $parse, $log, $q, $document) {
          return {
            restrict: 'E',
            scope: {isOpen: '=?mdIsOpen'},
            controller: '$mdSidenavController',
            compile: function(element) {
              element.addClass('md-closed');
              element.attr('tabIndex', '-1');
              return postLink;
            }
          };
          function postLink(scope, element, attr, sidenavCtrl) {
            var lastParentOverFlow;
            var triggeringElement = null;
            var promise = $q.when(true);
            var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);
            var isLocked = function() {
              return isLockedOpenParsed(scope.$parent, {
                $media: function(arg) {
                  $log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
                  return $mdMedia(arg);
                },
                $mdMedia: $mdMedia
              });
            };
            var backdrop = $mdUtil.createBackdrop(scope, "md-sidenav-backdrop md-opaque ng-enter");
            $mdTheming.inherit(backdrop, element);
            element.on('$destroy', function() {
              backdrop.remove();
              sidenavCtrl.destroy();
            });
            scope.$on('$destroy', function() {
              backdrop.remove();
            });
            scope.$watch(isLocked, updateIsLocked);
            scope.$watch('isOpen', updateIsOpen);
            sidenavCtrl.$toggleOpen = toggleOpen;
            function updateIsLocked(isLocked, oldValue) {
              scope.isLockedOpen = isLocked;
              if (isLocked === oldValue) {
                element.toggleClass('md-locked-open', !!isLocked);
              } else {
                $animate[isLocked ? 'addClass' : 'removeClass'](element, 'md-locked-open');
              }
              backdrop.toggleClass('md-locked-open', !!isLocked);
            }
            function updateIsOpen(isOpen) {
              var focusEl = $mdUtil.findFocusTarget(element) || $mdUtil.findFocusTarget(element, '[md-sidenav-focus]') || element;
              var parent = element.parent();
              parent[isOpen ? 'on' : 'off']('keydown', onKeyDown);
              backdrop[isOpen ? 'on' : 'off']('click', close);
              if (isOpen) {
                triggeringElement = $document[0].activeElement;
              }
              disableParentScroll(isOpen);
              return promise = $q.all([isOpen ? $animate.enter(backdrop, parent) : $animate.leave(backdrop), $animate[isOpen ? 'removeClass' : 'addClass'](element, 'md-closed')]).then(function() {
                if (scope.isOpen) {
                  focusEl && focusEl.focus();
                }
              });
            }
            function disableParentScroll(disabled) {
              var parent = element.parent();
              if (disabled && !lastParentOverFlow) {
                lastParentOverFlow = parent.css('overflow');
                parent.css('overflow', 'hidden');
              } else if (angular.isDefined(lastParentOverFlow)) {
                parent.css('overflow', lastParentOverFlow);
                lastParentOverFlow = undefined;
              }
            }
            function toggleOpen(isOpen) {
              if (scope.isOpen == isOpen) {
                return $q.when(true);
              } else {
                return $q(function(resolve) {
                  scope.isOpen = isOpen;
                  $mdUtil.nextTick(function() {
                    promise.then(function(result) {
                      if (!scope.isOpen) {
                        triggeringElement && triggeringElement.focus();
                        triggeringElement = null;
                      }
                      resolve(result);
                    });
                  });
                });
              }
            }
            function onKeyDown(ev) {
              var isEscape = (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE);
              return isEscape ? close(ev) : $q.when(true);
            }
            function close(ev) {
              ev.preventDefault();
              return sidenavCtrl.close();
            }
          }
        }
        SidenavDirective.$inject = ["$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$animate", "$compile", "$parse", "$log", "$q", "$document"];
        function SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {
          var self = this;
          self.isOpen = function() {
            return !!$scope.isOpen;
          };
          self.isLockedOpen = function() {
            return !!$scope.isLockedOpen;
          };
          self.open = function() {
            return self.$toggleOpen(true);
          };
          self.close = function() {
            return self.$toggleOpen(false);
          };
          self.toggle = function() {
            return self.$toggleOpen(!$scope.isOpen);
          };
          self.$toggleOpen = function(value) {
            return $q.when($scope.isOpen = value);
          };
          self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);
        }
        SidenavController.$inject = ["$scope", "$element", "$attrs", "$mdComponentRegistry", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.slider', ['material.core']).directive('mdSlider', SliderDirective);
        function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log) {
          return {
            scope: {},
            require: '?ngModel',
            template: '<div class="md-slider-wrapper">' + '<div class="md-track-container">' + '<div class="md-track"></div>' + '<div class="md-track md-track-fill"></div>' + '<div class="md-track-ticks"></div>' + '</div>' + '<div class="md-thumb-container">' + '<div class="md-thumb"></div>' + '<div class="md-focus-thumb"></div>' + '<div class="md-focus-ring"></div>' + '<div class="md-sign">' + '<span class="md-thumb-text"></span>' + '</div>' + '<div class="md-disabled-thumb"></div>' + '</div>' + '</div>',
            compile: compile
          };
          function compile(tElement, tAttrs) {
            tElement.attr({
              tabIndex: 0,
              role: 'slider'
            });
            $mdAria.expect(tElement, 'aria-label');
            return postLink;
          }
          function postLink(scope, element, attr, ngModelCtrl) {
            $mdTheming(element);
            ngModelCtrl = ngModelCtrl || {
              $setViewValue: function(val) {
                this.$viewValue = val;
                this.$viewChangeListeners.forEach(function(cb) {
                  cb();
                });
              },
              $parsers: [],
              $formatters: [],
              $viewChangeListeners: []
            };
            var isDisabledGetter = angular.noop;
            if (attr.disabled != null) {
              isDisabledGetter = function() {
                return true;
              };
            } else if (attr.ngDisabled) {
              isDisabledGetter = angular.bind(null, $parse(attr.ngDisabled), scope.$parent);
            }
            var thumb = angular.element(element[0].querySelector('.md-thumb'));
            var thumbText = angular.element(element[0].querySelector('.md-thumb-text'));
            var thumbContainer = thumb.parent();
            var trackContainer = angular.element(element[0].querySelector('.md-track-container'));
            var activeTrack = angular.element(element[0].querySelector('.md-track-fill'));
            var tickContainer = angular.element(element[0].querySelector('.md-track-ticks'));
            var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000);
            angular.isDefined(attr.min) ? attr.$observe('min', updateMin) : updateMin(0);
            angular.isDefined(attr.max) ? attr.$observe('max', updateMax) : updateMax(100);
            angular.isDefined(attr.step) ? attr.$observe('step', updateStep) : updateStep(1);
            var stopDisabledWatch = angular.noop;
            if (attr.ngDisabled) {
              stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);
            }
            $mdGesture.register(element, 'drag');
            element.on('keydown', keydownListener).on('$md.pressdown', onPressDown).on('$md.pressup', onPressUp).on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
            function updateAll() {
              refreshSliderDimensions();
              ngModelRender();
              redrawTicks();
            }
            setTimeout(updateAll, 0);
            var debouncedUpdateAll = $$rAF.throttle(updateAll);
            angular.element($window).on('resize', debouncedUpdateAll);
            scope.$on('$destroy', function() {
              angular.element($window).off('resize', debouncedUpdateAll);
              stopDisabledWatch();
            });
            ngModelCtrl.$render = ngModelRender;
            ngModelCtrl.$viewChangeListeners.push(ngModelRender);
            ngModelCtrl.$formatters.push(minMaxValidator);
            ngModelCtrl.$formatters.push(stepValidator);
            var min;
            var max;
            var step;
            function updateMin(value) {
              min = parseFloat(value);
              element.attr('aria-valuemin', value);
              updateAll();
            }
            function updateMax(value) {
              max = parseFloat(value);
              element.attr('aria-valuemax', value);
              updateAll();
            }
            function updateStep(value) {
              step = parseFloat(value);
              redrawTicks();
            }
            function updateAriaDisabled(isDisabled) {
              element.attr('aria-disabled', !!isDisabled);
            }
            var tickCanvas,
                tickCtx;
            function redrawTicks() {
              if (!angular.isDefined(attr.mdDiscrete))
                return;
              if (angular.isUndefined(step))
                return;
              if (step <= 0) {
                var msg = 'Slider step value must be greater than zero when in discrete mode';
                $log.error(msg);
                throw new Error(msg);
              }
              var numSteps = Math.floor((max - min) / step);
              if (!tickCanvas) {
                tickCanvas = angular.element('<canvas style="position:absolute;">');
                tickContainer.append(tickCanvas);
                var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                tickCtx = tickCanvas[0].getContext('2d');
                tickCtx.fillStyle = trackTicksStyle.backgroundColor || 'black';
              }
              var dimensions = getSliderDimensions();
              tickCanvas[0].width = dimensions.width;
              tickCanvas[0].height = dimensions.height;
              var distance;
              for (var i = 0; i <= numSteps; i++) {
                distance = Math.floor(dimensions.width * (i / numSteps));
                tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);
              }
            }
            var sliderDimensions = {};
            refreshSliderDimensions();
            function refreshSliderDimensions() {
              sliderDimensions = trackContainer[0].getBoundingClientRect();
            }
            function getSliderDimensions() {
              throttledRefreshDimensions();
              return sliderDimensions;
            }
            function keydownListener(ev) {
              if (element[0].hasAttribute('disabled')) {
                return;
              }
              var changeAmount;
              if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {
                changeAmount = -step;
              } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {
                changeAmount = step;
              }
              if (changeAmount) {
                if (ev.metaKey || ev.ctrlKey || ev.altKey) {
                  changeAmount *= 4;
                }
                ev.preventDefault();
                ev.stopPropagation();
                scope.$evalAsync(function() {
                  setModelValue(ngModelCtrl.$viewValue + changeAmount);
                });
              }
            }
            function setModelValue(value) {
              ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
            }
            function ngModelRender() {
              if (isNaN(ngModelCtrl.$viewValue)) {
                ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;
              }
              var percent = (ngModelCtrl.$viewValue - min) / (max - min);
              scope.modelValue = ngModelCtrl.$viewValue;
              element.attr('aria-valuenow', ngModelCtrl.$viewValue);
              setSliderPercent(percent);
              thumbText.text(ngModelCtrl.$viewValue);
            }
            function minMaxValidator(value) {
              if (angular.isNumber(value)) {
                return Math.max(min, Math.min(max, value));
              }
            }
            function stepValidator(value) {
              if (angular.isNumber(value)) {
                var formattedValue = (Math.round((value - min) / step) * step + min);
                return (Math.round(formattedValue * 1000) / 1000);
              }
            }
            function setSliderPercent(percent) {
              var percentStr = (percent * 100) + '%';
              activeTrack.css('width', percentStr);
              thumbContainer.css('left', percentStr);
              element.toggleClass('md-min', percent === 0);
              element.toggleClass('md-max', percent === 1);
            }
            var isDragging = false;
            var isDiscrete = angular.isDefined(attr.mdDiscrete);
            function onPressDown(ev) {
              if (isDisabledGetter())
                return;
              element.addClass('md-active');
              element[0].focus();
              refreshSliderDimensions();
              var exactVal = percentToValue(positionToPercent(ev.pointer.x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              scope.$apply(function() {
                setModelValue(closestVal);
                setSliderPercent(valueToPercent(closestVal));
              });
            }
            function onPressUp(ev) {
              if (isDisabledGetter())
                return;
              element.removeClass('md-dragging md-active');
              var exactVal = percentToValue(positionToPercent(ev.pointer.x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              scope.$apply(function() {
                setModelValue(closestVal);
                ngModelRender();
              });
            }
            function onDragStart(ev) {
              if (isDisabledGetter())
                return;
              isDragging = true;
              ev.stopPropagation();
              element.addClass('md-dragging');
              setSliderFromEvent(ev);
            }
            function onDrag(ev) {
              if (!isDragging)
                return;
              ev.stopPropagation();
              setSliderFromEvent(ev);
            }
            function onDragEnd(ev) {
              if (!isDragging)
                return;
              ev.stopPropagation();
              isDragging = false;
            }
            function setSliderFromEvent(ev) {
              if (isDiscrete)
                adjustThumbPosition(ev.pointer.x);
              else
                doSlide(ev.pointer.x);
            }
            function doSlide(x) {
              scope.$evalAsync(function() {
                setModelValue(percentToValue(positionToPercent(x)));
              });
            }
            function adjustThumbPosition(x) {
              var exactVal = percentToValue(positionToPercent(x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              setSliderPercent(positionToPercent(x));
              thumbText.text(closestVal);
            }
            function positionToPercent(x) {
              return Math.max(0, Math.min(1, (x - sliderDimensions.left) / (sliderDimensions.width)));
            }
            function percentToValue(percent) {
              return (min + percent * (max - min));
            }
            function valueToPercent(val) {
              return (val - min) / (max - min);
            }
          }
        }
        SliderDirective.$inject = ["$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.sticky', ['material.core', 'material.components.content']).factory('$mdSticky', MdSticky);
        function MdSticky($document, $mdConstant, $$rAF, $mdUtil) {
          var browserStickySupport = checkStickySupport();
          return function registerStickyElement(scope, element, stickyClone) {
            var contentCtrl = element.controller('mdContent');
            if (!contentCtrl)
              return;
            if (browserStickySupport) {
              element.css({
                position: browserStickySupport,
                top: 0,
                'z-index': 2
              });
            } else {
              var $$sticky = contentCtrl.$element.data('$$sticky');
              if (!$$sticky) {
                $$sticky = setupSticky(contentCtrl);
                contentCtrl.$element.data('$$sticky', $$sticky);
              }
              var deregister = $$sticky.add(element, stickyClone || element.clone());
              scope.$on('$destroy', deregister);
            }
          };
          function setupSticky(contentCtrl) {
            var contentEl = contentCtrl.$element;
            var debouncedRefreshElements = $$rAF.throttle(refreshElements);
            setupAugmentedScrollEvents(contentEl);
            contentEl.on('$scrollstart', debouncedRefreshElements);
            contentEl.on('$scroll', onScroll);
            var self;
            return self = {
              prev: null,
              current: null,
              next: null,
              items: [],
              add: add,
              refreshElements: refreshElements
            };
            function add(element, stickyClone) {
              stickyClone.addClass('md-sticky-clone');
              var item = {
                element: element,
                clone: stickyClone
              };
              self.items.push(item);
              $mdUtil.nextTick(function() {
                contentEl.prepend(item.clone);
              });
              debouncedRefreshElements();
              return function remove() {
                self.items.forEach(function(item, index) {
                  if (item.element[0] === element[0]) {
                    self.items.splice(index, 1);
                    item.clone.remove();
                  }
                });
                debouncedRefreshElements();
              };
            }
            function refreshElements() {
              self.items.forEach(refreshPosition);
              self.items = self.items.sort(function(a, b) {
                return a.top < b.top ? -1 : 1;
              });
              var item;
              var currentScrollTop = contentEl.prop('scrollTop');
              for (var i = self.items.length - 1; i >= 0; i--) {
                if (currentScrollTop > self.items[i].top) {
                  item = self.items[i];
                  break;
                }
              }
              setCurrentItem(item);
            }
            function refreshPosition(item) {
              var current = item.element[0];
              item.top = 0;
              item.left = 0;
              while (current && current !== contentEl[0]) {
                item.top += current.offsetTop;
                item.left += current.offsetLeft;
                current = current.offsetParent;
              }
              item.height = item.element.prop('offsetHeight');
              item.clone.css('margin-left', item.left + 'px');
              if ($mdUtil.floatingScrollbars()) {
                item.clone.css('margin-right', '0');
              }
            }
            function onScroll() {
              var scrollTop = contentEl.prop('scrollTop');
              var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
              onScroll.prevScrollTop = scrollTop;
              if (scrollTop === 0) {
                setCurrentItem(null);
                return;
              }
              if (isScrollingDown) {
                if (self.next && self.next.top <= scrollTop) {
                  setCurrentItem(self.next);
                  return;
                }
                if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {
                  translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
                  return;
                }
              }
              if (!isScrollingDown) {
                if (self.current && self.prev && scrollTop < self.current.top) {
                  setCurrentItem(self.prev);
                  return;
                }
                if (self.next && self.current && (scrollTop >= (self.next.top - self.current.height))) {
                  translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
                  return;
                }
              }
              if (self.current) {
                translate(self.current, scrollTop);
              }
            }
            function setCurrentItem(item) {
              if (self.current === item)
                return;
              if (self.current) {
                translate(self.current, null);
                setStickyState(self.current, null);
              }
              if (item) {
                setStickyState(item, 'active');
              }
              self.current = item;
              var index = self.items.indexOf(item);
              self.next = self.items[index + 1];
              self.prev = self.items[index - 1];
              setStickyState(self.next, 'next');
              setStickyState(self.prev, 'prev');
            }
            function setStickyState(item, state) {
              if (!item || item.state === state)
                return;
              if (item.state) {
                item.clone.attr('sticky-prev-state', item.state);
                item.element.attr('sticky-prev-state', item.state);
              }
              item.clone.attr('sticky-state', state);
              item.element.attr('sticky-state', state);
              item.state = state;
            }
            function translate(item, amount) {
              if (!item)
                return;
              if (amount === null || amount === undefined) {
                if (item.translateY) {
                  item.translateY = null;
                  item.clone.css($mdConstant.CSS.TRANSFORM, '');
                }
              } else {
                item.translateY = amount;
                item.clone.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + item.left + 'px,' + amount + 'px,0)');
              }
            }
          }
          function checkStickySupport($el) {
            var stickyProp;
            var testEl = angular.element('<div>');
            $document[0].body.appendChild(testEl[0]);
            var stickyProps = ['sticky', '-webkit-sticky'];
            for (var i = 0; i < stickyProps.length; ++i) {
              testEl.css({
                position: stickyProps[i],
                top: 0,
                'z-index': 2
              });
              if (testEl.css('position') == stickyProps[i]) {
                stickyProp = stickyProps[i];
                break;
              }
            }
            testEl.remove();
            return stickyProp;
          }
          function setupAugmentedScrollEvents(element) {
            var SCROLL_END_DELAY = 200;
            var isScrolling;
            var lastScrollTime;
            element.on('scroll touchmove', function() {
              if (!isScrolling) {
                isScrolling = true;
                $$rAF.throttle(loopScrollEvent);
                element.triggerHandler('$scrollstart');
              }
              element.triggerHandler('$scroll');
              lastScrollTime = +$mdUtil.now();
            });
            function loopScrollEvent() {
              if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
                isScrolling = false;
                element.triggerHandler('$scrollend');
              } else {
                element.triggerHandler('$scroll');
                $$rAF.throttle(loopScrollEvent);
              }
            }
          }
        }
        MdSticky.$inject = ["$document", "$mdConstant", "$$rAF", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.subheader', ['material.core', 'material.components.sticky']).directive('mdSubheader', MdSubheaderDirective);
        function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil) {
          return {
            restrict: 'E',
            replace: true,
            transclude: true,
            template: ('<div class="md-subheader">' + '  <div class="md-subheader-inner">' + '    <span class="md-subheader-content"></span>' + '  </div>' + '</div>'),
            link: function postLink(scope, element, attr, controllers, transclude) {
              $mdTheming(element);
              var outerHTML = element[0].outerHTML;
              function getContent(el) {
                return angular.element(el[0].querySelector('.md-subheader-content'));
              }
              transclude(scope, function(clone) {
                getContent(element).append(clone);
              });
              if (!element.hasClass('md-no-sticky')) {
                transclude(scope, function(clone) {
                  var wrapperHtml = '<div class="md-subheader-wrapper">' + outerHTML + '</div>';
                  var stickyClone = $compile(wrapperHtml)(scope);
                  $mdSticky(scope, element, stickyClone);
                  $mdUtil.nextTick(function() {
                    getContent(stickyClone).append(clone);
                  });
                });
              }
            }
          };
        }
        MdSubheaderDirective.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.swipe', ['material.core']).directive('mdSwipeLeft', getDirective('SwipeLeft')).directive('mdSwipeRight', getDirective('SwipeRight')).directive('mdSwipeUp', getDirective('SwipeUp')).directive('mdSwipeDown', getDirective('SwipeDown'));
        function getDirective(name) {
          var directiveName = 'md' + name;
          var eventName = '$md.' + name.toLowerCase();
          DirectiveFactory.$inject = ["$parse"];
          return DirectiveFactory;
          function DirectiveFactory($parse) {
            return {
              restrict: 'A',
              link: postLink
            };
            function postLink(scope, element, attr) {
              var fn = $parse(attr[directiveName]);
              element.on(eventName, function(ev) {
                scope.$apply(function() {
                  fn(scope, {$event: ev});
                });
              });
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.switch', ['material.core', 'material.components.checkbox']).directive('mdSwitch', MdSwitch);
        function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture) {
          var checkboxDirective = mdCheckboxDirective[0];
          return {
            restrict: 'E',
            priority: 210,
            transclude: true,
            template: '<div class="md-container">' + '<div class="md-bar"></div>' + '<div class="md-thumb-container">' + '<div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div>' + '</div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            require: '?ngModel',
            compile: mdSwitchCompile
          };
          function mdSwitchCompile(element, attr) {
            var checkboxLink = checkboxDirective.compile(element, attr);
            element.addClass('md-dragging');
            return function(scope, element, attr, ngModel) {
              ngModel = ngModel || $mdUtil.fakeNgModel();
              var disabledGetter = null;
              if (attr.disabled != null) {
                disabledGetter = function() {
                  return true;
                };
              } else if (attr.ngDisabled) {
                disabledGetter = $parse(attr.ngDisabled);
              }
              var thumbContainer = angular.element(element[0].querySelector('.md-thumb-container'));
              var switchContainer = angular.element(element[0].querySelector('.md-container'));
              $$rAF(function() {
                element.removeClass('md-dragging');
              });
              checkboxLink(scope, element, attr, ngModel);
              if (disabledGetter) {
                scope.$watch(disabledGetter, function(isDisabled) {
                  element.attr('tabindex', isDisabled ? -1 : 0);
                });
              }
              $mdGesture.register(switchContainer, 'drag');
              switchContainer.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
              var drag;
              function onDragStart(ev) {
                if (disabledGetter && disabledGetter(scope))
                  return;
                ev.stopPropagation();
                element.addClass('md-dragging');
                drag = {width: thumbContainer.prop('offsetWidth')};
                element.removeClass('transition');
              }
              function onDrag(ev) {
                if (!drag)
                  return;
                ev.stopPropagation();
                ev.srcEvent && ev.srcEvent.preventDefault();
                var percent = ev.pointer.distanceX / drag.width;
                var translate = ngModel.$viewValue ? 1 + percent : percent;
                translate = Math.max(0, Math.min(1, translate));
                thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + (100 * translate) + '%,0,0)');
                drag.translate = translate;
              }
              function onDragEnd(ev) {
                if (!drag)
                  return;
                ev.stopPropagation();
                element.removeClass('md-dragging');
                thumbContainer.css($mdConstant.CSS.TRANSFORM, '');
                var isChanged = ngModel.$viewValue ? drag.translate > 0.5 : drag.translate < 0.5;
                if (isChanged) {
                  applyModelValue(!ngModel.$viewValue);
                }
                drag = null;
              }
              function applyModelValue(newValue) {
                scope.$apply(function() {
                  ngModel.$setViewValue(newValue);
                  ngModel.$render();
                });
              }
            };
          }
        }
        MdSwitch.$inject = ["mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs', ['material.core', 'material.components.icon']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.toast', ['material.core', 'material.components.button']).directive('mdToast', MdToastDirective).provider('$mdToast', MdToastProvider);
        function MdToastDirective($mdToast) {
          return {
            restrict: 'E',
            link: function postLink(scope, element, attr) {
              scope.$on('$destroy', function() {
                $mdToast.destroy();
              });
            }
          };
        }
        MdToastDirective.$inject = ["$mdToast"];
        function MdToastProvider($$interimElementProvider) {
          var ACTION_RESOLVE = 'ok';
          var activeToastContent;
          var $mdToast = $$interimElementProvider('$mdToast').setDefaults({
            methods: ['position', 'hideDelay', 'capsule', 'parent'],
            options: toastDefaultOptions
          }).addPreset('simple', {
            argOption: 'textContent',
            methods: ['textContent', 'content', 'action', 'highlightAction', 'theme', 'parent'],
            options: ["$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
              var opts = {
                template: '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">' + '  <div class="md-toast-content">' + '    <span flex role="alert" aria-relevant="all" aria-atomic="true">' + '      {{ toast.content }}' + '    </span>' + '    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ng-class="{\'md-highlight\': toast.highlightAction}">' + '      {{ toast.action }}' + '    </md-button>' + '  </div>' + '</md-toast>',
                controller: ["$scope", function mdToastCtrl($scope) {
                  var self = this;
                  $scope.$watch(function() {
                    return activeToastContent;
                  }, function() {
                    self.content = activeToastContent;
                  });
                  this.resolve = function() {
                    $mdToast.hide(ACTION_RESOLVE);
                  };
                }],
                theme: $mdTheming.defaultTheme(),
                controllerAs: 'toast',
                bindToController: true
              };
              return opts;
            }]
          }).addMethod('updateTextContent', updateTextContent).addMethod('updateContent', updateTextContent);
          function updateTextContent(newContent) {
            activeToastContent = newContent;
          }
          toastDefaultOptions.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia"];
          return $mdToast;
          function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia) {
            var SWIPE_EVENTS = '$md.swipeleft $md.swiperight $md.swipeup $md.swipedown';
            return {
              onShow: onShow,
              onRemove: onRemove,
              position: 'bottom left',
              themable: true,
              hideDelay: 3000,
              autoWrap: true,
              transformTemplate: function(template, options) {
                var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template);
                if (shouldAddWrapper) {
                  var parsedTemplate = angular.element(template);
                  var wrappedContent = '<div class="md-toast-content">' + parsedTemplate.html() + '</div>';
                  parsedTemplate.empty().append(wrappedContent);
                  return parsedTemplate[0].outerHTML;
                }
                return shouldAddWrapper ? '<div class="md-toast-content">' + template + '</div>' : template || '';
              }
            };
            function onShow(scope, element, options) {
              activeToastContent = options.textContent || options.content;
              var isSmScreen = !$mdMedia('gt-sm');
              element = $mdUtil.extractElementByName(element, 'md-toast', true);
              options.onSwipe = function(ev, gesture) {
                var swipe = ev.type.replace('$md.', '');
                var direction = swipe.replace('swipe', '');
                if ((direction === 'down' && options.position.indexOf('top') != -1 && !isSmScreen) || (direction === 'up' && (options.position.indexOf('bottom') != -1 || isSmScreen))) {
                  return;
                }
                if ((direction === 'left' || direction === 'right') && isSmScreen) {
                  return;
                }
                element.addClass('md-' + swipe);
                $mdUtil.nextTick($mdToast.cancel);
              };
              options.openClass = toastOpenClass(options.position);
              options.parent.addClass(options.openClass);
              if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
                options.parent.css('position', 'relative');
              }
              element.on(SWIPE_EVENTS, options.onSwipe);
              element.addClass(isSmScreen ? 'md-bottom' : options.position.split(' ').map(function(pos) {
                return 'md-' + pos;
              }).join(' '));
              if (options.parent)
                options.parent.addClass('md-toast-animating');
              return $animate.enter(element, options.parent).then(function() {
                if (options.parent)
                  options.parent.removeClass('md-toast-animating');
              });
            }
            function onRemove(scope, element, options) {
              element.off(SWIPE_EVENTS, options.onSwipe);
              if (options.parent)
                options.parent.addClass('md-toast-animating');
              if (options.openClass)
                options.parent.removeClass(options.openClass);
              return ((options.$destroy == true) ? element.remove() : $animate.leave(element)).then(function() {
                if (options.parent)
                  options.parent.removeClass('md-toast-animating');
                if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
                  options.parent.css('position', '');
                }
              });
            }
            function toastOpenClass(position) {
              if (!$mdMedia('gt-sm')) {
                return 'md-toast-open-bottom';
              }
              return 'md-toast-open-' + (position.indexOf('top') > -1 ? 'top' : 'bottom');
            }
          }
        }
        MdToastProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.toolbar', ['material.core', 'material.components.content']).directive('mdToolbar', mdToolbarDirective);
        function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate) {
          var translateY = angular.bind(null, $mdUtil.supplant, 'translate3d(0,{0}px,0)');
          return {
            template: '',
            restrict: 'E',
            link: function(scope, element, attr) {
              $mdTheming(element);
              if (angular.isDefined(attr.mdScrollShrink)) {
                setupScrollShrink();
              }
              function setupScrollShrink() {
                var toolbarHeight;
                var contentElement;
                var disableScrollShrink = angular.noop;
                var y = 0;
                var prevScrollTop = 0;
                var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;
                var debouncedContentScroll = $$rAF.throttle(onContentScroll);
                var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000);
                scope.$on('$mdContentLoaded', onMdContentLoad);
                attr.$observe('mdScrollShrink', onChangeScrollShrink);
                if (attr.ngShow) {
                  scope.$watch(attr.ngShow, updateToolbarHeight);
                }
                if (attr.ngHide) {
                  scope.$watch(attr.ngHide, updateToolbarHeight);
                }
                scope.$on('$destroy', disableScrollShrink);
                function onChangeScrollShrink(shrinkWithScroll) {
                  var closestContent = element.parent().find('md-content');
                  if (!contentElement && closestContent.length) {
                    onMdContentLoad(null, closestContent);
                  }
                  shrinkWithScroll = scope.$eval(shrinkWithScroll);
                  if (shrinkWithScroll === false) {
                    disableScrollShrink();
                  } else {
                    disableScrollShrink = enableScrollShrink();
                  }
                }
                function onMdContentLoad($event, newContentEl) {
                  if (newContentEl && element.parent()[0] === newContentEl.parent()[0]) {
                    if (contentElement) {
                      contentElement.off('scroll', debouncedContentScroll);
                    }
                    contentElement = newContentEl;
                    disableScrollShrink = enableScrollShrink();
                  }
                }
                function onContentScroll(e) {
                  var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                  debouncedUpdateHeight();
                  y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
                  element.css($mdConstant.CSS.TRANSFORM, translateY([-y * shrinkSpeedFactor]));
                  contentElement.css($mdConstant.CSS.TRANSFORM, translateY([(toolbarHeight - y) * shrinkSpeedFactor]));
                  prevScrollTop = scrollTop;
                  $mdUtil.nextTick(function() {
                    var hasWhiteFrame = element.hasClass('md-whiteframe-z1');
                    if (hasWhiteFrame && !y) {
                      $animate.removeClass(element, 'md-whiteframe-z1');
                    } else if (!hasWhiteFrame && y) {
                      $animate.addClass(element, 'md-whiteframe-z1');
                    }
                  });
                }
                function enableScrollShrink() {
                  if (!contentElement)
                    return angular.noop;
                  contentElement.on('scroll', debouncedContentScroll);
                  contentElement.attr('scroll-shrink', 'true');
                  $$rAF(updateToolbarHeight);
                  return function disableScrollShrink() {
                    contentElement.off('scroll', debouncedContentScroll);
                    contentElement.attr('scroll-shrink', 'false');
                    $$rAF(updateToolbarHeight);
                  };
                }
                function updateToolbarHeight() {
                  toolbarHeight = element.prop('offsetHeight');
                  var margin = (-toolbarHeight * shrinkSpeedFactor) + 'px';
                  contentElement.css({
                    "margin-top": margin,
                    "margin-bottom": margin
                  });
                  onContentScroll();
                }
              }
            }
          };
        }
        mdToolbarDirective.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tooltip', ['material.core']).directive('mdTooltip', MdTooltipDirective);
        function MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement, $animate, $q) {
          var TOOLTIP_SHOW_DELAY = 0;
          var TOOLTIP_WINDOW_EDGE_SPACE = 8;
          return {
            restrict: 'E',
            transclude: true,
            priority: 210,
            template: '<div class="md-content" ng-transclude></div>',
            scope: {
              delay: '=?mdDelay',
              visible: '=?mdVisible',
              autohide: '=?mdAutohide',
              direction: '@?mdDirection'
            },
            link: postLink
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var parent = $mdUtil.getParentWithPointerEvents(element),
                content = angular.element(element[0].getElementsByClassName('md-content')[0]),
                tooltipParent = angular.element(document.body),
                debouncedOnResize = $$rAF.throttle(function() {
                  updatePosition();
                });
            if ($animate.pin)
              $animate.pin(element, parent);
            setDefaults();
            manipulateElement();
            bindEvents();
            updateContentOrigin();
            configureWatchers();
            addAriaLabel();
            function setDefaults() {
              if (!angular.isDefined(attr.mdDelay))
                scope.delay = TOOLTIP_SHOW_DELAY;
            }
            function updateContentOrigin() {
              var origin = 'center top';
              switch (scope.direction) {
                case 'left':
                  origin = 'right center';
                  break;
                case 'right':
                  origin = 'left center';
                  break;
                case 'top':
                  origin = 'center bottom';
                  break;
                case 'bottom':
                  origin = 'center top';
                  break;
              }
              content.css('transform-origin', origin);
            }
            function configureWatchers() {
              scope.$on('$destroy', function() {
                scope.visible = false;
                element.remove();
                angular.element($window).off('resize', debouncedOnResize);
              });
              scope.$watch('visible', function(isVisible) {
                if (isVisible)
                  showTooltip();
                else
                  hideTooltip();
              });
              scope.$watch('direction', updatePosition);
            }
            function addAriaLabel() {
              if (!parent.attr('aria-label') && !parent.text().trim()) {
                parent.attr('aria-label', element.text().trim());
              }
            }
            function manipulateElement() {
              element.detach();
              element.attr('role', 'tooltip');
            }
            function bindEvents() {
              var mouseActive = false;
              var ngWindow = angular.element($window);
              if (parent[0] && 'MutationObserver' in $window) {
                var attributeObserver = new MutationObserver(function(mutations) {
                  mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'disabled' && parent[0].disabled) {
                      setVisible(false);
                      scope.$digest();
                    }
                  });
                });
                attributeObserver.observe(parent[0], {attributes: true});
              }
              var windowBlurHandler = function() {
                elementFocusedOnWindowBlur = document.activeElement === parent[0];
              };
              var elementFocusedOnWindowBlur = false;
              function windowScrollHandler() {
                setVisible(false);
              }
              ngWindow.on('blur', windowBlurHandler);
              ngWindow.on('resize', debouncedOnResize);
              document.addEventListener('scroll', windowScrollHandler, true);
              scope.$on('$destroy', function() {
                ngWindow.off('blur', windowBlurHandler);
                ngWindow.off('resize', debouncedOnResize);
                document.removeEventListener('scroll', windowScrollHandler, true);
                attributeObserver && attributeObserver.disconnect();
              });
              var enterHandler = function(e) {
                if (e.type === 'focus' && elementFocusedOnWindowBlur) {
                  elementFocusedOnWindowBlur = false;
                  return;
                }
                parent.on('blur mouseleave touchend touchcancel', leaveHandler);
                setVisible(true);
              };
              var leaveHandler = function() {
                var autohide = scope.hasOwnProperty('autohide') ? scope.autohide : attr.hasOwnProperty('mdAutohide');
                if (autohide || mouseActive || ($document[0].activeElement !== parent[0])) {
                  parent.off('blur mouseleave touchend touchcancel', leaveHandler);
                  parent.triggerHandler("blur");
                  setVisible(false);
                }
                mouseActive = false;
              };
              parent.on('mousedown', function() {
                mouseActive = true;
              });
              parent.on('focus mouseenter touchstart', enterHandler);
            }
            function setVisible(value) {
              setVisible.value = !!value;
              if (!setVisible.queued) {
                if (value) {
                  setVisible.queued = true;
                  $timeout(function() {
                    scope.visible = setVisible.value;
                    setVisible.queued = false;
                  }, scope.delay);
                } else {
                  $mdUtil.nextTick(function() {
                    scope.visible = false;
                  });
                }
              }
            }
            function showTooltip() {
              tooltipParent.append(element);
              if ($mdUtil.hasComputedStyle(element, 'display', 'none')) {
                scope.visible = false;
                element.detach();
                return;
              }
              updatePosition();
              angular.forEach([element, content], function(element) {
                $animate.addClass(element, 'md-show');
              });
            }
            function hideTooltip() {
              var promises = [];
              angular.forEach([element, content], function(it) {
                if (it.parent() && it.hasClass('md-show')) {
                  promises.push($animate.removeClass(it, 'md-show'));
                }
              });
              $q.all(promises).then(function() {
                if (!scope.visible)
                  element.detach();
              });
            }
            function updatePosition() {
              if (!scope.visible)
                return;
              updateContentOrigin();
              positionTooltip();
            }
            function positionTooltip() {
              var tipRect = $mdUtil.offsetRect(element, tooltipParent);
              var parentRect = $mdUtil.offsetRect(parent, tooltipParent);
              var newPosition = getPosition(scope.direction);
              var offsetParent = element.prop('offsetParent');
              if (scope.direction) {
                newPosition = fitInParent(newPosition);
              } else if (offsetParent && newPosition.top > offsetParent.scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE) {
                newPosition = fitInParent(getPosition('top'));
              }
              element.css({
                left: newPosition.left + 'px',
                top: newPosition.top + 'px'
              });
              function fitInParent(pos) {
                var newPosition = {
                  left: pos.left,
                  top: pos.top
                };
                newPosition.left = Math.min(newPosition.left, tooltipParent.prop('scrollWidth') - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.left = Math.max(newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.top = Math.min(newPosition.top, tooltipParent.prop('scrollHeight') - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.top = Math.max(newPosition.top, TOOLTIP_WINDOW_EDGE_SPACE);
                return newPosition;
              }
              function getPosition(dir) {
                return dir === 'left' ? {
                  left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,
                  top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                } : dir === 'right' ? {
                  left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,
                  top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                } : dir === 'top' ? {
                  left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                  top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE
                } : {
                  left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                  top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE
                };
              }
            }
          }
        }
        MdTooltipDirective.$inject = ["$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.virtualRepeat', ['material.core', 'material.components.showHide']).directive('mdVirtualRepeatContainer', VirtualRepeatContainerDirective).directive('mdVirtualRepeat', VirtualRepeatDirective);
        function VirtualRepeatContainerDirective() {
          return {
            controller: VirtualRepeatContainerController,
            template: virtualRepeatContainerTemplate,
            compile: function virtualRepeatContainerCompile($element, $attrs) {
              $element.addClass('md-virtual-repeat-container').addClass($attrs.hasOwnProperty('mdOrientHorizontal') ? 'md-orient-horizontal' : 'md-orient-vertical');
            }
          };
        }
        function virtualRepeatContainerTemplate($element) {
          return '<div class="md-virtual-repeat-scroller">' + '<div class="md-virtual-repeat-sizer"></div>' + '<div class="md-virtual-repeat-offsetter">' + $element[0].innerHTML + '</div></div>';
        }
        var MAX_ELEMENT_SIZE = 1533917;
        var NUM_EXTRA = 3;
        function VirtualRepeatContainerController($$rAF, $mdUtil, $parse, $rootScope, $window, $scope, $element, $attrs) {
          this.$rootScope = $rootScope;
          this.$scope = $scope;
          this.$element = $element;
          this.$attrs = $attrs;
          this.size = 0;
          this.scrollSize = 0;
          this.scrollOffset = 0;
          this.horizontal = this.$attrs.hasOwnProperty('mdOrientHorizontal');
          this.repeater = null;
          this.autoShrink = this.$attrs.hasOwnProperty('mdAutoShrink');
          this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
          this.originalSize = null;
          this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
          this.oldElementSize = null;
          if (this.$attrs.mdTopIndex) {
            this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
            this.topIndex = this.bindTopIndex(this.$scope);
            if (!angular.isDefined(this.topIndex)) {
              this.topIndex = 0;
              this.bindTopIndex.assign(this.$scope, 0);
            }
            this.$scope.$watch(this.bindTopIndex, angular.bind(this, function(newIndex) {
              if (newIndex !== this.topIndex) {
                this.scrollToIndex(newIndex);
              }
            }));
          } else {
            this.topIndex = 0;
          }
          this.scroller = $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0];
          this.sizer = this.scroller.getElementsByClassName('md-virtual-repeat-sizer')[0];
          this.offsetter = this.scroller.getElementsByClassName('md-virtual-repeat-offsetter')[0];
          var boundUpdateSize = angular.bind(this, this.updateSize);
          $$rAF(angular.bind(this, function() {
            boundUpdateSize();
            var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, false);
            var jWindow = angular.element($window);
            if (!this.size) {
              debouncedUpdateSize();
            }
            jWindow.on('resize', debouncedUpdateSize);
            $scope.$on('$destroy', function() {
              jWindow.off('resize', debouncedUpdateSize);
            });
            $scope.$emit('$md-resize-enable');
            $scope.$on('$md-resize', boundUpdateSize);
          }));
        }
        VirtualRepeatContainerController.$inject = ["$$rAF", "$mdUtil", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"];
        VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
          this.repeater = repeaterCtrl;
          angular.element(this.scroller).on('scroll wheel touchmove touchend', angular.bind(this, this.handleScroll_));
        };
        VirtualRepeatContainerController.prototype.isHorizontal = function() {
          return this.horizontal;
        };
        VirtualRepeatContainerController.prototype.getSize = function() {
          return this.size;
        };
        VirtualRepeatContainerController.prototype.setSize_ = function(size) {
          var dimension = this.getDimensionName_();
          this.size = size;
          this.$element[0].style[dimension] = size + 'px';
        };
        VirtualRepeatContainerController.prototype.unsetSize_ = function() {
          this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
          this.oldElementSize = null;
        };
        VirtualRepeatContainerController.prototype.updateSize = function() {
          if (this.originalSize)
            return;
          this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
          this.handleScroll_();
          this.repeater && this.repeater.containerUpdated();
        };
        VirtualRepeatContainerController.prototype.getScrollSize = function() {
          return this.scrollSize;
        };
        VirtualRepeatContainerController.prototype.getDimensionName_ = function() {
          return this.isHorizontal() ? 'width' : 'height';
        };
        VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
          var dimension = this.getDimensionName_();
          var crossDimension = this.isHorizontal() ? 'height' : 'width';
          this.sizer.innerHTML = '';
          if (size < MAX_ELEMENT_SIZE) {
            this.sizer.style[dimension] = size + 'px';
          } else {
            this.sizer.style[dimension] = 'auto';
            this.sizer.style[crossDimension] = 'auto';
            var numChildren = Math.floor(size / MAX_ELEMENT_SIZE);
            var sizerChild = document.createElement('div');
            sizerChild.style[dimension] = MAX_ELEMENT_SIZE + 'px';
            sizerChild.style[crossDimension] = '1px';
            for (var i = 0; i < numChildren; i++) {
              this.sizer.appendChild(sizerChild.cloneNode(false));
            }
            sizerChild.style[dimension] = (size - (numChildren * MAX_ELEMENT_SIZE)) + 'px';
            this.sizer.appendChild(sizerChild);
          }
        };
        VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
          var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
          if (this.autoShrink && shrinkSize !== this.size) {
            if (this.oldElementSize === null) {
              this.oldElementSize = this.$element[0].style[this.getDimensionName_()];
            }
            var currentSize = this.originalSize || this.size;
            if (!currentSize || shrinkSize < currentSize) {
              if (!this.originalSize) {
                this.originalSize = this.size;
              }
              this.setSize_(shrinkSize);
            } else if (this.originalSize !== null) {
              this.unsetSize_();
              this.originalSize = null;
              this.updateSize();
            }
            this.repeater.containerUpdated();
          }
        };
        VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
          var size = itemsSize + this.offsetSize;
          if (this.scrollSize === size)
            return;
          this.sizeScroller_(size);
          this.autoShrink_(size);
          this.scrollSize = size;
        };
        VirtualRepeatContainerController.prototype.getScrollOffset = function() {
          return this.scrollOffset;
        };
        VirtualRepeatContainerController.prototype.scrollTo = function(position) {
          this.scroller[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = position;
          this.handleScroll_();
        };
        VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
          var itemSize = this.repeater.getItemSize();
          var itemsLength = this.repeater.itemsLength;
          if (index > itemsLength) {
            index = itemsLength - 1;
          }
          this.scrollTo(itemSize * index);
        };
        VirtualRepeatContainerController.prototype.resetScroll = function() {
          this.scrollTo(0);
        };
        VirtualRepeatContainerController.prototype.handleScroll_ = function() {
          var offset = this.isHorizontal() ? this.scroller.scrollLeft : this.scroller.scrollTop;
          if (offset === this.scrollOffset)
            return;
          var itemSize = this.repeater.getItemSize();
          if (!itemSize)
            return;
          var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA);
          var transform = this.isHorizontal() ? 'translateX(' : 'translateY(';
          transform += (numItems * itemSize) + 'px)';
          this.scrollOffset = offset;
          this.offsetter.style.webkitTransform = transform;
          this.offsetter.style.transform = transform;
          if (this.bindTopIndex) {
            var topIndex = Math.floor(offset / itemSize);
            if (topIndex !== this.topIndex && topIndex < this.repeater.itemsLength) {
              this.topIndex = topIndex;
              this.bindTopIndex.assign(this.$scope, topIndex);
              if (!this.$rootScope.$$phase)
                this.$scope.$digest();
            }
          }
          this.repeater.containerUpdated();
        };
        function VirtualRepeatDirective($parse) {
          return {
            controller: VirtualRepeatController,
            priority: 1000,
            require: ['mdVirtualRepeat', '^^mdVirtualRepeatContainer'],
            restrict: 'A',
            terminal: true,
            transclude: 'element',
            compile: function VirtualRepeatCompile($element, $attrs) {
              var expression = $attrs.mdVirtualRepeat;
              var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/);
              var repeatName = match[1];
              var repeatListExpression = $parse(match[2]);
              var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);
              return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude) {
                ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
              };
            }
          };
        }
        VirtualRepeatDirective.$inject = ["$parse"];
        function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF) {
          this.$scope = $scope;
          this.$element = $element;
          this.$attrs = $attrs;
          this.$browser = $browser;
          this.$document = $document;
          this.$rootScope = $rootScope;
          this.$$rAF = $$rAF;
          this.onDemand = $attrs.hasOwnProperty('mdOnDemand');
          this.browserCheckUrlChange = $browser.$$checkUrlChange;
          this.newStartIndex = 0;
          this.newEndIndex = 0;
          this.newVisibleEnd = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          this.itemSize = $scope.$eval($attrs.mdItemSize) || null;
          this.isFirstRender = true;
          this.isVirtualRepeatUpdating_ = false;
          this.itemsLength = 0;
          this.unwatchItemSize_ = angular.noop;
          this.blocks = {};
          this.pooledBlocks = [];
        }
        VirtualRepeatController.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF"];
        VirtualRepeatController.Block;
        VirtualRepeatController.prototype.link_ = function(container, transclude, repeatName, repeatListExpression, extraName) {
          this.container = container;
          this.transclude = transclude;
          this.repeatName = repeatName;
          this.rawRepeatListExpression = repeatListExpression;
          this.extraName = extraName;
          this.sized = false;
          this.repeatListExpression = angular.bind(this, this.repeatListExpression_);
          this.container.register(this);
        };
        VirtualRepeatController.prototype.readItemSize_ = function() {
          if (this.itemSize) {
            return;
          }
          this.items = this.repeatListExpression(this.$scope);
          this.parentNode = this.$element[0].parentNode;
          var block = this.getBlock_(0);
          if (!block.element[0].parentNode) {
            this.parentNode.appendChild(block.element[0]);
          }
          this.itemSize = block.element[0][this.container.isHorizontal() ? 'offsetWidth' : 'offsetHeight'] || null;
          this.blocks[0] = block;
          this.poolBlock_(0);
          if (this.itemSize) {
            this.containerUpdated();
          }
        };
        VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
          var repeatList = this.rawRepeatListExpression(scope);
          if (this.onDemand && repeatList) {
            var virtualList = new VirtualRepeatModelArrayLike(repeatList);
            virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
            return virtualList;
          } else {
            return repeatList;
          }
        };
        VirtualRepeatController.prototype.containerUpdated = function() {
          if (!this.itemSize) {
            this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items) {
              if (items && items.length) {
                this.$$rAF(angular.bind(this, this.readItemSize_));
              }
            }));
            if (!this.$rootScope.$$phase)
              this.$scope.$digest();
            return;
          } else if (!this.sized) {
            this.items = this.repeatListExpression(this.$scope);
          }
          if (!this.sized) {
            this.unwatchItemSize_();
            this.sized = true;
            this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items, oldItems) {
              if (!this.isVirtualRepeatUpdating_) {
                this.virtualRepeatUpdate_(items, oldItems);
              }
            }));
          }
          this.updateIndexes_();
          if (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) {
            if (this.items instanceof VirtualRepeatModelArrayLike) {
              this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
            }
            this.virtualRepeatUpdate_(this.items, this.items);
          }
        };
        VirtualRepeatController.prototype.getItemSize = function() {
          return this.itemSize;
        };
        VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
          this.isVirtualRepeatUpdating_ = true;
          var itemsLength = items && items.length || 0;
          var lengthChanged = false;
          if (this.items && itemsLength < this.items.length && this.container.getScrollOffset() !== 0) {
            this.items = items;
            this.container.resetScroll();
            return;
          }
          if (itemsLength !== this.itemsLength) {
            lengthChanged = true;
            this.itemsLength = itemsLength;
          }
          this.items = items;
          if (items !== oldItems || lengthChanged) {
            this.updateIndexes_();
          }
          this.parentNode = this.$element[0].parentNode;
          if (lengthChanged) {
            this.container.setScrollSize(itemsLength * this.itemSize);
          }
          if (this.isFirstRender) {
            this.isFirstRender = false;
            var startIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
            this.container.scrollToIndex(startIndex);
          }
          Object.keys(this.blocks).forEach(function(blockIndex) {
            var index = parseInt(blockIndex, 10);
            if (index < this.newStartIndex || index >= this.newEndIndex) {
              this.poolBlock_(index);
            }
          }, this);
          this.$browser.$$checkUrlChange = angular.noop;
          var i,
              block,
              newStartBlocks = [],
              newEndBlocks = [];
          for (i = this.newStartIndex; i < this.newEndIndex && this.blocks[i] == null; i++) {
            block = this.getBlock_(i);
            this.updateBlock_(block, i);
            newStartBlocks.push(block);
          }
          for (; this.blocks[i] != null; i++) {
            this.updateBlock_(this.blocks[i], i);
          }
          var maxIndex = i - 1;
          for (; i < this.newEndIndex; i++) {
            block = this.getBlock_(i);
            this.updateBlock_(block, i);
            newEndBlocks.push(block);
          }
          if (newStartBlocks.length) {
            this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling);
          }
          if (newEndBlocks.length) {
            this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
          }
          this.$browser.$$checkUrlChange = this.browserCheckUrlChange;
          this.startIndex = this.newStartIndex;
          this.endIndex = this.newEndIndex;
          this.isVirtualRepeatUpdating_ = false;
        };
        VirtualRepeatController.prototype.getBlock_ = function(index) {
          if (this.pooledBlocks.length) {
            return this.pooledBlocks.pop();
          }
          var block;
          this.transclude(angular.bind(this, function(clone, scope) {
            block = {
              element: clone,
              new: true,
              scope: scope
            };
            this.updateScope_(scope, index);
            this.parentNode.appendChild(clone[0]);
          }));
          return block;
        };
        VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
          this.blocks[index] = block;
          if (!block.new && (block.scope.$index === index && block.scope[this.repeatName] === this.items[index])) {
            return;
          }
          block.new = false;
          this.updateScope_(block.scope, index);
          if (!this.$rootScope.$$phase) {
            block.scope.$digest();
          }
        };
        VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
          scope.$index = index;
          scope[this.repeatName] = this.items && this.items[index];
          if (this.extraName)
            scope[this.extraName(this.$scope)] = this.items[index];
        };
        VirtualRepeatController.prototype.poolBlock_ = function(index) {
          this.pooledBlocks.push(this.blocks[index]);
          this.parentNode.removeChild(this.blocks[index].element[0]);
          delete this.blocks[index];
        };
        VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
          var fragment = this.$document[0].createDocumentFragment();
          blocks.forEach(function(block) {
            fragment.appendChild(block.element[0]);
          });
          return fragment;
        };
        VirtualRepeatController.prototype.updateIndexes_ = function() {
          var itemsLength = this.items ? this.items.length : 0;
          var containerLength = Math.ceil(this.container.getSize() / this.itemSize);
          this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize)));
          this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
          this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
          this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);
        };
        function VirtualRepeatModelArrayLike(model) {
          if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) {
            throw Error('When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement ' + 'functions getItemAtIndex() and getLength() ');
          }
          this.model = model;
        }
        VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
          for (var i = start; i < end; i++) {
            if (!this.hasOwnProperty(i)) {
              this[i] = this.model.getItemAtIndex(i);
            }
          }
          this.length = this.model.getLength();
        };
        function abstractMethod() {
          throw Error('Non-overridden abstract method called.');
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.whiteframe', []);
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').controller('MdAutocompleteCtrl', MdAutocompleteCtrl);
        var ITEM_HEIGHT = 41,
            MAX_HEIGHT = 5.5 * ITEM_HEIGHT,
            MENU_PADDING = 8,
            INPUT_PADDING = 2;
        function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q) {
          var ctrl = this,
              itemParts = $scope.itemsExpr.split(/ in /i),
              itemExpr = itemParts[1],
              elements = null,
              cache = {},
              noBlur = false,
              selectedItemWatchers = [],
              hasFocus = false,
              lastCount = 0;
          defineProperty('hidden', handleHiddenChange, true);
          ctrl.scope = $scope;
          ctrl.parent = $scope.$parent;
          ctrl.itemName = itemParts[0];
          ctrl.matches = [];
          ctrl.loading = false;
          ctrl.hidden = true;
          ctrl.index = null;
          ctrl.messages = [];
          ctrl.id = $mdUtil.nextUid();
          ctrl.isDisabled = null;
          ctrl.isRequired = null;
          ctrl.hasNotFound = false;
          ctrl.keydown = keydown;
          ctrl.blur = blur;
          ctrl.focus = focus;
          ctrl.clear = clearValue;
          ctrl.select = select;
          ctrl.listEnter = onListEnter;
          ctrl.listLeave = onListLeave;
          ctrl.mouseUp = onMouseup;
          ctrl.getCurrentDisplayValue = getCurrentDisplayValue;
          ctrl.registerSelectedItemWatcher = registerSelectedItemWatcher;
          ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
          ctrl.notFoundVisible = notFoundVisible;
          ctrl.loadingIsVisible = loadingIsVisible;
          return init();
          function init() {
            $mdUtil.initOptionalProperties($scope, $attrs, {
              searchText: null,
              selectedItem: null
            });
            $mdTheming($element);
            configureWatchers();
            $mdUtil.nextTick(function() {
              gatherElements();
              moveDropdown();
              focusElement();
              $element.on('focus', focusElement);
            });
          }
          function positionDropdown() {
            if (!elements)
              return $mdUtil.nextTick(positionDropdown, false, $scope);
            var hrect = elements.wrap.getBoundingClientRect(),
                vrect = elements.snap.getBoundingClientRect(),
                root = elements.root.getBoundingClientRect(),
                top = vrect.bottom - root.top,
                bot = root.bottom - vrect.top,
                left = hrect.left - root.left,
                width = hrect.width,
                offset = getVerticalOffset(),
                styles;
            if ($attrs.mdFloatingLabel) {
              left += INPUT_PADDING;
              width -= INPUT_PADDING * 2;
            }
            styles = {
              left: left + 'px',
              minWidth: width + 'px',
              maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'
            };
            if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {
              styles.top = 'auto';
              styles.bottom = bot + 'px';
              styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + 'px';
            } else {
              styles.top = (top - offset) + 'px';
              styles.bottom = 'auto';
              styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom + $mdUtil.scrollTop() - hrect.bottom - MENU_PADDING) + 'px';
            }
            elements.$.scrollContainer.css(styles);
            $mdUtil.nextTick(correctHorizontalAlignment, false);
            function getVerticalOffset() {
              var offset = 0;
              var inputContainer = $element.find('md-input-container');
              if (inputContainer.length) {
                var input = inputContainer.find('input');
                offset = inputContainer.prop('offsetHeight');
                offset -= input.prop('offsetTop');
                offset -= input.prop('offsetHeight');
                offset += inputContainer.prop('offsetTop');
              }
              return offset;
            }
            function correctHorizontalAlignment() {
              var dropdown = elements.scrollContainer.getBoundingClientRect(),
                  styles = {};
              if (dropdown.right > root.right - MENU_PADDING) {
                styles.left = (hrect.right - dropdown.width) + 'px';
              }
              elements.$.scrollContainer.css(styles);
            }
          }
          function moveDropdown() {
            if (!elements.$.root.length)
              return;
            $mdTheming(elements.$.scrollContainer);
            elements.$.scrollContainer.detach();
            elements.$.root.append(elements.$.scrollContainer);
            if ($animate.pin)
              $animate.pin(elements.$.scrollContainer, $rootElement);
          }
          function focusElement() {
            if ($scope.autofocus)
              elements.input.focus();
          }
          function configureWatchers() {
            var wait = parseInt($scope.delay, 10) || 0;
            $attrs.$observe('disabled', function(value) {
              ctrl.isDisabled = !!value;
            });
            $attrs.$observe('required', function(value) {
              ctrl.isRequired = !!value;
            });
            $scope.$watch('searchText', wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
            $scope.$watch('selectedItem', selectedItemChange);
            angular.element($window).on('resize', positionDropdown);
            $scope.$on('$destroy', cleanup);
          }
          function cleanup() {
            angular.element($window).off('resize', positionDropdown);
            if (elements) {
              var items = 'ul scroller scrollContainer input'.split(' ');
              angular.forEach(items, function(key) {
                elements.$[key].remove();
              });
            }
          }
          function gatherElements() {
            elements = {
              main: $element[0],
              scrollContainer: $element[0].getElementsByClassName('md-virtual-repeat-container')[0],
              scroller: $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0],
              ul: $element.find('ul')[0],
              input: $element.find('input')[0],
              wrap: $element.find('md-autocomplete-wrap')[0],
              root: document.body
            };
            elements.li = elements.ul.getElementsByTagName('li');
            elements.snap = getSnapTarget();
            elements.$ = getAngularElements(elements);
          }
          function getSnapTarget() {
            for (var element = $element; element.length; element = element.parent()) {
              if (angular.isDefined(element.attr('md-autocomplete-snap')))
                return element[0];
            }
            return elements.wrap;
          }
          function getAngularElements(elements) {
            var obj = {};
            for (var key in elements) {
              if (elements.hasOwnProperty(key))
                obj[key] = angular.element(elements[key]);
            }
            return obj;
          }
          function handleHiddenChange(hidden, oldHidden) {
            if (!hidden && oldHidden) {
              positionDropdown();
              if (elements) {
                $mdUtil.nextTick(function() {
                  $mdUtil.disableScrollAround(elements.ul);
                }, false, $scope);
              }
            } else if (hidden && !oldHidden) {
              $mdUtil.nextTick(function() {
                $mdUtil.enableScrolling();
              }, false, $scope);
            }
          }
          function onListEnter() {
            noBlur = true;
          }
          function onListLeave() {
            if (!hasFocus)
              elements.input.focus();
            noBlur = false;
            ctrl.hidden = shouldHide();
          }
          function onMouseup() {
            elements.input.focus();
          }
          function selectedItemChange(selectedItem, previousSelectedItem) {
            if (selectedItem) {
              getDisplayValue(selectedItem).then(function(val) {
                $scope.searchText = val;
                handleSelectedItemChange(selectedItem, previousSelectedItem);
              });
            }
            if (selectedItem !== previousSelectedItem)
              announceItemChange();
          }
          function announceItemChange() {
            angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem));
          }
          function announceTextChange() {
            angular.isFunction($scope.textChange) && $scope.textChange();
          }
          function handleSelectedItemChange(selectedItem, previousSelectedItem) {
            selectedItemWatchers.forEach(function(watcher) {
              watcher(selectedItem, previousSelectedItem);
            });
          }
          function registerSelectedItemWatcher(cb) {
            if (selectedItemWatchers.indexOf(cb) == -1) {
              selectedItemWatchers.push(cb);
            }
          }
          function unregisterSelectedItemWatcher(cb) {
            var i = selectedItemWatchers.indexOf(cb);
            if (i != -1) {
              selectedItemWatchers.splice(i, 1);
            }
          }
          function handleSearchText(searchText, previousSearchText) {
            ctrl.index = getDefaultIndex();
            if (searchText === previousSearchText)
              return;
            getDisplayValue($scope.selectedItem).then(function(val) {
              if (searchText !== val) {
                $scope.selectedItem = null;
                if (searchText !== previousSearchText)
                  announceTextChange();
                if (!isMinLengthMet()) {
                  ctrl.matches = [];
                  setLoading(false);
                  updateMessages();
                } else {
                  handleQuery();
                }
              }
            });
          }
          function blur() {
            hasFocus = false;
            if (!noBlur) {
              ctrl.hidden = shouldHide();
            }
          }
          function doBlur(forceBlur) {
            if (forceBlur) {
              noBlur = false;
              hasFocus = false;
            }
            elements.input.blur();
          }
          function focus() {
            hasFocus = true;
            if (!angular.isString($scope.searchText))
              $scope.searchText = '';
            ctrl.hidden = shouldHide();
            if (!ctrl.hidden)
              handleQuery();
          }
          function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.DOWN_ARROW:
                if (ctrl.loading)
                  return;
                event.stopPropagation();
                event.preventDefault();
                ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
                updateScroll();
                updateMessages();
                break;
              case $mdConstant.KEY_CODE.UP_ARROW:
                if (ctrl.loading)
                  return;
                event.stopPropagation();
                event.preventDefault();
                ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
                updateScroll();
                updateMessages();
                break;
              case $mdConstant.KEY_CODE.TAB:
                onListLeave();
                if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1)
                  return;
                select(ctrl.index);
                break;
              case $mdConstant.KEY_CODE.ENTER:
                if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1)
                  return;
                if (hasSelection())
                  return;
                event.stopPropagation();
                event.preventDefault();
                select(ctrl.index);
                break;
              case $mdConstant.KEY_CODE.ESCAPE:
                event.stopPropagation();
                event.preventDefault();
                clearValue();
                doBlur(true);
                break;
              default:
            }
          }
          function getMinLength() {
            return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
          }
          function getDisplayValue(item) {
            return $q.when(getItemText(item) || item);
            function getItemText(item) {
              return (item && $scope.itemText) ? $scope.itemText(getItemAsNameVal(item)) : null;
            }
          }
          function getItemAsNameVal(item) {
            if (!item)
              return undefined;
            var locals = {};
            if (ctrl.itemName)
              locals[ctrl.itemName] = item;
            return locals;
          }
          function getDefaultIndex() {
            return $scope.autoselect ? 0 : -1;
          }
          function setLoading(value) {
            if (ctrl.loading != value) {
              ctrl.loading = value;
            }
            ctrl.hidden = shouldHide();
          }
          function shouldHide() {
            if (ctrl.loading && !hasMatches())
              return true;
            else if (hasSelection())
              return true;
            else if (!hasFocus)
              return true;
            else
              return !shouldShow();
          }
          function shouldShow() {
            return (isMinLengthMet() && hasMatches()) || notFoundVisible();
          }
          function hasMatches() {
            return ctrl.matches.length ? true : false;
          }
          function hasSelection() {
            return ctrl.scope.selectedItem ? true : false;
          }
          function loadingIsVisible() {
            return ctrl.loading && !hasSelection();
          }
          function getCurrentDisplayValue() {
            return getDisplayValue(ctrl.matches[ctrl.index]);
          }
          function isMinLengthMet() {
            return ($scope.searchText || '').length >= getMinLength();
          }
          function defineProperty(key, handler, value) {
            Object.defineProperty(ctrl, key, {
              get: function() {
                return value;
              },
              set: function(newValue) {
                var oldValue = value;
                value = newValue;
                handler(newValue, oldValue);
              }
            });
          }
          function select(index) {
            $mdUtil.nextTick(function() {
              getDisplayValue(ctrl.matches[index]).then(function(val) {
                var ngModel = elements.$.input.controller('ngModel');
                ngModel.$setViewValue(val);
                ngModel.$render();
              }).finally(function() {
                $scope.selectedItem = ctrl.matches[index];
                setLoading(false);
              });
            }, false);
          }
          function clearValue() {
            setLoading(true);
            ctrl.index = 0;
            ctrl.matches = [];
            $scope.searchText = '';
            select(-1);
            var eventObj = document.createEvent('CustomEvent');
            eventObj.initCustomEvent('input', true, true, {value: $scope.searchText});
            elements.input.dispatchEvent(eventObj);
            elements.input.focus();
          }
          function fetchResults(searchText) {
            var items = $scope.$parent.$eval(itemExpr),
                term = searchText.toLowerCase();
            if (angular.isArray(items)) {
              handleResults(items);
            } else if (items) {
              setLoading(true);
              $mdUtil.nextTick(function() {
                if (items.success)
                  items.success(handleResults);
                if (items.then)
                  items.then(handleResults);
                if (items.finally)
                  items.finally(function() {
                    setLoading(false);
                  });
              }, true, $scope);
            }
            function handleResults(matches) {
              cache[term] = matches;
              if ((searchText || '') !== ($scope.searchText || ''))
                return;
              ctrl.matches = matches;
              ctrl.hidden = shouldHide();
              if ($scope.selectOnMatch)
                selectItemOnMatch();
              updateMessages();
              positionDropdown();
            }
          }
          function updateMessages() {
            getCurrentDisplayValue().then(function(msg) {
              ctrl.messages = [getCountMessage(), msg];
            });
          }
          function getCountMessage() {
            if (lastCount === ctrl.matches.length)
              return '';
            lastCount = ctrl.matches.length;
            switch (ctrl.matches.length) {
              case 0:
                return 'There are no matches available.';
              case 1:
                return 'There is 1 match available.';
              default:
                return 'There are ' + ctrl.matches.length + ' matches available.';
            }
          }
          function updateScroll() {
            if (!elements.li[0])
              return;
            var height = elements.li[0].offsetHeight,
                top = height * ctrl.index,
                bot = top + height,
                hgt = elements.scroller.clientHeight,
                scrollTop = elements.scroller.scrollTop;
            if (top < scrollTop) {
              scrollTo(top);
            } else if (bot > scrollTop + hgt) {
              scrollTo(bot - hgt);
            }
          }
          function scrollTo(offset) {
            elements.$.scrollContainer.controller('mdVirtualRepeatContainer').scrollTo(offset);
          }
          function notFoundVisible() {
            var textLength = (ctrl.scope.searchText || '').length;
            return ctrl.hasNotFound && !hasMatches() && !ctrl.loading && textLength >= getMinLength() && hasFocus && !hasSelection();
          }
          function handleQuery() {
            var searchText = $scope.searchText || '',
                term = searchText.toLowerCase();
            if (!$scope.noCache && cache[term]) {
              ctrl.matches = cache[term];
              updateMessages();
            } else {
              fetchResults(searchText);
            }
            ctrl.hidden = shouldHide();
          }
          function selectItemOnMatch() {
            var searchText = $scope.searchText,
                matches = ctrl.matches,
                item = matches[0];
            if (matches.length === 1)
              getDisplayValue(item).then(function(displayValue) {
                if (searchText == displayValue)
                  select(0);
              });
          }
        }
        MdAutocompleteCtrl.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdAutocomplete', MdAutocomplete);
        function MdAutocomplete() {
          var hasNotFoundTemplate = false;
          return {
            controller: 'MdAutocompleteCtrl',
            controllerAs: '$mdAutocompleteCtrl',
            scope: {
              inputName: '@mdInputName',
              inputMinlength: '@mdInputMinlength',
              inputMaxlength: '@mdInputMaxlength',
              searchText: '=?mdSearchText',
              selectedItem: '=?mdSelectedItem',
              itemsExpr: '@mdItems',
              itemText: '&mdItemText',
              placeholder: '@placeholder',
              noCache: '=?mdNoCache',
              selectOnMatch: '=?mdSelectOnMatch',
              itemChange: '&?mdSelectedItemChange',
              textChange: '&?mdSearchTextChange',
              minLength: '=?mdMinLength',
              delay: '=?mdDelay',
              autofocus: '=?mdAutofocus',
              floatingLabel: '@?mdFloatingLabel',
              autoselect: '=?mdAutoselect',
              menuClass: '@?mdMenuClass',
              inputId: '@?mdInputId'
            },
            link: function(scope, element, attrs, controller) {
              controller.hasNotFound = hasNotFoundTemplate;
            },
            template: function(element, attr) {
              var noItemsTemplate = getNoItemsTemplate(),
                  itemTemplate = getItemTemplate(),
                  leftover = element.html(),
                  tabindex = attr.tabindex;
              hasNotFoundTemplate = noItemsTemplate ? true : false;
              if (!attr.hasOwnProperty('tabindex'))
                element.attr('tabindex', '-1');
              return '\
        <md-autocomplete-wrap\
            layout="row"\
            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }"\
            role="listbox">\
          ' + getInputElement() + '\
          <md-progress-linear\
              class="' + (attr.mdFloatingLabel ? 'md-inline' : '') + '"\
              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"\
              md-mode="indeterminate"></md-progress-linear>\
          <md-virtual-repeat-container\
              md-auto-shrink\
              md-auto-shrink-min="1"\
              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"\
              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"\
              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"\
              ng-hide="$mdAutocompleteCtrl.hidden"\
              class="md-autocomplete-suggestions-container md-whiteframe-z1"\
              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"\
              role="presentation">\
            <ul class="md-autocomplete-suggestions"\
                ng-class="::menuClass"\
                id="ul-{{$mdAutocompleteCtrl.id}}">\
              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"\
                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"\
                  ng-click="$mdAutocompleteCtrl.select($index)"\
                  md-extra-name="$mdAutocompleteCtrl.itemName">\
                  ' + itemTemplate + '\
                  </li>' + noItemsTemplate + '\
            </ul>\
          </md-virtual-repeat-container>\
        </md-autocomplete-wrap>\
        <aria-status\
            class="md-visually-hidden"\
            role="status"\
            aria-live="assertive">\
          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}</p>\
        </aria-status>';
              function getItemTemplate() {
                var templateTag = element.find('md-item-template').detach(),
                    html = templateTag.length ? templateTag.html() : element.html();
                if (!templateTag.length)
                  element.empty();
                return '<md-autocomplete-parent-scope md-autocomplete-replace>' + html + '</md-autocomplete-parent-scope>';
              }
              function getNoItemsTemplate() {
                var templateTag = element.find('md-not-found').detach(),
                    template = templateTag.length ? templateTag.html() : '';
                return template ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"\
                         md-autocomplete-parent-scope>' + template + '</li>' : '';
              }
              function getInputElement() {
                if (attr.mdFloatingLabel) {
                  return '\
            <md-input-container flex ng-if="floatingLabel">\
              <label>{{floatingLabel}}</label>\
              <input type="search"\
                  ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"\
                  name="{{inputName}}"\
                  autocomplete="off"\
                  ng-required="$mdAutocompleteCtrl.isRequired"\
                  ng-minlength="inputMinlength"\
                  ng-maxlength="inputMaxlength"\
                  ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                  ng-model="$mdAutocompleteCtrl.scope.searchText"\
                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                  ng-blur="$mdAutocompleteCtrl.blur()"\
                  ng-focus="$mdAutocompleteCtrl.focus()"\
                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                  aria-label="{{floatingLabel}}"\
                  aria-autocomplete="list"\
                  aria-haspopup="true"\
                  aria-activedescendant=""\
                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\
              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\
            </md-input-container>';
                } else {
                  return '\
            <input flex type="search"\
                ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"\
                name="{{inputName}}"\
                ng-if="!floatingLabel"\
                autocomplete="off"\
                ng-required="$mdAutocompleteCtrl.isRequired"\
                ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                ng-model="$mdAutocompleteCtrl.scope.searchText"\
                ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                ng-blur="$mdAutocompleteCtrl.blur()"\
                ng-focus="$mdAutocompleteCtrl.focus()"\
                placeholder="{{placeholder}}"\
                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                aria-label="{{placeholder}}"\
                aria-autocomplete="list"\
                aria-haspopup="true"\
                aria-activedescendant=""\
                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\
            <button\
                type="button"\
                tabindex="-1"\
                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"\
                ng-click="$mdAutocompleteCtrl.clear()">\
              <md-icon md-svg-icon="md-close"></md-icon>\
              <span class="md-visually-hidden">Clear</span>\
            </button>\
                ';
                }
              }
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdAutocompleteParentScope', MdAutocompleteItemScopeDirective);
        function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
          return {
            restrict: 'AE',
            compile: compile,
            terminal: true,
            transclude: 'element'
          };
          function compile(tElement, tAttr, transclude) {
            return function postLink(scope, element, attr) {
              var ctrl = scope.$mdAutocompleteCtrl;
              var newScope = ctrl.parent.$new();
              var itemName = ctrl.itemName;
              watchVariable('$index', '$index');
              watchVariable('item', itemName);
              connectScopes();
              transclude(newScope, function(clone) {
                element.after(clone);
              });
              function watchVariable(variable, alias) {
                newScope[alias] = scope[variable];
                scope.$watch(variable, function(value) {
                  $mdUtil.nextTick(function() {
                    newScope[alias] = value;
                  });
                });
              }
              function connectScopes() {
                var scopeDigesting = false;
                var newScopeDigesting = false;
                scope.$watch(function() {
                  if (newScopeDigesting || scopeDigesting) {
                    return;
                  }
                  scopeDigesting = true;
                  scope.$$postDigest(function() {
                    if (!newScopeDigesting) {
                      newScope.$digest();
                    }
                    scopeDigesting = newScopeDigesting = false;
                  });
                });
                newScope.$watch(function() {
                  newScopeDigesting = true;
                });
              }
            };
          }
        }
        MdAutocompleteItemScopeDirective.$inject = ["$compile", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').controller('MdHighlightCtrl', MdHighlightCtrl);
        function MdHighlightCtrl($scope, $element, $attrs) {
          this.init = init;
          function init(termExpr, unsafeTextExpr) {
            var text = null,
                regex = null,
                flags = $attrs.mdHighlightFlags || '',
                watcher = $scope.$watch(function($scope) {
                  return {
                    term: termExpr($scope),
                    unsafeText: unsafeTextExpr($scope)
                  };
                }, function(state, prevState) {
                  if (text === null || state.unsafeText !== prevState.unsafeText) {
                    text = angular.element('<div>').text(state.unsafeText).html();
                  }
                  if (regex === null || state.term !== prevState.term) {
                    regex = getRegExp(state.term, flags);
                  }
                  $element.html(text.replace(regex, '<span class="highlight">$&</span>'));
                }, true);
            $element.on('$destroy', watcher);
          }
          function sanitize(term) {
            return term && term.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, '\\$&');
          }
          function getRegExp(text, flags) {
            var str = '';
            if (flags.indexOf('^') >= 1)
              str += '^';
            str += text;
            if (flags.indexOf('$') >= 1)
              str += '$';
            return new RegExp(sanitize(str), flags.replace(/[\$\^]/g, ''));
          }
        }
        MdHighlightCtrl.$inject = ["$scope", "$element", "$attrs"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdHighlightText', MdHighlight);
        function MdHighlight($interpolate, $parse) {
          return {
            terminal: true,
            controller: 'MdHighlightCtrl',
            compile: function mdHighlightCompile(tElement, tAttr) {
              var termExpr = $parse(tAttr.mdHighlightText);
              var unsafeTextExpr = $interpolate(tElement.html());
              return function mdHighlightLink(scope, element, attr, ctrl) {
                ctrl.init(termExpr, unsafeTextExpr);
              };
            }
          };
        }
        MdHighlight.$inject = ["$interpolate", "$parse"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChip', MdChip);
        var DELETE_HINT_TEMPLATE = '\
    <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">\
      {{$mdChipsCtrl.deleteHint}}\
    </span>';
        function MdChip($mdTheming, $mdUtil) {
          var hintTemplate = $mdUtil.processTemplate(DELETE_HINT_TEMPLATE);
          return {
            restrict: 'E',
            require: '^?mdChips',
            compile: compile
          };
          function compile(element, attr) {
            element.append($mdUtil.processTemplate(hintTemplate));
            return function postLink(scope, element, attr, ctrl) {
              element.addClass('md-chip');
              $mdTheming(element);
              if (ctrl)
                angular.element(element[0].querySelector('.md-chip-content')).on('blur', function() {
                  ctrl.selectedChip = -1;
                });
            };
          }
        }
        MdChip.$inject = ["$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChipRemove', MdChipRemove);
        function MdChipRemove($timeout) {
          return {
            restrict: 'A',
            require: '^mdChips',
            scope: false,
            link: postLink
          };
          function postLink(scope, element, attr, ctrl) {
            element.on('click', function(event) {
              scope.$apply(function() {
                ctrl.removeChip(scope.$$replacedScope.$index);
              });
            });
            $timeout(function() {
              element.attr({
                tabindex: -1,
                'aria-hidden': true
              });
              element.find('button').attr('tabindex', '-1');
            });
          }
        }
        MdChipRemove.$inject = ["$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChipTransclude', MdChipTransclude);
        function MdChipTransclude($compile) {
          return {
            restrict: 'EA',
            terminal: true,
            link: link,
            scope: false
          };
          function link(scope, element, attr) {
            var ctrl = scope.$parent.$mdChipsCtrl,
                newScope = ctrl.parent.$new(false, ctrl.parent);
            newScope.$$replacedScope = scope;
            newScope.$chip = scope.$chip;
            newScope.$index = scope.$index;
            newScope.$mdChipsCtrl = ctrl;
            var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);
            element.html(newHtml);
            $compile(element.contents())(newScope);
          }
        }
        MdChipTransclude.$inject = ["$compile"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdChipsCtrl', MdChipsCtrl);
        function MdChipsCtrl($scope, $mdConstant, $log, $element, $timeout) {
          this.$timeout = $timeout;
          this.$mdConstant = $mdConstant;
          this.$scope = $scope;
          this.parent = $scope.$parent;
          this.$log = $log;
          this.$element = $element;
          this.ngModelCtrl = null;
          this.userInputNgModelCtrl = null;
          this.userInputElement = null;
          this.items = [];
          this.selectedChip = -1;
          this.hasAutocomplete = false;
          this.deleteHint = 'Press delete to remove this chip.';
          this.deleteButtonLabel = 'Remove';
          this.chipBuffer = '';
          this.useOnAppend = false;
          this.useTransformChip = false;
          this.useOnAdd = false;
          this.useOnRemove = false;
          this.useOnSelect = false;
        }
        MdChipsCtrl.$inject = ["$scope", "$mdConstant", "$log", "$element", "$timeout"];
        MdChipsCtrl.prototype.inputKeydown = function(event) {
          var chipBuffer = this.getChipBuffer();
          if (this.hasAutocomplete && event.isDefaultPrevented && event.isDefaultPrevented()) {
            return;
          }
          if (event.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) {
            if (chipBuffer)
              return;
            event.preventDefault();
            event.stopPropagation();
            if (this.items.length)
              this.selectAndFocusChipSafe(this.items.length - 1);
            return;
          }
          if (!this.separatorKeys || this.separatorKeys.length < 1) {
            this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER];
          }
          if (this.separatorKeys.indexOf(event.keyCode) !== -1) {
            if ((this.hasAutocomplete && this.requireMatch) || !chipBuffer)
              return;
            event.preventDefault();
            this.appendChip(chipBuffer);
            this.resetChipBuffer();
          }
        };
        MdChipsCtrl.prototype.chipKeydown = function(event) {
          if (this.getChipBuffer())
            return;
          switch (event.keyCode) {
            case this.$mdConstant.KEY_CODE.BACKSPACE:
            case this.$mdConstant.KEY_CODE.DELETE:
              if (this.selectedChip < 0)
                return;
              event.preventDefault();
              this.removeAndSelectAdjacentChip(this.selectedChip);
              break;
            case this.$mdConstant.KEY_CODE.LEFT_ARROW:
              event.preventDefault();
              if (this.selectedChip < 0)
                this.selectedChip = this.items.length;
              if (this.items.length)
                this.selectAndFocusChipSafe(this.selectedChip - 1);
              break;
            case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
              event.preventDefault();
              this.selectAndFocusChipSafe(this.selectedChip + 1);
              break;
            case this.$mdConstant.KEY_CODE.ESCAPE:
            case this.$mdConstant.KEY_CODE.TAB:
              if (this.selectedChip < 0)
                return;
              event.preventDefault();
              this.onFocus();
              break;
          }
        };
        MdChipsCtrl.prototype.getPlaceholder = function() {
          var useSecondary = (this.items.length && (this.secondaryPlaceholder == '' || this.secondaryPlaceholder));
          return useSecondary ? this.placeholder : this.secondaryPlaceholder;
        };
        MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {
          var selIndex = this.getAdjacentChipIndex(index);
          this.removeChip(index);
          this.$timeout(angular.bind(this, function() {
            this.selectAndFocusChipSafe(selIndex);
          }));
        };
        MdChipsCtrl.prototype.resetSelectedChip = function() {
          this.selectedChip = -1;
        };
        MdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {
          var len = this.items.length - 1;
          return (len == 0) ? -1 : (index == len) ? index - 1 : index;
        };
        MdChipsCtrl.prototype.appendChip = function(newChip) {
          if (this.useTransformChip && this.transformChip) {
            var transformedChip = this.transformChip({'$chip': newChip});
            if (angular.isDefined(transformedChip)) {
              newChip = transformedChip;
            }
          }
          if (angular.isObject(newChip)) {
            var identical = this.items.some(function(item) {
              return angular.equals(newChip, item);
            });
            if (identical)
              return;
          }
          if (newChip == null || this.items.indexOf(newChip) + 1)
            return;
          var index = this.items.push(newChip);
          if (this.useOnAdd && this.onAdd) {
            this.onAdd({
              '$chip': newChip,
              '$index': index
            });
          }
        };
        MdChipsCtrl.prototype.useOnAppendExpression = function() {
          this.$log.warn("md-on-append is deprecated; please use md-transform-chip or md-on-add instead");
          if (!this.useTransformChip || !this.transformChip) {
            this.useTransformChip = true;
            this.transformChip = this.onAppend;
          }
        };
        MdChipsCtrl.prototype.useTransformChipExpression = function() {
          this.useTransformChip = true;
        };
        MdChipsCtrl.prototype.useOnAddExpression = function() {
          this.useOnAdd = true;
        };
        MdChipsCtrl.prototype.useOnRemoveExpression = function() {
          this.useOnRemove = true;
        };
        MdChipsCtrl.prototype.useOnSelectExpression = function() {
          this.useOnSelect = true;
        };
        MdChipsCtrl.prototype.getChipBuffer = function() {
          return !this.userInputElement ? this.chipBuffer : this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value;
        };
        MdChipsCtrl.prototype.resetChipBuffer = function() {
          if (this.userInputElement) {
            if (this.userInputNgModelCtrl) {
              this.userInputNgModelCtrl.$setViewValue('');
              this.userInputNgModelCtrl.$render();
            } else {
              this.userInputElement[0].value = '';
            }
          } else {
            this.chipBuffer = '';
          }
        };
        MdChipsCtrl.prototype.removeChip = function(index) {
          var removed = this.items.splice(index, 1);
          if (removed && removed.length && this.useOnRemove && this.onRemove) {
            this.onRemove({
              '$chip': removed[0],
              '$index': index
            });
          }
        };
        MdChipsCtrl.prototype.removeChipAndFocusInput = function(index) {
          this.removeChip(index);
          this.onFocus();
        };
        MdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {
          if (!this.items.length) {
            this.selectChip(-1);
            this.onFocus();
            return;
          }
          if (index === this.items.length)
            return this.onFocus();
          index = Math.max(index, 0);
          index = Math.min(index, this.items.length - 1);
          this.selectChip(index);
          this.focusChip(index);
        };
        MdChipsCtrl.prototype.selectChip = function(index) {
          if (index >= -1 && index <= this.items.length) {
            this.selectedChip = index;
            if (this.useOnSelect && this.onSelect) {
              this.onSelect({'$chip': this.items[this.selectedChip]});
            }
          } else {
            this.$log.warn('Selected Chip index out of bounds; ignoring.');
          }
        };
        MdChipsCtrl.prototype.selectAndFocusChip = function(index) {
          this.selectChip(index);
          if (index != -1) {
            this.focusChip(index);
          }
        };
        MdChipsCtrl.prototype.focusChip = function(index) {
          this.$element[0].querySelector('md-chip[index="' + index + '"] .md-chip-content').focus();
        };
        MdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {
          this.ngModelCtrl = ngModelCtrl;
          var self = this;
          ngModelCtrl.$render = function() {
            self.items = self.ngModelCtrl.$viewValue;
          };
        };
        MdChipsCtrl.prototype.onFocus = function() {
          var input = this.$element[0].querySelector('input');
          input && input.focus();
          this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputFocus = function() {
          this.inputHasFocus = true;
          this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputBlur = function() {
          this.inputHasFocus = false;
        };
        MdChipsCtrl.prototype.configureUserInput = function(inputElement) {
          this.userInputElement = inputElement;
          var ngModelCtrl = inputElement.controller('ngModel');
          if (ngModelCtrl != this.ngModelCtrl) {
            this.userInputNgModelCtrl = ngModelCtrl;
          }
          var scope = this.$scope;
          var ctrl = this;
          var scopeApplyFn = function(event, fn) {
            scope.$evalAsync(angular.bind(ctrl, fn, event));
          };
          inputElement.attr({tabindex: 0}).on('keydown', function(event) {
            scopeApplyFn(event, ctrl.inputKeydown);
          }).on('focus', function(event) {
            scopeApplyFn(event, ctrl.onInputFocus);
          }).on('blur', function(event) {
            scopeApplyFn(event, ctrl.onInputBlur);
          });
        };
        MdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {
          if (ctrl) {
            this.hasAutocomplete = true;
            ctrl.registerSelectedItemWatcher(angular.bind(this, function(item) {
              if (item) {
                this.appendChip(item);
                this.resetChipBuffer();
              }
            }));
            this.$element.find('input').on('focus', angular.bind(this, this.onInputFocus)).on('blur', angular.bind(this, this.onInputBlur));
          }
        };
        MdChipsCtrl.prototype.hasFocus = function() {
          return this.inputHasFocus || this.selectedChip >= 0;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChips', MdChips);
        var MD_CHIPS_TEMPLATE = '\
      <md-chips-wrap\
          ng-if="!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0"\
          ng-keydown="$mdChipsCtrl.chipKeydown($event)"\
          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \'md-readonly\': !$mdChipsCtrl.ngModelCtrl }"\
          class="md-chips">\
        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"\
            index="{{$index}}"\
            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': $mdChipsCtrl.readonly}">\
          <div class="md-chip-content"\
              tabindex="-1"\
              aria-hidden="true"\
              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"\
              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>\
          <div ng-if="!$mdChipsCtrl.readonly"\
               class="md-chip-remove-container"\
               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>\
        </md-chip>\
        <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"\
            class="md-chip-input-container"\
            md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>\
        </div>\
      </md-chips-wrap>';
        var CHIP_INPUT_TEMPLATE = '\
        <input\
            class="md-input"\
            tabindex="0"\
            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"\
            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"\
            ng-model="$mdChipsCtrl.chipBuffer"\
            ng-focus="$mdChipsCtrl.onInputFocus()"\
            ng-blur="$mdChipsCtrl.onInputBlur()"\
            ng-keydown="$mdChipsCtrl.inputKeydown($event)">';
        var CHIP_DEFAULT_TEMPLATE = '\
      <span>{{$chip}}</span>';
        var CHIP_REMOVE_TEMPLATE = '\
      <button\
          class="md-chip-remove"\
          ng-if="!$mdChipsCtrl.readonly"\
          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"\
          type="button"\
          aria-hidden="true"\
          tabindex="-1">\
        <md-icon md-svg-icon="md-close"></md-icon>\
        <span class="md-visually-hidden">\
          {{$mdChipsCtrl.deleteButtonLabel}}\
        </span>\
      </button>';
        function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout) {
          var templates = getTemplates();
          return {
            template: function(element, attrs) {
              attrs['$mdUserTemplate'] = element.clone();
              return templates.chips;
            },
            require: ['mdChips'],
            restrict: 'E',
            controller: 'MdChipsCtrl',
            controllerAs: '$mdChipsCtrl',
            bindToController: true,
            compile: compile,
            scope: {
              readonly: '=readonly',
              placeholder: '@',
              secondaryPlaceholder: '@',
              transformChip: '&mdTransformChip',
              onAppend: '&mdOnAppend',
              onAdd: '&mdOnAdd',
              onRemove: '&mdOnRemove',
              onSelect: '&mdOnSelect',
              deleteHint: '@',
              deleteButtonLabel: '@',
              separatorKeys: '=?mdSeparatorKeys',
              requireMatch: '=?mdRequireMatch'
            }
          };
          function compile(element, attr) {
            var userTemplate = attr['$mdUserTemplate'];
            attr['$mdUserTemplate'] = null;
            var chipRemoveTemplate = getTemplateByQuery('md-chips>*[md-chip-remove]') || templates.remove,
                chipContentsTemplate = getTemplateByQuery('md-chips>md-chip-template') || templates.default,
                chipInputTemplate = getTemplateByQuery('md-chips>md-autocomplete') || getTemplateByQuery('md-chips>input') || templates.input,
                staticChips = userTemplate.find('md-chip');
            if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {
              $log.warn('invalid placement of md-chip-remove within md-chip-template.');
            }
            function getTemplateByQuery(query) {
              if (!attr.ngModel)
                return;
              var element = userTemplate[0].querySelector(query);
              return element && element.outerHTML;
            }
            return function postLink(scope, element, attrs, controllers) {
              $mdUtil.initOptionalProperties(scope, attr);
              $mdTheming(element);
              var mdChipsCtrl = controllers[0];
              mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;
              mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate;
              mdChipsCtrl.chipInputTemplate = chipInputTemplate;
              element.attr({
                'aria-hidden': true,
                tabindex: -1
              }).on('focus', function() {
                mdChipsCtrl.onFocus();
              });
              if (attr.ngModel) {
                mdChipsCtrl.configureNgModel(element.controller('ngModel'));
                if (attrs.mdTransformChip)
                  mdChipsCtrl.useTransformChipExpression();
                if (attrs.mdOnAppend)
                  mdChipsCtrl.useOnAppendExpression();
                if (attrs.mdOnAdd)
                  mdChipsCtrl.useOnAddExpression();
                if (attrs.mdOnRemove)
                  mdChipsCtrl.useOnRemoveExpression();
                if (attrs.mdOnSelect)
                  mdChipsCtrl.useOnSelectExpression();
                if (chipInputTemplate != templates.input) {
                  scope.$watch('$mdChipsCtrl.readonly', function(readonly) {
                    if (!readonly) {
                      $mdUtil.nextTick(function() {
                        if (chipInputTemplate.indexOf('<md-autocomplete') === 0)
                          mdChipsCtrl.configureAutocomplete(element.find('md-autocomplete').controller('mdAutocomplete'));
                        mdChipsCtrl.configureUserInput(element.find('input'));
                      });
                    }
                  });
                }
                $mdUtil.nextTick(function() {
                  var input = element.find('input');
                  input && input.toggleClass('md-input', true);
                });
              }
              if (staticChips.length > 0) {
                var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
                $timeout(function() {
                  element.find('md-chips-wrap').prepend(compiledStaticChips);
                });
              }
            };
          }
          function getTemplates() {
            return {
              chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
              input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
              default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
              remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
            };
          }
        }
        MdChips.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdContactChipsCtrl', MdContactChipsCtrl);
        function MdContactChipsCtrl() {
          this.selectedItem = null;
          this.searchText = '';
        }
        MdContactChipsCtrl.prototype.queryContact = function(searchText) {
          var results = this.contactQuery({'$query': searchText});
          return this.filterSelected ? results.filter(angular.bind(this, this.filterSelectedContacts)) : results;
        };
        MdContactChipsCtrl.prototype.itemName = function(item) {
          return item[this.contactName];
        };
        MdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {
          return this.contacts.indexOf(contact) == -1;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdContactChips', MdContactChips);
        var MD_CONTACT_CHIPS_TEMPLATE = '\
      <md-chips class="md-contact-chips"\
          ng-model="$mdContactChipsCtrl.contacts"\
          md-require-match="$mdContactChipsCtrl.requireMatch"\
          md-autocomplete-snap>\
          <md-autocomplete\
              md-menu-class="md-contact-chips-suggestions"\
              md-selected-item="$mdContactChipsCtrl.selectedItem"\
              md-search-text="$mdContactChipsCtrl.searchText"\
              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"\
              md-item-text="$mdContactChipsCtrl.itemName(item)"\
              md-no-cache="true"\
              md-autoselect\
              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?\
                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">\
            <div class="md-contact-suggestion">\
              <img \
                  ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{item[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="item[$mdContactChipsCtrl.contactImage]" />\
              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"\
                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">\
                {{item[$mdContactChipsCtrl.contactName]}}\
              </span>\
              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\
            </div>\
          </md-autocomplete>\
          <md-chip-template>\
            <div class="md-contact-avatar">\
              <img \
                  ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />\
            </div>\
            <div class="md-contact-name">\
              {{$chip[$mdContactChipsCtrl.contactName]}}\
            </div>\
          </md-chip-template>\
      </md-chips>';
        function MdContactChips($mdTheming, $mdUtil) {
          return {
            template: function(element, attrs) {
              return MD_CONTACT_CHIPS_TEMPLATE;
            },
            restrict: 'E',
            controller: 'MdContactChipsCtrl',
            controllerAs: '$mdContactChipsCtrl',
            bindToController: true,
            compile: compile,
            scope: {
              contactQuery: '&mdContacts',
              placeholder: '@',
              secondaryPlaceholder: '@',
              contactName: '@mdContactName',
              contactImage: '@mdContactImage',
              contactEmail: '@mdContactEmail',
              contacts: '=ngModel',
              requireMatch: '=?mdRequireMatch',
              highlightFlags: '@?mdHighlightFlags'
            }
          };
          function compile(element, attr) {
            return function postLink(scope, element, attrs, controllers) {
              $mdUtil.initOptionalProperties(scope, attr);
              $mdTheming(element);
              element.attr('tabindex', '-1');
            };
          }
        }
        MdContactChips.$inject = ["$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon').directive('mdIcon', ['$mdIcon', '$mdTheming', '$mdAria', mdIconDirective]);
        function mdIconDirective($mdIcon, $mdTheming, $mdAria) {
          return {
            scope: {
              fontSet: '@mdFontSet',
              fontIcon: '@mdFontIcon',
              svgIcon: '@mdSvgIcon',
              svgSrc: '@mdSvgSrc'
            },
            restrict: 'E',
            link: postLink
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            prepareForFontIcon();
            var label = attr.alt || scope.fontIcon || scope.svgIcon || element.text();
            var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || '');
            if (!attr['aria-label']) {
              if (label != '' && !parentsHaveText()) {
                $mdAria.expect(element, 'aria-label', label);
                $mdAria.expect(element, 'role', 'img');
              } else if (!element.text()) {
                $mdAria.expect(element, 'aria-hidden', 'true');
              }
            }
            if (attrName) {
              attr.$observe(attrName, function(attrVal) {
                element.empty();
                if (attrVal) {
                  $mdIcon(attrVal).then(function(svg) {
                    element.append(svg);
                  });
                }
              });
            }
            function parentsHaveText() {
              var parent = element.parent();
              if (parent.attr('aria-label') || parent.text()) {
                return true;
              } else if (parent.parent().attr('aria-label') || parent.parent().text()) {
                return true;
              }
              return false;
            }
            function prepareForFontIcon() {
              if (!scope.svgIcon && !scope.svgSrc) {
                if (scope.fontIcon) {
                  element.addClass('md-font ' + scope.fontIcon);
                }
                element.addClass($mdIcon.fontSet(scope.fontSet));
              }
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon').provider('$mdIcon', MdIconProvider);
        var config = {
          defaultViewBoxSize: 24,
          defaultFontSet: 'material-icons',
          fontSets: []
        };
        function MdIconProvider() {}
        MdIconProvider.prototype = {
          icon: function(id, url, viewBoxSize) {
            if (id.indexOf(':') == -1)
              id = '$default:' + id;
            config[id] = new ConfigurationItem(url, viewBoxSize);
            return this;
          },
          iconSet: function(id, url, viewBoxSize) {
            config[id] = new ConfigurationItem(url, viewBoxSize);
            return this;
          },
          defaultIconSet: function(url, viewBoxSize) {
            var setName = '$default';
            if (!config[setName]) {
              config[setName] = new ConfigurationItem(url, viewBoxSize);
            }
            config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
            return this;
          },
          defaultViewBoxSize: function(viewBoxSize) {
            config.defaultViewBoxSize = viewBoxSize;
            return this;
          },
          fontSet: function fontSet(alias, className) {
            config.fontSets.push({
              alias: alias,
              fontSet: className || alias
            });
            return this;
          },
          defaultFontSet: function defaultFontSet(className) {
            config.defaultFontSet = !className ? '' : className;
            return this;
          },
          defaultIconSize: function defaultIconSize(iconSize) {
            config.defaultIconSize = iconSize;
            return this;
          },
          preloadIcons: function($templateCache) {
            var iconProvider = this;
            var svgRegistry = [{
              id: 'md-tabs-arrow',
              url: 'md-tabs-arrow.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/></g></svg>'
            }, {
              id: 'md-close',
              url: 'md-close.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/></g></svg>'
            }, {
              id: 'md-cancel',
              url: 'md-cancel.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/></g></svg>'
            }, {
              id: 'md-menu',
              url: 'md-menu.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>'
            }, {
              id: 'md-toggle-arrow',
              url: 'md-toggle-arrow-svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 48 48"><path d="M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z"/><path d="M0 0h48v48h-48z" fill="none"/></svg>'
            }, {
              id: 'md-calendar',
              url: 'md-calendar.svg',
              svg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>'
            }];
            svgRegistry.forEach(function(asset) {
              iconProvider.icon(asset.id, asset.url);
              $templateCache.put(asset.url, asset.svg);
            });
          },
          $get: ['$http', '$q', '$log', '$templateCache', function($http, $q, $log, $templateCache) {
            this.preloadIcons($templateCache);
            return MdIconService(config, $http, $q, $log, $templateCache);
          }]
        };
        function ConfigurationItem(url, viewBoxSize) {
          this.url = url;
          this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
        }
        function MdIconService(config, $http, $q, $log, $templateCache) {
          var iconCache = {};
          var urlRegex = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/i;
          Icon.prototype = {
            clone: cloneSVG,
            prepare: prepareAndStyle
          };
          getIcon.fontSet = findRegisteredFontSet;
          return getIcon;
          function getIcon(id) {
            id = id || '';
            if (iconCache[id])
              return $q.when(iconCache[id].clone());
            if (urlRegex.test(id))
              return loadByURL(id).then(cacheIcon(id));
            if (id.indexOf(':') == -1)
              id = '$default:' + id;
            var load = config[id] ? loadByID : loadFromIconSet;
            return load(id).then(cacheIcon(id));
          }
          function findRegisteredFontSet(alias) {
            var useDefault = angular.isUndefined(alias) || !(alias && alias.length);
            if (useDefault)
              return config.defaultFontSet;
            var result = alias;
            angular.forEach(config.fontSets, function(it) {
              if (it.alias == alias)
                result = it.fontSet || result;
            });
            return result;
          }
          function cacheIcon(id) {
            return function updateCache(icon) {
              iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);
              return iconCache[id].clone();
            };
          }
          function loadByID(id) {
            var iconConfig = config[id];
            return loadByURL(iconConfig.url).then(function(icon) {
              return new Icon(icon, iconConfig);
            });
          }
          function loadFromIconSet(id) {
            var setName = id.substring(0, id.lastIndexOf(':')) || '$default';
            var iconSetConfig = config[setName];
            return !iconSetConfig ? announceIdNotFound(id) : loadByURL(iconSetConfig.url).then(extractFromSet);
            function extractFromSet(set) {
              var iconName = id.slice(id.lastIndexOf(':') + 1);
              var icon = set.querySelector('#' + iconName);
              return !icon ? announceIdNotFound(id) : new Icon(icon, iconSetConfig);
            }
            function announceIdNotFound(id) {
              var msg = 'icon ' + id + ' not found';
              $log.warn(msg);
              return $q.reject(msg || id);
            }
          }
          function loadByURL(url) {
            return $http.get(url, {cache: $templateCache}).then(function(response) {
              return angular.element('<div>').append(response.data).find('svg')[0];
            }).catch(announceNotFound);
          }
          function announceNotFound(err) {
            var msg = angular.isString(err) ? err : (err.message || err.data || err.statusText);
            $log.warn(msg);
            return $q.reject(msg);
          }
          function isIcon(target) {
            return angular.isDefined(target.element) && angular.isDefined(target.config);
          }
          function Icon(el, config) {
            if (el && el.tagName != 'svg') {
              el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el)[0];
            }
            if (!el.getAttribute('xmlns')) {
              el.setAttribute('xmlns', "http://www.w3.org/2000/svg");
            }
            this.element = el;
            this.config = config;
            this.prepare();
          }
          function prepareAndStyle() {
            var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
            angular.forEach({
              'fit': '',
              'height': '100%',
              'width': '100%',
              'preserveAspectRatio': 'xMidYMid meet',
              'viewBox': this.element.getAttribute('viewBox') || ('0 0 ' + viewBoxSize + ' ' + viewBoxSize)
            }, function(val, attr) {
              this.element.setAttribute(attr, val);
            }, this);
            angular.forEach({
              'pointer-events': 'none',
              'display': 'block'
            }, function(val, style) {
              this.element.style[style] = val;
            }, this);
          }
          function cloneSVG() {
            return this.element.cloneNode(true);
          }
        }
        MdIconService.$inject = ["config", "$http", "$q", "$log", "$templateCache"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').controller('mdMenuCtrl', MenuController);
        function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q) {
          var menuContainer;
          var self = this;
          var triggerElement;
          this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;
          this.init = function init(setMenuContainer, opts) {
            opts = opts || {};
            menuContainer = setMenuContainer;
            triggerElement = $element[0].querySelector('[ng-click],[ng-mouseenter]');
            triggerElement.setAttribute('aria-expanded', 'false');
            this.isInMenuBar = opts.isInMenuBar;
            this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll('.md-nested-menu'));
            menuContainer.on('$mdInterimElementRemove', function() {
              self.isOpen = false;
            });
            var menuContainerId = 'menu_container_' + $mdUtil.nextUid();
            menuContainer.attr('id', menuContainerId);
            angular.element(triggerElement).attr({
              'aria-owns': menuContainerId,
              'aria-haspopup': 'true'
            });
            $scope.$on('$destroy', this.disableHoverListener);
          };
          var openMenuTimeout,
              menuItems,
              deregisterScopeListeners = [];
          this.enableHoverListener = function() {
            deregisterScopeListeners.push($rootScope.$on('$mdMenuOpen', function(event, el) {
              if (menuContainer[0].contains(el[0])) {
                self.currentlyOpenMenu = el.controller('mdMenu');
                self.isAlreadyOpening = false;
                self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));
              }
            }));
            deregisterScopeListeners.push($rootScope.$on('$mdMenuClose', function(event, el) {
              if (menuContainer[0].contains(el[0])) {
                self.currentlyOpenMenu = undefined;
              }
            }));
            menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
            menuItems.on('mouseenter', self.handleMenuItemHover);
            menuItems.on('mouseleave', self.handleMenuItemMouseLeave);
          };
          this.disableHoverListener = function() {
            while (deregisterScopeListeners.length) {
              deregisterScopeListeners.shift()();
            }
            menuItems && menuItems.off('mouseenter', self.handleMenuItemHover);
            menuItems && menuItems.off('mouseleave', self.handleMenuMouseLeave);
          };
          this.handleMenuItemHover = function(event) {
            if (self.isAlreadyOpening)
              return;
            var nestedMenu = (event.target.querySelector('md-menu') || $mdUtil.getClosest(event.target, 'MD-MENU'));
            openMenuTimeout = $timeout(function() {
              if (nestedMenu) {
                nestedMenu = angular.element(nestedMenu).controller('mdMenu');
              }
              if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {
                var closeTo = self.nestLevel + 1;
                self.currentlyOpenMenu.close(true, {closeTo: closeTo});
              } else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open) {
                self.isAlreadyOpening = true;
                nestedMenu.open();
              }
            }, nestedMenu ? 100 : 250);
            var focusableTarget = event.currentTarget.querySelector('button:not([disabled])');
            focusableTarget && focusableTarget.focus();
          };
          this.handleMenuItemMouseLeave = function() {
            if (openMenuTimeout) {
              $timeout.cancel(openMenuTimeout);
              openMenuTimeout = undefined;
            }
          };
          this.open = function openMenu(ev) {
            ev && ev.stopPropagation();
            ev && ev.preventDefault();
            if (self.isOpen)
              return;
            self.enableHoverListener();
            self.isOpen = true;
            triggerElement = triggerElement || (ev ? ev.target : $element[0]);
            triggerElement.setAttribute('aria-expanded', 'true');
            $scope.$emit('$mdMenuOpen', $element);
            $mdMenu.show({
              scope: $scope,
              mdMenuCtrl: self,
              nestLevel: self.nestLevel,
              element: menuContainer,
              target: triggerElement,
              preserveElement: true,
              parent: 'body'
            }).finally(function() {
              triggerElement.setAttribute('aria-expanded', 'false');
              self.disableHoverListener();
            });
          };
          $scope.$mdOpenMenu = this.open;
          $scope.$watch(function() {
            return self.isOpen;
          }, function(isOpen) {
            if (isOpen) {
              menuContainer.attr('aria-hidden', 'false');
              $element[0].classList.add('md-open');
              angular.forEach(self.nestedMenus, function(el) {
                el.classList.remove('md-open');
              });
            } else {
              menuContainer.attr('aria-hidden', 'true');
              $element[0].classList.remove('md-open');
            }
            $scope.$mdMenuIsOpen = self.isOpen;
          });
          this.focusMenuContainer = function focusMenuContainer() {
            var focusTarget = menuContainer[0].querySelector('[md-menu-focus-target]');
            if (!focusTarget)
              focusTarget = menuContainer[0].querySelector('.md-button');
            focusTarget.focus();
          };
          this.registerContainerProxy = function registerContainerProxy(handler) {
            this.containerProxy = handler;
          };
          this.triggerContainerProxy = function triggerContainerProxy(ev) {
            this.containerProxy && this.containerProxy(ev);
          };
          this.destroy = function() {
            return self.isOpen ? $mdMenu.destroy() : $q.when(false);
          };
          this.close = function closeMenu(skipFocus, closeOpts) {
            if (!self.isOpen)
              return;
            self.isOpen = false;
            var eventDetails = angular.extend({}, closeOpts, {skipFocus: skipFocus});
            $scope.$emit('$mdMenuClose', $element, eventDetails);
            $mdMenu.hide(null, closeOpts);
            if (!skipFocus) {
              var el = self.restoreFocusTo || $element.find('button')[0];
              if (el instanceof angular.element)
                el = el[0];
              if (el)
                el.focus();
            }
          };
          this.positionMode = function positionMode() {
            var attachment = ($attrs.mdPositionMode || 'target').split(' ');
            if (attachment.length == 1) {
              attachment.push(attachment[0]);
            }
            return {
              left: attachment[0],
              top: attachment[1]
            };
          };
          this.offsets = function offsets() {
            var position = ($attrs.mdOffset || '0 0').split(' ').map(parseFloat);
            if (position.length == 2) {
              return {
                left: position[0],
                top: position[1]
              };
            } else if (position.length == 1) {
              return {
                top: position[0],
                left: position[0]
              };
            } else {
              throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');
            }
          };
        }
        MenuController.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').directive('mdMenu', MenuDirective);
        function MenuDirective($mdUtil) {
          var INVALID_PREFIX = 'Invalid HTML for md-menu: ';
          return {
            restrict: 'E',
            require: ['mdMenu', '?^mdMenuBar'],
            controller: 'mdMenuCtrl',
            scope: true,
            compile: compile
          };
          function compile(templateElement) {
            templateElement.addClass('md-menu');
            var triggerElement = templateElement.children()[0];
            if (!triggerElement.hasAttribute('ng-click')) {
              triggerElement = triggerElement.querySelector('[ng-click],[ng-mouseenter]') || triggerElement;
            }
            if (triggerElement && (triggerElement.nodeName == 'MD-BUTTON' || triggerElement.nodeName == 'BUTTON') && !triggerElement.hasAttribute('type')) {
              triggerElement.setAttribute('type', 'button');
            }
            if (templateElement.children().length != 2) {
              throw Error(INVALID_PREFIX + 'Expected two children elements.');
            }
            triggerElement && triggerElement.setAttribute('aria-haspopup', 'true');
            var nestedMenus = templateElement[0].querySelectorAll('md-menu');
            var nestingDepth = parseInt(templateElement[0].getAttribute('md-nest-level'), 10) || 0;
            if (nestedMenus) {
              angular.forEach($mdUtil.nodesToArray(nestedMenus), function(menuEl) {
                if (!menuEl.hasAttribute('md-position-mode')) {
                  menuEl.setAttribute('md-position-mode', 'cascade');
                }
                menuEl.classList.add('md-nested-menu');
                menuEl.setAttribute('md-nest-level', nestingDepth + 1);
              });
            }
            return link;
          }
          function link(scope, element, attrs, ctrls) {
            var mdMenuCtrl = ctrls[0];
            var isInMenuBar = ctrls[1] != undefined;
            var menuContainer = angular.element('<div class="md-open-menu-container md-whiteframe-z2"></div>');
            var menuContents = element.children()[1];
            if (!menuContents.hasAttribute('role')) {
              menuContents.setAttribute('role', 'menu');
            }
            menuContainer.append(menuContents);
            element.on('$destroy', function() {
              menuContainer.remove();
            });
            element.append(menuContainer);
            menuContainer[0].style.display = 'none';
            mdMenuCtrl.init(menuContainer, {isInMenuBar: isInMenuBar});
          }
        }
        MenuDirective.$inject = ["$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').provider('$mdMenu', MenuProvider);
        function MenuProvider($$interimElementProvider) {
          var MENU_EDGE_MARGIN = 8;
          menuDefaultOptions.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate"];
          return $$interimElementProvider('$mdMenu').setDefaults({
            methods: ['target'],
            options: menuDefaultOptions
          });
          function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate) {
            var animator = $mdUtil.dom.animator;
            return {
              parent: 'body',
              onShow: onShow,
              onRemove: onRemove,
              hasBackdrop: true,
              disableParentScroll: true,
              skipCompile: true,
              preserveScope: true,
              skipHide: true,
              themable: true
            };
            function showBackdrop(scope, element, options) {
              if (options.nestLevel)
                return angular.noop;
              if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
                options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
              } else {
                options.disableParentScroll = false;
              }
              if (options.hasBackdrop) {
                options.backdrop = $mdUtil.createBackdrop(scope, "md-menu-backdrop md-click-catcher");
                $animate.enter(options.backdrop, $document[0].body);
              }
              return function hideBackdrop() {
                if (options.backdrop)
                  options.backdrop.remove();
                if (options.disableParentScroll)
                  options.restoreScroll();
              };
            }
            function onRemove(scope, element, opts) {
              opts.cleanupInteraction();
              opts.cleanupResizing();
              opts.hideBackdrop();
              return (opts.$destroy === true) ? detachAndClean() : animateRemoval().then(detachAndClean);
              function animateRemoval() {
                return $animateCss(element, {addClass: 'md-leave'}).start();
              }
              function detachAndClean() {
                element.removeClass('md-active');
                detachElement(element, opts);
                opts.alreadyOpen = false;
              }
            }
            function onShow(scope, element, opts) {
              sanitizeAndConfigure(opts);
              $mdTheming.inherit(opts.menuContentEl, opts.target);
              opts.cleanupResizing = startRepositioningOnResize();
              opts.hideBackdrop = showBackdrop(scope, element, opts);
              return showMenu().then(function(response) {
                opts.alreadyOpen = true;
                opts.cleanupInteraction = activateInteraction();
                return response;
              });
              function showMenu() {
                opts.parent.append(element);
                element[0].style.display = '';
                return $q(function(resolve) {
                  var position = calculateMenuPosition(element, opts);
                  element.removeClass('md-leave');
                  $animateCss(element, {
                    addClass: 'md-active',
                    from: animator.toCss(position),
                    to: animator.toCss({transform: ''})
                  }).start().then(resolve);
                });
              }
              function sanitizeAndConfigure() {
                if (!opts.target) {
                  throw Error('$mdMenu.show() expected a target to animate from in options.target');
                }
                angular.extend(opts, {
                  alreadyOpen: false,
                  isRemoved: false,
                  target: angular.element(opts.target),
                  parent: angular.element(opts.parent),
                  menuContentEl: angular.element(element[0].querySelector('md-menu-content'))
                });
              }
              function startRepositioningOnResize() {
                var repositionMenu = (function(target, options) {
                  return $$rAF.throttle(function() {
                    if (opts.isRemoved)
                      return;
                    var position = calculateMenuPosition(target, options);
                    target.css(animator.toCss(position));
                  });
                })(element, opts);
                $window.addEventListener('resize', repositionMenu);
                $window.addEventListener('orientationchange', repositionMenu);
                return function stopRepositioningOnResize() {
                  $window.removeEventListener('resize', repositionMenu);
                  $window.removeEventListener('orientationchange', repositionMenu);
                };
              }
              function activateInteraction() {
                element.addClass('md-clickable');
                if (opts.backdrop)
                  opts.backdrop.on('click', onBackdropClick);
                opts.menuContentEl.on('keydown', onMenuKeyDown);
                opts.menuContentEl[0].addEventListener('click', captureClickListener, true);
                var focusTarget = opts.menuContentEl[0].querySelector('[md-menu-focus-target]');
                if (!focusTarget) {
                  var firstChild = opts.menuContentEl[0].firstElementChild;
                  focusTarget = firstChild && (firstChild.querySelector('.md-button:not([disabled])') || firstChild.firstElementChild);
                }
                focusTarget && focusTarget.focus();
                return function cleanupInteraction() {
                  element.removeClass('md-clickable');
                  if (opts.backdrop)
                    opts.backdrop.off('click', onBackdropClick);
                  opts.menuContentEl.off('keydown', onMenuKeyDown);
                  opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);
                };
                function onMenuKeyDown(ev) {
                  var handled;
                  switch (ev.keyCode) {
                    case $mdConstant.KEY_CODE.ESCAPE:
                      opts.mdMenuCtrl.close(false, {closeAll: true});
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.UP_ARROW:
                      if (!focusMenuItem(ev, opts.menuContentEl, opts, -1) && !opts.nestLevel) {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.DOWN_ARROW:
                      if (!focusMenuItem(ev, opts.menuContentEl, opts, 1) && !opts.nestLevel) {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.LEFT_ARROW:
                      if (opts.nestLevel) {
                        opts.mdMenuCtrl.close();
                      } else {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.RIGHT_ARROW:
                      var parentMenu = $mdUtil.getClosest(ev.target, 'MD-MENU');
                      if (parentMenu && parentMenu != opts.parent[0]) {
                        ev.target.click();
                      } else {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                  }
                  if (handled) {
                    ev.preventDefault();
                    ev.stopImmediatePropagation();
                  }
                }
                function onBackdropClick(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  scope.$apply(function() {
                    opts.mdMenuCtrl.close(true, {closeAll: true});
                  });
                }
                function captureClickListener(e) {
                  var target = e.target;
                  do {
                    if (target == opts.menuContentEl[0])
                      return;
                    if ((hasAnyAttribute(target, ['ng-click', 'ng-href', 'ui-sref']) || target.nodeName == 'BUTTON' || target.nodeName == 'MD-BUTTON') && !hasAnyAttribute(target, ['md-prevent-menu-close'])) {
                      var closestMenu = $mdUtil.getClosest(target, 'MD-MENU');
                      if (!target.hasAttribute('disabled') && (!closestMenu || closestMenu == opts.parent[0])) {
                        close();
                      }
                      break;
                    }
                  } while (target = target.parentNode);
                  function close() {
                    scope.$apply(function() {
                      opts.mdMenuCtrl.close(true, {closeAll: true});
                    });
                  }
                  function hasAnyAttribute(target, attrs) {
                    if (!target)
                      return false;
                    for (var i = 0,
                        attr; attr = attrs[i]; ++i) {
                      var altForms = [attr, 'data-' + attr, 'x-' + attr];
                      for (var j = 0,
                          rawAttr; rawAttr = altForms[j]; ++j) {
                        if (target.hasAttribute(rawAttr)) {
                          return true;
                        }
                      }
                    }
                    return false;
                  }
                }
                opts.menuContentEl[0].addEventListener('click', captureClickListener, true);
                return function cleanupInteraction() {
                  element.removeClass('md-clickable');
                  opts.menuContentEl.off('keydown');
                  opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);
                };
              }
            }
            function focusMenuItem(e, menuEl, opts, direction) {
              var currentItem = $mdUtil.getClosest(e.target, 'MD-MENU-ITEM');
              var items = $mdUtil.nodesToArray(menuEl[0].children);
              var currentIndex = items.indexOf(currentItem);
              var didFocus;
              for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {
                var focusTarget = items[i].querySelector('.md-button');
                didFocus = attemptFocus(focusTarget);
                if (didFocus) {
                  break;
                }
              }
              return didFocus;
            }
            function attemptFocus(el) {
              if (el && el.getAttribute('tabindex') != -1) {
                el.focus();
                return ($document[0].activeElement == el);
              }
            }
            function detachElement(element, opts) {
              if (!opts.preserveElement) {
                if (toNode(element).parentNode === toNode(opts.parent)) {
                  toNode(opts.parent).removeChild(toNode(element));
                }
              } else {
                toNode(element).style.display = 'none';
              }
            }
            function calculateMenuPosition(el, opts) {
              var containerNode = el[0],
                  openMenuNode = el[0].firstElementChild,
                  openMenuNodeRect = openMenuNode.getBoundingClientRect(),
                  boundryNode = $document[0].body,
                  boundryNodeRect = boundryNode.getBoundingClientRect();
              var menuStyle = $window.getComputedStyle(openMenuNode);
              var originNode = opts.target[0].querySelector('[md-menu-origin]') || opts.target[0],
                  originNodeRect = originNode.getBoundingClientRect();
              var bounds = {
                left: boundryNodeRect.left + MENU_EDGE_MARGIN,
                top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
                bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
                right: boundryNodeRect.right - MENU_EDGE_MARGIN
              };
              var alignTarget,
                  alignTargetRect = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                  },
                  existingOffsets = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                  };
              var positionMode = opts.mdMenuCtrl.positionMode();
              if (positionMode.top == 'target' || positionMode.left == 'target' || positionMode.left == 'target-right') {
                alignTarget = firstVisibleChild();
                if (alignTarget) {
                  alignTarget = alignTarget.firstElementChild || alignTarget;
                  alignTarget = alignTarget.querySelector('[md-menu-align-target]') || alignTarget;
                  alignTargetRect = alignTarget.getBoundingClientRect();
                  existingOffsets = {
                    top: parseFloat(containerNode.style.top || 0),
                    left: parseFloat(containerNode.style.left || 0)
                  };
                }
              }
              var position = {};
              var transformOrigin = 'top ';
              switch (positionMode.top) {
                case 'target':
                  position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
                  break;
                case 'cascade':
                  position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
                  break;
                case 'bottom':
                  position.top = originNodeRect.top + originNodeRect.height;
                  break;
                default:
                  throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');
              }
              switch (positionMode.left) {
                case 'target':
                  position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
                  transformOrigin += 'left';
                  break;
                case 'target-right':
                  position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
                  transformOrigin += 'right';
                  break;
                case 'cascade':
                  var willFitRight = (originNodeRect.right + openMenuNodeRect.width) < bounds.right;
                  position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
                  transformOrigin += willFitRight ? 'left' : 'right';
                  break;
                case 'left':
                  position.left = originNodeRect.left;
                  transformOrigin += 'left';
                  break;
                default:
                  throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');
              }
              var offsets = opts.mdMenuCtrl.offsets();
              position.top += offsets.top;
              position.left += offsets.left;
              clamp(position);
              var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0)) / 100;
              var scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0)) / 100;
              return {
                top: Math.round(position.top),
                left: Math.round(position.left),
                transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : undefined,
                transformOrigin: transformOrigin
              };
              function clamp(pos) {
                pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
                pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
              }
              function firstVisibleChild() {
                for (var i = 0; i < openMenuNode.children.length; ++i) {
                  if ($window.getComputedStyle(openMenuNode.children[i]).display != 'none') {
                    return openMenuNode.children[i];
                  }
                }
              }
            }
          }
          function toNode(el) {
            if (el instanceof angular.element) {
              el = el[0];
            }
            return el;
          }
        }
        MenuProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').controller('MenuBarController', MenuBarController);
        var BOUND_MENU_METHODS = ['handleKeyDown', 'handleMenuHover', 'scheduleOpenHoveredMenu', 'cancelScheduledOpen'];
        function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {
          this.$element = $element;
          this.$attrs = $attrs;
          this.$mdConstant = $mdConstant;
          this.$mdUtil = $mdUtil;
          this.$document = $document;
          this.$scope = $scope;
          this.$rootScope = $rootScope;
          this.$timeout = $timeout;
          var self = this;
          angular.forEach(BOUND_MENU_METHODS, function(methodName) {
            self[methodName] = angular.bind(self, self[methodName]);
          });
        }
        MenuBarController.$inject = ["$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout"];
        MenuBarController.prototype.init = function() {
          var $element = this.$element;
          var $mdUtil = this.$mdUtil;
          var $scope = this.$scope;
          var self = this;
          var deregisterFns = [];
          $element.on('keydown', this.handleKeyDown);
          this.parentToolbar = $mdUtil.getClosest($element, 'MD-TOOLBAR');
          deregisterFns.push(this.$rootScope.$on('$mdMenuOpen', function(event, el) {
            if (self.getMenus().indexOf(el[0]) != -1) {
              $element[0].classList.add('md-open');
              el[0].classList.add('md-open');
              self.currentlyOpenMenu = el.controller('mdMenu');
              self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown);
              self.enableOpenOnHover();
            }
          }));
          deregisterFns.push(this.$rootScope.$on('$mdMenuClose', function(event, el, opts) {
            var rootMenus = self.getMenus();
            if (rootMenus.indexOf(el[0]) != -1) {
              $element[0].classList.remove('md-open');
              el[0].classList.remove('md-open');
            }
            if ($element[0].contains(el[0])) {
              var parentMenu = el[0];
              while (parentMenu && rootMenus.indexOf(parentMenu) == -1) {
                parentMenu = $mdUtil.getClosest(parentMenu, 'MD-MENU', true);
              }
              if (parentMenu) {
                if (!opts.skipFocus)
                  parentMenu.querySelector('button:not([disabled])').focus();
                self.currentlyOpenMenu = undefined;
                self.disableOpenOnHover();
                self.setKeyboardMode(true);
              }
            }
          }));
          $scope.$on('$destroy', function() {
            while (deregisterFns.length) {
              deregisterFns.shift()();
            }
          });
          this.setKeyboardMode(true);
        };
        MenuBarController.prototype.setKeyboardMode = function(enabled) {
          if (enabled)
            this.$element[0].classList.add('md-keyboard-mode');
          else
            this.$element[0].classList.remove('md-keyboard-mode');
        };
        MenuBarController.prototype.enableOpenOnHover = function() {
          if (this.openOnHoverEnabled)
            return;
          this.openOnHoverEnabled = true;
          var parentToolbar;
          if (parentToolbar = this.parentToolbar) {
            parentToolbar.dataset.mdRestoreStyle = parentToolbar.getAttribute('style');
            parentToolbar.style.position = 'relative';
            parentToolbar.style.zIndex = 100;
          }
          angular.element(this.getMenus()).on('mouseenter', this.handleMenuHover);
        };
        MenuBarController.prototype.handleMenuHover = function(e) {
          this.setKeyboardMode(false);
          if (this.openOnHoverEnabled) {
            this.scheduleOpenHoveredMenu(e);
          }
        };
        MenuBarController.prototype.disableOpenOnHover = function() {
          if (!this.openOnHoverEnabled)
            return;
          this.openOnHoverEnabled = false;
          var parentToolbar;
          if (parentToolbar = this.parentToolbar) {
            parentToolbar.setAttribute('style', parentToolbar.dataset.mdRestoreStyle || '');
          }
          angular.element(this.getMenus()).off('mouseenter', this.handleMenuHover);
        };
        MenuBarController.prototype.scheduleOpenHoveredMenu = function(e) {
          var menuEl = angular.element(e.currentTarget);
          var menuCtrl = menuEl.controller('mdMenu');
          this.setKeyboardMode(false);
          this.scheduleOpenMenu(menuCtrl);
        };
        MenuBarController.prototype.scheduleOpenMenu = function(menuCtrl) {
          var self = this;
          var $timeout = this.$timeout;
          if (menuCtrl != self.currentlyOpenMenu) {
            $timeout.cancel(self.pendingMenuOpen);
            self.pendingMenuOpen = $timeout(function() {
              self.pendingMenuOpen = undefined;
              if (self.currentlyOpenMenu) {
                self.currentlyOpenMenu.close(true, {closeAll: true});
              }
              menuCtrl.open();
            }, 200, false);
          }
        };
        MenuBarController.prototype.handleKeyDown = function(e) {
          var keyCodes = this.$mdConstant.KEY_CODE;
          var currentMenu = this.currentlyOpenMenu;
          var wasOpen = currentMenu && currentMenu.isOpen;
          this.setKeyboardMode(true);
          var handled,
              newMenu,
              newMenuCtrl;
          switch (e.keyCode) {
            case keyCodes.DOWN_ARROW:
              if (currentMenu) {
                currentMenu.focusMenuContainer();
              } else {
                this.openFocusedMenu();
              }
              handled = true;
              break;
            case keyCodes.UP_ARROW:
              currentMenu && currentMenu.close();
              handled = true;
              break;
            case keyCodes.LEFT_ARROW:
              newMenu = this.focusMenu(-1);
              if (wasOpen) {
                newMenuCtrl = angular.element(newMenu).controller('mdMenu');
                this.scheduleOpenMenu(newMenuCtrl);
              }
              handled = true;
              break;
            case keyCodes.RIGHT_ARROW:
              newMenu = this.focusMenu(+1);
              if (wasOpen) {
                newMenuCtrl = angular.element(newMenu).controller('mdMenu');
                this.scheduleOpenMenu(newMenuCtrl);
              }
              handled = true;
              break;
          }
          if (handled) {
            e && e.preventDefault && e.preventDefault();
            e && e.stopImmediatePropagation && e.stopImmediatePropagation();
          }
        };
        MenuBarController.prototype.focusMenu = function(direction) {
          var menus = this.getMenus();
          var focusedIndex = this.getFocusedMenuIndex();
          if (focusedIndex == -1) {
            focusedIndex = this.getOpenMenuIndex();
          }
          var changed = false;
          if (focusedIndex == -1) {
            focusedIndex = 0;
          } else if (direction < 0 && focusedIndex > 0 || direction > 0 && focusedIndex < menus.length - direction) {
            focusedIndex += direction;
            changed = true;
          }
          if (changed) {
            menus[focusedIndex].querySelector('button').focus();
            return menus[focusedIndex];
          }
        };
        MenuBarController.prototype.openFocusedMenu = function() {
          var menu = this.getFocusedMenu();
          menu && angular.element(menu).controller('mdMenu').open();
        };
        MenuBarController.prototype.getMenus = function() {
          var $element = this.$element;
          return this.$mdUtil.nodesToArray($element[0].children).filter(function(el) {
            return el.nodeName == 'MD-MENU';
          });
        };
        MenuBarController.prototype.getFocusedMenu = function() {
          return this.getMenus()[this.getFocusedMenuIndex()];
        };
        MenuBarController.prototype.getFocusedMenuIndex = function() {
          var $mdUtil = this.$mdUtil;
          var focusedEl = $mdUtil.getClosest(this.$document[0].activeElement, 'MD-MENU');
          if (!focusedEl)
            return -1;
          var focusedIndex = this.getMenus().indexOf(focusedEl);
          return focusedIndex;
        };
        MenuBarController.prototype.getOpenMenuIndex = function() {
          var menus = this.getMenus();
          for (var i = 0; i < menus.length; ++i) {
            if (menus[i].classList.contains('md-open'))
              return i;
          }
          return -1;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuBar', MenuBarDirective);
        function MenuBarDirective($mdUtil, $mdTheming) {
          return {
            restrict: 'E',
            require: 'mdMenuBar',
            controller: 'MenuBarController',
            compile: function compile(templateEl, templateAttrs) {
              if (!templateAttrs.ariaRole) {
                templateEl[0].setAttribute('role', 'menubar');
              }
              angular.forEach(templateEl[0].children, function(menuEl) {
                if (menuEl.nodeName == 'MD-MENU') {
                  if (!menuEl.hasAttribute('md-position-mode')) {
                    menuEl.setAttribute('md-position-mode', 'left bottom');
                    menuEl.querySelector('button,a').setAttribute('role', 'menuitem');
                  }
                  var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll('md-menu-content'));
                  angular.forEach(contentEls, function(contentEl) {
                    contentEl.classList.add('md-menu-bar-menu');
                    contentEl.classList.add('md-dense');
                    if (!contentEl.hasAttribute('width')) {
                      contentEl.setAttribute('width', 5);
                    }
                  });
                }
              });
              return function postLink(scope, el, attrs, ctrl) {
                $mdTheming(scope, el);
                ctrl.init();
              };
            }
          };
        }
        MenuBarDirective.$inject = ["$mdUtil", "$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuDivider', MenuDividerDirective);
        function MenuDividerDirective() {
          return {
            restrict: 'E',
            compile: function(templateEl, templateAttrs) {
              if (!templateAttrs.role) {
                templateEl[0].setAttribute('role', 'separator');
              }
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').controller('MenuItemController', MenuItemController);
        function MenuItemController($scope, $element, $attrs) {
          this.$element = $element;
          this.$attrs = $attrs;
          this.$scope = $scope;
        }
        MenuItemController.$inject = ["$scope", "$element", "$attrs"];
        MenuItemController.prototype.init = function(ngModel) {
          var $element = this.$element;
          var $attrs = this.$attrs;
          this.ngModel = ngModel;
          if ($attrs.type == 'checkbox' || $attrs.type == 'radio') {
            this.mode = $attrs.type;
            this.iconEl = $element[0].children[0];
            this.buttonEl = $element[0].children[1];
            if (ngModel) {
              this.initClickListeners();
            }
          }
        };
        MenuItemController.prototype.clearNgAria = function() {
          var el = this.$element[0];
          var clearAttrs = ['role', 'tabindex', 'aria-invalid', 'aria-checked'];
          angular.forEach(clearAttrs, function(attr) {
            el.removeAttribute(attr);
          });
        };
        MenuItemController.prototype.initClickListeners = function() {
          var self = this;
          var ngModel = this.ngModel;
          var $scope = this.$scope;
          var $attrs = this.$attrs;
          var $element = this.$element;
          var mode = this.mode;
          this.handleClick = angular.bind(this, this.handleClick);
          var icon = this.iconEl;
          var button = angular.element(this.buttonEl);
          var handleClick = this.handleClick;
          $attrs.$observe('disabled', setDisabled);
          setDisabled($attrs.disabled);
          ngModel.$render = function render() {
            self.clearNgAria();
            if (isSelected()) {
              icon.style.display = '';
              button.attr('aria-checked', 'true');
            } else {
              icon.style.display = 'none';
              button.attr('aria-checked', 'false');
            }
          };
          $scope.$$postDigest(ngModel.$render);
          function isSelected() {
            if (mode == 'radio') {
              var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
              return ngModel.$modelValue == val;
            } else {
              return ngModel.$modelValue;
            }
          }
          function setDisabled(disabled) {
            if (disabled) {
              button.off('click', handleClick);
            } else {
              button.on('click', handleClick);
            }
          }
        };
        MenuItemController.prototype.handleClick = function(e) {
          var mode = this.mode;
          var ngModel = this.ngModel;
          var $attrs = this.$attrs;
          var newVal;
          if (mode == 'checkbox') {
            newVal = !ngModel.$modelValue;
          } else if (mode == 'radio') {
            newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value;
          }
          ngModel.$setViewValue(newVal);
          ngModel.$render();
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuItem', MenuItemDirective);
        function MenuItemDirective() {
          return {
            require: ['mdMenuItem', '?ngModel'],
            priority: 210,
            compile: function(templateEl, templateAttrs) {
              if (templateAttrs.type == 'checkbox' || templateAttrs.type == 'radio') {
                var text = templateEl[0].textContent;
                var buttonEl = angular.element('<md-button type="button"></md-button>');
                buttonEl.html(text);
                buttonEl.attr('tabindex', '0');
                templateEl.html('');
                templateEl.append(angular.element('<md-icon md-svg-icon="check"></md-icon>'));
                templateEl.append(buttonEl);
                templateEl[0].classList.add('md-indent');
                setDefault('role', (templateAttrs.type == 'checkbox') ? 'menuitemcheckbox' : 'menuitemradio', buttonEl);
                angular.forEach(['ng-disabled'], moveAttrToButton);
              } else {
                setDefault('role', 'menuitem', templateEl[0].querySelector('md-button,button,a'));
              }
              return function(scope, el, attrs, ctrls) {
                var ctrl = ctrls[0];
                var ngModel = ctrls[1];
                ctrl.init(ngModel);
              };
              function setDefault(attr, val, el) {
                el = el || templateEl;
                if (el instanceof angular.element) {
                  el = el[0];
                }
                if (!el.hasAttribute(attr)) {
                  el.setAttribute(attr, val);
                }
              }
              function moveAttrToButton(attr) {
                if (templateEl[0].hasAttribute(attr)) {
                  var val = templateEl[0].getAttribute(attr);
                  buttonEl[0].setAttribute(attr, val);
                  templateEl[0].removeAttribute(attr);
                }
              }
            },
            controller: 'MenuItemController'
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTab', MdTab);
        function MdTab() {
          return {
            require: '^?mdTabs',
            terminal: true,
            compile: function(element, attr) {
              var label = firstChild(element, 'md-tab-label'),
                  body = firstChild(element, 'md-tab-body');
              if (label.length == 0) {
                label = angular.element('<md-tab-label></md-tab-label>');
                if (attr.label)
                  label.text(attr.label);
                else
                  label.append(element.contents());
                if (body.length == 0) {
                  var contents = element.contents().detach();
                  body = angular.element('<md-tab-body></md-tab-body>');
                  body.append(contents);
                }
              }
              element.append(label);
              if (body.html())
                element.append(body);
              return postLink;
            },
            scope: {
              active: '=?mdActive',
              disabled: '=?ngDisabled',
              select: '&?mdOnSelect',
              deselect: '&?mdOnDeselect'
            }
          };
          function postLink(scope, element, attr, ctrl) {
            if (!ctrl)
              return;
            var index = ctrl.getTabElementIndex(element),
                body = firstChild(element, 'md-tab-body').remove(),
                label = firstChild(element, 'md-tab-label').remove(),
                data = ctrl.insertTab({
                  scope: scope,
                  parent: scope.$parent,
                  index: index,
                  element: element,
                  template: body.html(),
                  label: label.html()
                }, index);
            scope.select = scope.select || angular.noop;
            scope.deselect = scope.deselect || angular.noop;
            scope.$watch('active', function(active) {
              if (active)
                ctrl.select(data.getIndex());
            });
            scope.$watch('disabled', function() {
              ctrl.refreshIndex();
            });
            scope.$watch(function() {
              return ctrl.getTabElementIndex(element);
            }, function(newIndex) {
              data.index = newIndex;
              ctrl.updateTabOrder();
            });
            scope.$on('$destroy', function() {
              ctrl.removeTab(data);
            });
          }
          function firstChild(element, tagName) {
            var children = element[0].children;
            for (var i = 0,
                len = children.length; i < len; i++) {
              var child = children[i];
              if (child.tagName === tagName.toUpperCase())
                return angular.element(child);
            }
            return angular.element();
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabItem', MdTabItem);
        function MdTabItem() {
          return {
            require: '^?mdTabs',
            link: function link(scope, element, attr, ctrl) {
              if (!ctrl)
                return;
              ctrl.attachRipple(scope, element);
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabLabel', MdTabLabel);
        function MdTabLabel() {
          return {terminal: true};
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabScroll', MdTabScroll);
        function MdTabScroll($parse) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr.mdTabScroll, null, true);
              return function ngEventHandler(scope, element) {
                element.on('mousewheel', function(event) {
                  scope.$apply(function() {
                    fn(scope, {$event: event});
                  });
                });
              };
            }
          };
        }
        MdTabScroll.$inject = ["$parse"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').controller('MdTabsController', MdTabsController);
        function MdTabsController($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming) {
          var ctrl = this,
              locked = false,
              elements = getElements(),
              queue = [],
              destroyed = false,
              loaded = false;
          defineOneWayBinding('stretchTabs', handleStretchTabs);
          defineProperty('focusIndex', handleFocusIndexChange, ctrl.selectedIndex || 0);
          defineProperty('offsetLeft', handleOffsetChange, 0);
          defineProperty('hasContent', handleHasContent, false);
          defineProperty('maxTabWidth', handleMaxTabWidth, getMaxTabWidth());
          defineProperty('shouldPaginate', handleShouldPaginate, false);
          defineBooleanAttribute('noInkBar', handleInkBar);
          defineBooleanAttribute('dynamicHeight', handleDynamicHeight);
          defineBooleanAttribute('noPagination');
          defineBooleanAttribute('swipeContent');
          defineBooleanAttribute('noDisconnect');
          defineBooleanAttribute('autoselect');
          defineBooleanAttribute('centerTabs', handleCenterTabs, false);
          defineBooleanAttribute('enableDisconnect');
          ctrl.scope = $scope;
          ctrl.parent = $scope.$parent;
          ctrl.tabs = [];
          ctrl.lastSelectedIndex = null;
          ctrl.hasFocus = false;
          ctrl.lastClick = true;
          ctrl.shouldCenterTabs = shouldCenterTabs();
          ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100);
          ctrl.redirectFocus = redirectFocus;
          ctrl.attachRipple = attachRipple;
          ctrl.insertTab = insertTab;
          ctrl.removeTab = removeTab;
          ctrl.select = select;
          ctrl.scroll = scroll;
          ctrl.nextPage = nextPage;
          ctrl.previousPage = previousPage;
          ctrl.keydown = keydown;
          ctrl.canPageForward = canPageForward;
          ctrl.canPageBack = canPageBack;
          ctrl.refreshIndex = refreshIndex;
          ctrl.incrementIndex = incrementIndex;
          ctrl.getTabElementIndex = getTabElementIndex;
          ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);
          ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);
          init();
          function init() {
            ctrl.selectedIndex = ctrl.selectedIndex || 0;
            compileTemplate();
            configureWatchers();
            bindEvents();
            $mdTheming($element);
            $mdUtil.nextTick(function() {
              updateHeightFromContent();
              adjustOffset();
              updateInkBarStyles();
              ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
              loaded = true;
              updatePagination();
            });
          }
          function compileTemplate() {
            var template = $attrs.$mdTabsTemplate,
                element = angular.element(elements.data);
            element.html(template);
            $compile(element.contents())(ctrl.parent);
            delete $attrs.$mdTabsTemplate;
          }
          function bindEvents() {
            angular.element($window).on('resize', handleWindowResize);
            $scope.$on('$destroy', cleanup);
          }
          function configureWatchers() {
            $scope.$watch('$mdTabsCtrl.selectedIndex', handleSelectedIndexChange);
          }
          function defineOneWayBinding(key, handler) {
            var attr = $attrs.$normalize('md-' + key);
            if (handler)
              defineProperty(key, handler);
            $attrs.$observe(attr, function(newValue) {
              ctrl[key] = newValue;
            });
          }
          function defineBooleanAttribute(key, handler) {
            var attr = $attrs.$normalize('md-' + key);
            if (handler)
              defineProperty(key, handler);
            if ($attrs.hasOwnProperty(attr))
              updateValue($attrs[attr]);
            $attrs.$observe(attr, updateValue);
            function updateValue(newValue) {
              ctrl[key] = newValue !== 'false';
            }
          }
          function cleanup() {
            destroyed = true;
            angular.element($window).off('resize', handleWindowResize);
          }
          function handleStretchTabs(stretchTabs) {
            angular.element(elements.wrapper).toggleClass('md-stretch-tabs', shouldStretchTabs());
            updateInkBarStyles();
          }
          function handleCenterTabs(newValue) {
            ctrl.shouldCenterTabs = shouldCenterTabs();
          }
          function handleMaxTabWidth(newWidth, oldWidth) {
            if (newWidth !== oldWidth) {
              $mdUtil.nextTick(ctrl.updateInkBarStyles);
            }
          }
          function handleShouldPaginate(newValue, oldValue) {
            if (newValue !== oldValue) {
              ctrl.maxTabWidth = getMaxTabWidth();
              ctrl.shouldCenterTabs = shouldCenterTabs();
              $mdUtil.nextTick(function() {
                ctrl.maxTabWidth = getMaxTabWidth();
                adjustOffset(ctrl.selectedIndex);
              });
            }
          }
          function handleHasContent(hasContent) {
            $element[hasContent ? 'removeClass' : 'addClass']('md-no-tab-content');
          }
          function handleOffsetChange(left) {
            var newValue = ctrl.shouldCenterTabs ? '' : '-' + left + 'px';
            angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, 'translate3d(' + newValue + ', 0, 0)');
            $scope.$broadcast('$mdTabsPaginationChanged');
          }
          function handleFocusIndexChange(newIndex, oldIndex) {
            if (newIndex === oldIndex)
              return;
            if (!elements.tabs[newIndex])
              return;
            adjustOffset();
            redirectFocus();
          }
          function handleSelectedIndexChange(newValue, oldValue) {
            if (newValue === oldValue)
              return;
            ctrl.selectedIndex = getNearestSafeIndex(newValue);
            ctrl.lastSelectedIndex = oldValue;
            ctrl.updateInkBarStyles();
            updateHeightFromContent();
            adjustOffset(newValue);
            $scope.$broadcast('$mdTabsChanged');
            ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();
            ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();
          }
          function getTabElementIndex(tabEl) {
            var tabs = $element[0].getElementsByTagName('md-tab');
            return Array.prototype.indexOf.call(tabs, tabEl[0]);
          }
          function handleResizeWhenVisible() {
            if (handleResizeWhenVisible.watcher)
              return;
            handleResizeWhenVisible.watcher = $scope.$watch(function() {
              $mdUtil.nextTick(function() {
                if (!handleResizeWhenVisible.watcher)
                  return;
                if ($element.prop('offsetParent')) {
                  handleResizeWhenVisible.watcher();
                  handleResizeWhenVisible.watcher = null;
                  handleWindowResize();
                }
              }, false);
            });
          }
          function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.LEFT_ARROW:
                event.preventDefault();
                incrementIndex(-1, true);
                break;
              case $mdConstant.KEY_CODE.RIGHT_ARROW:
                event.preventDefault();
                incrementIndex(1, true);
                break;
              case $mdConstant.KEY_CODE.SPACE:
              case $mdConstant.KEY_CODE.ENTER:
                event.preventDefault();
                if (!locked)
                  ctrl.selectedIndex = ctrl.focusIndex;
                break;
            }
            ctrl.lastClick = false;
          }
          function select(index) {
            if (!locked)
              ctrl.focusIndex = ctrl.selectedIndex = index;
            ctrl.lastClick = true;
            $mdUtil.nextTick(function() {
              ctrl.tabs[index].element.triggerHandler('click');
            }, false);
          }
          function scroll(event) {
            if (!ctrl.shouldPaginate)
              return;
            event.preventDefault();
            ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);
          }
          function nextPage() {
            var viewportWidth = elements.canvas.clientWidth,
                totalWidth = viewportWidth + ctrl.offsetLeft,
                i,
                tab;
            for (i = 0; i < elements.tabs.length; i++) {
              tab = elements.tabs[i];
              if (tab.offsetLeft + tab.offsetWidth > totalWidth)
                break;
            }
            ctrl.offsetLeft = fixOffset(tab.offsetLeft);
          }
          function previousPage() {
            var i,
                tab;
            for (i = 0; i < elements.tabs.length; i++) {
              tab = elements.tabs[i];
              if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft)
                break;
            }
            ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);
          }
          function handleWindowResize() {
            ctrl.lastSelectedIndex = ctrl.selectedIndex;
            ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
            $mdUtil.nextTick(function() {
              ctrl.updateInkBarStyles();
              updatePagination();
            });
          }
          function handleInkBar(hide) {
            angular.element(elements.inkBar).toggleClass('ng-hide', hide);
          }
          function handleDynamicHeight(value) {
            $element.toggleClass('md-dynamic-height', value);
          }
          function removeTab(tabData) {
            if (destroyed)
              return;
            var selectedIndex = ctrl.selectedIndex,
                tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];
            refreshIndex();
            if (ctrl.selectedIndex === selectedIndex) {
              tab.scope.deselect();
              ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
            }
            $mdUtil.nextTick(function() {
              updatePagination();
              ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
            });
          }
          function insertTab(tabData, index) {
            var hasLoaded = loaded;
            var proto = {
              getIndex: function() {
                return ctrl.tabs.indexOf(tab);
              },
              isActive: function() {
                return this.getIndex() === ctrl.selectedIndex;
              },
              isLeft: function() {
                return this.getIndex() < ctrl.selectedIndex;
              },
              isRight: function() {
                return this.getIndex() > ctrl.selectedIndex;
              },
              shouldRender: function() {
                return !ctrl.noDisconnect || this.isActive();
              },
              hasFocus: function() {
                return !ctrl.lastClick && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;
              },
              id: $mdUtil.nextUid()
            },
                tab = angular.extend(proto, tabData);
            if (angular.isDefined(index)) {
              ctrl.tabs.splice(index, 0, tab);
            } else {
              ctrl.tabs.push(tab);
            }
            processQueue();
            updateHasContent();
            $mdUtil.nextTick(function() {
              updatePagination();
              if (hasLoaded && ctrl.autoselect)
                $mdUtil.nextTick(function() {
                  $mdUtil.nextTick(function() {
                    select(ctrl.tabs.indexOf(tab));
                  });
                });
            });
            return tab;
          }
          function getElements() {
            var elements = {};
            elements.wrapper = $element[0].getElementsByTagName('md-tabs-wrapper')[0];
            elements.data = $element[0].getElementsByTagName('md-tab-data')[0];
            elements.canvas = elements.wrapper.getElementsByTagName('md-tabs-canvas')[0];
            elements.paging = elements.canvas.getElementsByTagName('md-pagination-wrapper')[0];
            elements.tabs = elements.paging.getElementsByTagName('md-tab-item');
            elements.dummies = elements.canvas.getElementsByTagName('md-dummy-tab');
            elements.inkBar = elements.paging.getElementsByTagName('md-ink-bar')[0];
            elements.contentsWrapper = $element[0].getElementsByTagName('md-tabs-content-wrapper')[0];
            elements.contents = elements.contentsWrapper.getElementsByTagName('md-tab-content');
            return elements;
          }
          function canPageBack() {
            return ctrl.offsetLeft > 0;
          }
          function canPageForward() {
            var lastTab = elements.tabs[elements.tabs.length - 1];
            return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;
          }
          function shouldStretchTabs() {
            switch (ctrl.stretchTabs) {
              case 'always':
                return true;
              case 'never':
                return false;
              default:
                return !ctrl.shouldPaginate && $window.matchMedia('(max-width: 600px)').matches;
            }
          }
          function shouldCenterTabs() {
            return ctrl.centerTabs && !ctrl.shouldPaginate;
          }
          function shouldPaginate() {
            if (ctrl.noPagination || !loaded)
              return false;
            var canvasWidth = $element.prop('clientWidth');
            angular.forEach(getElements().dummies, function(tab) {
              canvasWidth -= tab.offsetWidth;
            });
            return canvasWidth < 0;
          }
          function getNearestSafeIndex(newIndex) {
            if (newIndex === -1)
              return -1;
            var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex),
                i,
                tab;
            for (i = 0; i <= maxOffset; i++) {
              tab = ctrl.tabs[newIndex + i];
              if (tab && (tab.scope.disabled !== true))
                return tab.getIndex();
              tab = ctrl.tabs[newIndex - i];
              if (tab && (tab.scope.disabled !== true))
                return tab.getIndex();
            }
            return newIndex;
          }
          function defineProperty(key, handler, value) {
            Object.defineProperty(ctrl, key, {
              get: function() {
                return value;
              },
              set: function(newValue) {
                var oldValue = value;
                value = newValue;
                handler && handler(newValue, oldValue);
              }
            });
          }
          function updatePagination() {
            if (!shouldStretchTabs())
              updatePagingWidth();
            ctrl.maxTabWidth = getMaxTabWidth();
            ctrl.shouldPaginate = shouldPaginate();
          }
          function updatePagingWidth() {
            var width = 1;
            angular.forEach(getElements().dummies, function(element) {
              width += Math.ceil(element.offsetWidth);
            });
            angular.element(elements.paging).css('width', width + 'px');
          }
          function getMaxTabWidth() {
            return $element.prop('clientWidth');
          }
          function updateTabOrder() {
            var selectedItem = ctrl.tabs[ctrl.selectedIndex],
                focusItem = ctrl.tabs[ctrl.focusIndex];
            ctrl.tabs = ctrl.tabs.sort(function(a, b) {
              return a.index - b.index;
            });
            ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem);
            ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);
          }
          function incrementIndex(inc, focus) {
            var newIndex,
                key = focus ? 'focusIndex' : 'selectedIndex',
                index = ctrl[key];
            for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc) {}
            if (ctrl.tabs[newIndex]) {
              ctrl[key] = newIndex;
            }
          }
          function redirectFocus() {
            getElements().dummies[ctrl.focusIndex].focus();
          }
          function adjustOffset(index) {
            if (index == null)
              index = ctrl.focusIndex;
            if (!elements.tabs[index])
              return;
            if (ctrl.shouldCenterTabs)
              return;
            var tab = elements.tabs[index],
                left = tab.offsetLeft,
                right = tab.offsetWidth + left;
            ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + 32 * 2));
            ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));
          }
          function processQueue() {
            queue.forEach(function(func) {
              $mdUtil.nextTick(func);
            });
            queue = [];
          }
          function updateHasContent() {
            var hasContent = false;
            angular.forEach(ctrl.tabs, function(tab) {
              if (tab.template)
                hasContent = true;
            });
            ctrl.hasContent = hasContent;
          }
          function refreshIndex() {
            ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex);
            ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);
          }
          function updateHeightFromContent() {
            if (!ctrl.dynamicHeight)
              return $element.css('height', '');
            if (!ctrl.tabs.length)
              return queue.push(updateHeightFromContent);
            var tabContent = elements.contents[ctrl.selectedIndex],
                contentHeight = tabContent ? tabContent.offsetHeight : 0,
                tabsHeight = elements.wrapper.offsetHeight,
                newHeight = contentHeight + tabsHeight,
                currentHeight = $element.prop('clientHeight');
            if (currentHeight === newHeight)
              return;
            if ($element.attr('md-align-tabs') === 'bottom') {
              currentHeight -= tabsHeight;
              newHeight -= tabsHeight;
              if ($element.attr('md-border-bottom') !== undefined)
                ++currentHeight;
            }
            locked = true;
            var fromHeight = {height: currentHeight + 'px'},
                toHeight = {height: newHeight + 'px'};
            $element.css(fromHeight);
            $animateCss($element, {
              from: fromHeight,
              to: toHeight,
              easing: 'cubic-bezier(0.35, 0, 0.25, 1)',
              duration: 0.5
            }).start().done(function() {
              $element.css({
                transition: 'none',
                height: ''
              });
              $mdUtil.nextTick(function() {
                $element.css('transition', '');
              });
              locked = false;
            });
          }
          function updateInkBarStyles() {
            if (!elements.tabs[ctrl.selectedIndex]) {
              angular.element(elements.inkBar).css({
                left: 'auto',
                right: 'auto'
              });
              return;
            }
            if (!ctrl.tabs.length)
              return queue.push(ctrl.updateInkBarStyles);
            if (!$element.prop('offsetParent'))
              return handleResizeWhenVisible();
            var index = ctrl.selectedIndex,
                totalWidth = elements.paging.offsetWidth,
                tab = elements.tabs[index],
                left = tab.offsetLeft,
                right = totalWidth - left - tab.offsetWidth,
                tabWidth;
            if (ctrl.shouldCenterTabs) {
              tabWidth = Array.prototype.slice.call(elements.tabs).reduce(function(value, element) {
                return value + element.offsetWidth;
              }, 0);
              if (totalWidth > tabWidth)
                $mdUtil.nextTick(updateInkBarStyles, false);
            }
            updateInkBarClassName();
            angular.element(elements.inkBar).css({
              left: left + 'px',
              right: right + 'px'
            });
          }
          function updateInkBarClassName() {
            var newIndex = ctrl.selectedIndex,
                oldIndex = ctrl.lastSelectedIndex,
                ink = angular.element(elements.inkBar);
            if (!angular.isNumber(oldIndex))
              return;
            ink.toggleClass('md-left', newIndex < oldIndex).toggleClass('md-right', newIndex > oldIndex);
          }
          function fixOffset(value) {
            if (!elements.tabs.length || !ctrl.shouldPaginate)
              return 0;
            var lastTab = elements.tabs[elements.tabs.length - 1],
                totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
            value = Math.max(0, value);
            value = Math.min(totalWidth - elements.canvas.clientWidth, value);
            return value;
          }
          function attachRipple(scope, element) {
            var options = {colorElement: angular.element(elements.inkBar)};
            $mdTabInkRipple.attach(scope, element, options);
          }
        }
        MdTabsController.$inject = ["$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabs', MdTabs);
        function MdTabs() {
          return {
            scope: {selectedIndex: '=?mdSelected'},
            template: function(element, attr) {
              attr["$mdTabsTemplate"] = element.html();
              return '' + '<md-tabs-wrapper> ' + '<md-tab-data></md-tab-data> ' + '<md-prev-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Previous Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ' + 'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.previousPage()"> ' + '<md-icon md-svg-icon="md-tabs-arrow"></md-icon> ' + '</md-prev-button> ' + '<md-next-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Next Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ' + 'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.nextPage()"> ' + '<md-icon md-svg-icon="md-tabs-arrow"></md-icon> ' + '</md-next-button> ' + '<md-tabs-canvas ' + 'tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" ' + 'aria-activedescendant="tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}" ' + 'ng-focus="$mdTabsCtrl.redirectFocus()" ' + 'ng-class="{ ' + '\'md-paginated\': $mdTabsCtrl.shouldPaginate, ' + '\'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs ' + '}" ' + 'ng-keydown="$mdTabsCtrl.keydown($event)" ' + 'role="tablist"> ' + '<md-pagination-wrapper ' + 'ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ' + 'md-tab-scroll="$mdTabsCtrl.scroll($event)"> ' + '<md-tab-item ' + 'tabindex="-1" ' + 'class="md-tab" ' + 'style="max-width: {{ $mdTabsCtrl.maxTabWidth + \'px\' }}" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'role="tab" ' + 'aria-controls="tab-content-{{::tab.id}}" ' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-click="$mdTabsCtrl.select(tab.getIndex())" ' + 'ng-class="{ ' + '\'md-active\':    tab.isActive(), ' + '\'md-focused\':   tab.hasFocus(), ' + '\'md-disabled\':  tab.scope.disabled ' + '}" ' + 'ng-disabled="tab.scope.disabled" ' + 'md-swipe-left="$mdTabsCtrl.nextPage()" ' + 'md-swipe-right="$mdTabsCtrl.previousPage()" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-tab-item> ' + '<md-ink-bar></md-ink-bar> ' + '</md-pagination-wrapper> ' + '<div class="md-visually-hidden md-dummy-wrapper"> ' + '<md-dummy-tab ' + 'class="md-tab" ' + 'tabindex="-1" ' + 'id="tab-item-{{::tab.id}}" ' + 'role="tab" ' + 'aria-controls="tab-content-{{::tab.id}}" ' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-focus="$mdTabsCtrl.hasFocus = true" ' + 'ng-blur="$mdTabsCtrl.hasFocus = false" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-dummy-tab> ' + '</div> ' + '</md-tabs-canvas> ' + '</md-tabs-wrapper> ' + '<md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0"> ' + '<md-tab-content ' + 'id="tab-content-{{::tab.id}}" ' + 'role="tabpanel" ' + 'aria-labelledby="tab-item-{{::tab.id}}" ' + 'md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" ' + 'md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ' + 'ng-if="$mdTabsCtrl.hasContent" ' + 'ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ' + 'ng-class="{ ' + '\'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, ' + '\'md-active\':        tab.isActive(), ' + '\'md-left\':          tab.isLeft(), ' + '\'md-right\':         tab.isRight(), ' + '\'md-no-scroll\':     $mdTabsCtrl.dynamicHeight ' + '}"> ' + '<div ' + 'md-tabs-template="::tab.template" ' + 'md-connected-if="tab.isActive()" ' + 'md-scope="::tab.parent" ' + 'ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> ' + '</md-tab-content> ' + '</md-tabs-content-wrapper>';
            },
            controller: 'MdTabsController',
            controllerAs: '$mdTabsCtrl',
            bindToController: true
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabsTemplate', MdTabsTemplate);
        function MdTabsTemplate($compile, $mdUtil) {
          return {
            restrict: 'A',
            link: link,
            scope: {
              template: '=mdTabsTemplate',
              connected: '=?mdConnectedIf',
              compileScope: '=mdScope'
            },
            require: '^?mdTabs'
          };
          function link(scope, element, attr, ctrl) {
            if (!ctrl)
              return;
            var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;
            element.html(scope.template);
            $compile(element.contents())(compileScope);
            element.on('DOMSubtreeModified', function() {
              ctrl.updatePagination();
              ctrl.updateInkBarStyles();
            });
            return $mdUtil.nextTick(handleScope);
            function handleScope() {
              scope.$watch('connected', function(value) {
                value === false ? disconnect() : reconnect();
              });
              scope.$on('$destroy', reconnect);
            }
            function disconnect() {
              if (ctrl.enableDisconnect)
                $mdUtil.disconnectScope(compileScope);
            }
            function reconnect() {
              if (ctrl.enableDisconnect)
                $mdUtil.reconnectScope(compileScope);
            }
          }
        }
        MdTabsTemplate.$inject = ["$compile", "$mdUtil"];
      })();
      (function() {
        angular.module("material.core").constant("$MD_THEME_CSS", "md-autocomplete.md-THEME_NAME-theme {  background: '{{background-50}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions-container.md-THEME_NAME-theme {  background: '{{background-50}}'; }  .md-autocomplete-suggestions-container.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }md-backdrop {  background-color: '{{background-900-0.0}}'; }  md-backdrop.md-opaque.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]):hover,.md-button.md-THEME_NAME-theme:not([disabled]):hover {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]).md-focused {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover,.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {  background-color: transparent; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab md-icon,  .md-button.md-THEME_NAME-theme.md-fab md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-primary,.md-button.md-THEME_NAME-theme.md-primary {  color: '{{primary-color}}'; }  a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab,  .md-button.md-THEME_NAME-theme.md-primary.md-raised,  .md-button.md-THEME_NAME-theme.md-primary.md-fab {    color: '{{primary-contrast}}';    background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {      color: '{{primary-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {      background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {      background-color: '{{primary-600}}'; }  a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {    color: '{{primary-color}}'; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-raised,.md-button.md-THEME_NAME-theme.md-raised {  color: '{{background-900}}';  background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) .md-icon,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) .md-icon {    color: '{{background-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {    background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {    background-color: '{{background-200}}'; }a.md-button.md-THEME_NAME-theme.md-warn,.md-button.md-THEME_NAME-theme.md-warn {  color: '{{warn-color}}'; }  a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab,  .md-button.md-THEME_NAME-theme.md-warn.md-raised,  .md-button.md-THEME_NAME-theme.md-warn.md-fab {    color: '{{warn-contrast}}';    background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {      color: '{{warn-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {      background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {      background-color: '{{warn-700}}'; }  a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {    color: '{{warn-color}}'; }a.md-button.md-THEME_NAME-theme.md-accent,.md-button.md-THEME_NAME-theme.md-accent {  color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab,  .md-button.md-THEME_NAME-theme.md-accent.md-raised,  .md-button.md-THEME_NAME-theme.md-accent.md-fab {    color: '{{accent-contrast}}';    background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {      background-color: '{{accent-700}}'; }  a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {    color: '{{accent-color}}'; }a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled] {  color: '{{foreground-3}}' !important;  cursor: default; }  a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,  .md-button.md-THEME_NAME-theme[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {    color: '{{foreground-3}}'; }a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled] {  background-color: '{{foreground-4}}'; }a.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme[disabled] {  background-color: transparent; }md-card.md-THEME_NAME-theme {  background-color: '{{background-color}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }  md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon {    color: '{{background-color}}';    background-color: '{{foreground-3}}'; }  md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead {    color: '{{foreground-2}}'; }  md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead {    color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{accent-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: '{{foreground-3}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{background-300}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }md-chips.md-THEME_NAME-theme .md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-content.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }/** Theme styles for mdCalendar. */.md-calendar.md-THEME_NAME-theme {  color: '{{foreground-1}}'; }  .md-calendar.md-THEME_NAME-theme tr:last-child td {    border-bottom-color: '{{background-200}}'; }.md-THEME_NAME-theme .md-calendar-day-header {  background: '{{background-hue-1}}';  color: '{{foreground-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator {  border: 1px solid '{{primary-500}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled {  color: '{{primary-500-0.6}}'; }.md-THEME_NAME-theme .md-calendar-date.md-focus .md-calendar-date-selection-indicator {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator {  background: '{{primary-500}}';  color: '{{primary-500-contrast}}';  border-color: transparent; }.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled {  color: '{{foreground-3}}'; }/** Theme styles for mdDatepicker. */md-datepicker.md-THEME_NAME-theme {  background: '{{background-color}}'; }.md-THEME_NAME-theme .md-datepicker-input {  color: '{{background-contrast}}';  background: '{{background-color}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder, .md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }.md-THEME_NAME-theme .md-datepicker-input-container {  border-bottom-color: '{{background-300}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused {    border-bottom-color: '{{primary-500}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid {    border-bottom-color: '{{warn-A700}}'; }.md-THEME_NAME-theme .md-datepicker-calendar-pane {  border-color: '{{background-300}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle {  border-top-color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button:hover .md-datepicker-expand-triangle {  border-top-color: '{{foreground-2}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon {  fill: '{{primary-500}}'; }.md-THEME_NAME-theme .md-datepicker-calendar,.md-THEME_NAME-theme .md-datepicker-input-mask-opaque {  background: '{{background-color}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-color}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions, md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }.layout-row > md-divider.md-THEME_NAME-theme {  border-right-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label,md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme ng-messages :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [ng-messages] :not(.md-char-counter),md-input-container.md-THEME_NAME-theme ng-message :not(.md-char-counter), md-input-container.md-THEME_NAME-theme data-ng-message :not(.md-char-counter), md-input-container.md-THEME_NAME-theme x-ng-message :not(.md-char-counter),md-input-container.md-THEME_NAME-theme [ng-message] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [data-ng-message] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [x-ng-message] :not(.md-char-counter),md-input-container.md-THEME_NAME-theme [ng-message-exp] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [data-ng-message-exp] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [x-ng-message-exp] :not(.md-char-counter) {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message,md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message],md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message-exp],md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled],md-input-container.md-THEME_NAME-theme .md-input [disabled] {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item > .md-avatar-icon {  background-color: '{{foreground-3}}';  color: '{{background-color}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{foreground-4}}'; }md-menu-bar.md-THEME_NAME-theme > button.md-button {  color: '{{foreground-2}}';  border-radius: 2px; }md-menu-bar.md-THEME_NAME-theme md-menu.md-open > button, md-menu-bar.md-THEME_NAME-theme md-menu > button:focus {  outline: none;  background: '{{background-200}}'; }md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover > button {  background-color: '{{ background-500-0.2}}'; }md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus {  background: transparent; }md-menu-content.md-THEME_NAME-theme .md-menu > .md-button:after {  color: '{{foreground-2}}'; }md-menu-content.md-THEME_NAME-theme .md-menu.md-open > .md-button {  background-color: '{{ background-500-0.2}}'; }md-toolbar.md-THEME_NAME-theme.md-menu-toolbar {  background-color: '{{background-color}}';  color: '{{foreground-1}}'; }  md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler {    background-color: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon {      color: '{{primary-contrast}}'; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient(\"{{warn-100}}\" 0%, \"{{warn-100}}\" 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient(\"{{accent-100}}\" 0%, \"{{accent-100}}\" 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled],md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple {  color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple, md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple {  color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple {  color: '{{warn-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  border-bottom-color: transparent;  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-select.md-THEME_NAME-theme .md-select-value {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-value {  color: '{{warn-A700}}' !important;  border-bottom-color: '{{warn-A700}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-option[disabled] {  color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: '{{primary-500}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: '{{primary-600}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: '{{accent-500}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: '{{accent-600}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([disabled]):not([selected]) {  background: '{{background-200}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-ink-ripple {  color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple {  color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple {  color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled], md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon, md-tabs.md-THEME_NAME-theme .md-tab.md-focused, md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toast.md-THEME_NAME-theme .md-toast-content {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-toast-content .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button:not(.md-raised) {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-content {    background-color: '{{foreground-2}}'; }");
      })();
    })(window, window.angular);
    ;
    window.ngMaterial = {version: {full: "1.0.2"}};
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:angular-material@1.0.2/index", ["npm:angular@1.5.0-rc.1", "npm:angular-animate@1.5.0-rc.1", "npm:angular-aria@1.5.0-rc.1", "npm:angular-material@1.0.2/angular-material"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:angular@1.5.0-rc.1');
  $__require('npm:angular-animate@1.5.0-rc.1');
  $__require('npm:angular-aria@1.5.0-rc.1');
  $__require('npm:angular-material@1.0.2/angular-material');
  module.exports = 'ngMaterial';
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-material@1.0.2", ["npm:angular-material@1.0.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-material@1.0.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2", ["npm:process@0.11.2/browser"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.11.2/browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index", ["npm:process@0.11.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.2');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2", ["github:jspm/nodelibs-process@0.1.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-ui-router@1.0.0-alpha0/release/angular-ui-router", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
      else if (typeof define === 'function' && define.amd)
        define([], factory);
      else if (typeof exports === 'object')
        exports["ui.router"] = factory();
      else
        root["ui.router"] = factory();
    })(this, function() {
      return (function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
          module.loaded = true;
          return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      })([function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(1);
      }, function(module, exports, __webpack_require__) {
        var common = __webpack_require__(2);
        exports.common = common;
        var params = __webpack_require__(36);
        exports.params = params;
        var path = __webpack_require__(15);
        exports.path = path;
        var resolve = __webpack_require__(17);
        exports.resolve = resolve;
        var state = __webpack_require__(12);
        exports.state = state;
        var transition = __webpack_require__(9);
        exports.transition = transition;
        var url = __webpack_require__(34);
        exports.url = url;
        var view = __webpack_require__(49);
        exports.view = view;
        Object.defineProperty(exports, "__esModule", {value: true});
        exports.default = "ui.router";
      }, function(module, exports, __webpack_require__) {
        function __export(m) {
          for (var p in m)
            if (!exports.hasOwnProperty(p))
              exports[p] = m[p];
        }
        __export(__webpack_require__(3));
        __export(__webpack_require__(4));
        __export(__webpack_require__(5));
        __export(__webpack_require__(6));
      }, function(module, exports) {
        var isDefined = angular.isDefined,
            isFunction = angular.isFunction,
            isNumber = angular.isNumber,
            isString = angular.isString,
            isObject = angular.isObject,
            isArray = angular.isArray,
            forEach = angular.forEach,
            extend = angular.extend,
            copy = angular.copy,
            noop = angular.noop,
            toJson = angular.toJson,
            fromJson = angular.fromJson,
            equals = angular.equals,
            identity = angular.identity;
        exports.isDefined = isDefined;
        exports.isFunction = isFunction;
        exports.isNumber = isNumber;
        exports.isString = isString;
        exports.isObject = isObject;
        exports.isArray = isArray;
        exports.forEach = forEach;
        exports.extend = extend;
        exports.copy = copy;
        exports.noop = noop;
        exports.toJson = toJson;
        exports.fromJson = fromJson;
        exports.equals = equals;
        exports.identity = identity;
        exports.abstractKey = 'abstract';
        function curry(fn) {
          var initial_args = [].slice.apply(arguments, [1]);
          var func_args_length = fn.length;
          function curried(args) {
            if (args.length >= func_args_length)
              return fn.apply(null, args);
            return function() {
              return curried(args.concat([].slice.apply(arguments)));
            };
          }
          return curried(initial_args);
        }
        exports.curry = curry;
        function compose() {
          var args = arguments;
          var start = args.length - 1;
          return function() {
            var i = start,
                result = args[start].apply(this, arguments);
            while (i--)
              result = args[i].call(this, result);
            return result;
          };
        }
        exports.compose = compose;
        function pipe() {
          var funcs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            funcs[_i - 0] = arguments[_i];
          }
          return compose.apply(null, [].slice.call(arguments).reverse());
        }
        exports.pipe = pipe;
        exports.prop = function(name) {
          return function(obj) {
            return obj && obj[name];
          };
        };
        exports.propEq = curry(function(name, val, obj) {
          return obj && obj[name] === val;
        });
        exports.parse = function(name) {
          return pipe.apply(null, name.split(".").map(exports.prop));
        };
        exports.not = function(fn) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i - 0] = arguments[_i];
            }
            return !fn.apply(null, args);
          };
        };
        function and(fn1, fn2) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i - 0] = arguments[_i];
            }
            return fn1.apply(null, args) && fn2.apply(null, args);
          };
        }
        exports.and = and;
        function or(fn1, fn2) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i - 0] = arguments[_i];
            }
            return fn1.apply(null, args) || fn2.apply(null, args);
          };
        }
        exports.or = or;
        exports.is = function(ctor) {
          return function(obj) {
            return (obj != null && obj.constructor === ctor || obj instanceof ctor);
          };
        };
        exports.eq = function(val) {
          return function(other) {
            return val === other;
          };
        };
        exports.val = function(v) {
          return function() {
            return v;
          };
        };
        function invoke(fnName, args) {
          return function(obj) {
            return obj[fnName].apply(obj, args);
          };
        }
        exports.invoke = invoke;
        function pattern(struct) {
          return function(val) {
            for (var i = 0; i < struct.length; i++) {
              if (struct[i][0](val))
                return struct[i][1](val);
            }
          };
        }
        exports.pattern = pattern;
        exports.inherit = function(parent, extra) {
          return extend(new (extend(function() {}, {prototype: parent}))(), extra);
        };
        var restArgs = function(args, idx) {
          if (idx === void 0) {
            idx = 0;
          }
          return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));
        };
        var inArray = function(array, obj) {
          return array.indexOf(obj) !== -1;
        };
        exports.removeFrom = function(array) {
          return function(obj) {
            var idx = array.indexOf(obj);
            if (idx >= 0)
              array.splice(idx, 1);
            return array;
          };
        };
        function defaults(opts) {
          if (opts === void 0) {
            opts = {};
          }
          var defaultsList = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            defaultsList[_i - 1] = arguments[_i];
          }
          var defaults = merge.apply(null, [{}].concat(defaultsList));
          return extend({}, defaults, pick(opts || {}, Object.keys(defaults)));
        }
        exports.defaults = defaults;
        function merge(dst) {
          var objs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            objs[_i - 1] = arguments[_i];
          }
          forEach(objs, function(obj) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          });
          return dst;
        }
        exports.merge = merge;
        exports.mergeR = function(memo, item) {
          return extend(memo, item);
        };
        function ancestors(first, second) {
          var path = [];
          for (var n in first.path) {
            if (first.path[n] !== second.path[n])
              break;
            path.push(first.path[n]);
          }
          return path;
        }
        exports.ancestors = ancestors;
        function equalForKeys(a, b, keys) {
          if (keys === void 0) {
            keys = Object.keys(a);
          }
          for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k])
              return false;
          }
          return true;
        }
        exports.equalForKeys = equalForKeys;
        function pickOmitImpl(predicate, obj) {
          var objCopy = {},
              keys = restArgs(arguments, 2);
          for (var key in obj) {
            if (predicate(keys, key))
              objCopy[key] = obj[key];
          }
          return objCopy;
        }
        function pick(obj) {
          return pickOmitImpl.apply(null, [inArray].concat(restArgs(arguments)));
        }
        exports.pick = pick;
        function omit(obj) {
          return pickOmitImpl.apply(null, [exports.not(inArray)].concat(restArgs(arguments)));
        }
        exports.omit = omit;
        function pluck(collection, propName) {
          return map(collection, exports.prop(propName));
        }
        exports.pluck = pluck;
        function filter(collection, callback) {
          var arr = isArray(collection),
              result = arr ? [] : {};
          var accept = arr ? function(x) {
            return result.push(x);
          } : function(x, key) {
            return result[key] = x;
          };
          forEach(collection, function(item, i) {
            if (callback(item, i))
              accept(item, i);
          });
          return result;
        }
        exports.filter = filter;
        function find(collection, callback) {
          var result;
          forEach(collection, function(item, i) {
            if (result)
              return;
            if (callback(item, i))
              result = item;
          });
          return result;
        }
        exports.find = find;
        function map(collection, callback) {
          var result = isArray(collection) ? [] : {};
          forEach(collection, function(item, i) {
            return result[i] = callback(item, i);
          });
          return result;
        }
        exports.map = map;
        exports.values = function(obj) {
          return Object.keys(obj).map(function(key) {
            return obj[key];
          });
        };
        exports.allTrueR = function(memo, elem) {
          return memo && elem;
        };
        exports.anyTrueR = function(memo, elem) {
          return memo || elem;
        };
        exports.pushR = function(arr, obj) {
          arr.push(obj);
          return arr;
        };
        exports.unnestR = function(memo, elem) {
          return memo.concat(elem);
        };
        exports.flattenR = function(memo, elem) {
          return isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : exports.pushR(memo, elem);
        };
        exports.unnest = function(arr) {
          return arr.reduce(exports.unnestR, []);
        };
        exports.flatten = function(arr) {
          return arr.reduce(exports.flattenR, []);
        };
        function assertPredicate(fn, errMsg) {
          if (errMsg === void 0) {
            errMsg = "assert failure";
          }
          return function(obj) {
            if (!fn(obj))
              throw new Error(errMsg);
            return true;
          };
        }
        exports.assertPredicate = assertPredicate;
        exports.pairs = function(object) {
          return Object.keys(object).map(function(key) {
            return [key, object[key]];
          });
        };
        function arrayTuples() {
          var arrayArgs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arrayArgs[_i - 0] = arguments[_i];
          }
          if (arrayArgs.length === 0)
            return [];
          var length = arrayArgs.reduce(function(min, arr) {
            return Math.min(arr.length, min);
          }, 9007199254740991);
          return Array.apply(null, Array(length)).map(function(ignored, idx) {
            return arrayArgs.map(function(arr) {
              return arr[idx];
            }).reduce(exports.pushR, []);
          });
        }
        exports.arrayTuples = arrayTuples;
        function applyPairs(memo, keyValTuple) {
          var key,
              value;
          if (isArray(keyValTuple))
            key = keyValTuple[0], value = keyValTuple[1];
          if (!isString(key))
            throw new Error("invalid parameters to applyPairs");
          memo[key] = value;
          return memo;
        }
        exports.applyPairs = applyPairs;
        function isInjectable(val) {
          if (isArray(val) && val.length) {
            var head = val.slice(0, -1),
                tail_1 = val.slice(-1);
            if (head.filter(exports.not(isString)).length || tail_1.filter(exports.not(isFunction)).length)
              return false;
          }
          return isFunction(val);
        }
        exports.isInjectable = isInjectable;
        exports.isNull = function(o) {
          return o === null;
        };
        exports.isPromise = and(isObject, pipe(exports.prop('then'), isFunction));
        function fnToString(fn) {
          var _fn = pattern([[isArray, function(arr) {
            return arr.slice(-1)[0];
          }], [exports.val(true), identity]])(fn);
          return _fn && _fn.toString() || "undefined";
        }
        exports.fnToString = fnToString;
        function maxLength(max, str) {
          if (str.length <= max)
            return str;
          return str.substr(0, max - 3) + "...";
        }
        exports.maxLength = maxLength;
        function padString(length, str) {
          while (str.length < length)
            str += " ";
          return str;
        }
        exports.padString = padString;
        function tail(collection) {
          return collection.length && collection[collection.length - 1] || undefined;
        }
        exports.tail = tail;
        angular.module('ui.router.util', ['ng', 'ui.router.init']);
        angular.module('ui.router.router', ['ui.router.util']);
        angular.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);
        angular.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);
        angular.module('ui.router.compat', ['ui.router']);
      }, function(module, exports) {
        var notImplemented = function(fnname) {
          return function() {
            throw new Error(fnname + "(): No coreservices implementation for UI-Router is loaded. You should include one of: ['angular1.js']");
          };
        };
        var services = {
          $q: undefined,
          $injector: undefined,
          location: {},
          locationConfig: {}
        };
        exports.services = services;
        ["replace", "url", "path", "search", "hash"].forEach(function(key) {
          return services.location[key] = notImplemented(key);
        });
        ["port", "protocol", "host", "baseHref", "html5Mode", "hashPrefix"].forEach(function(key) {
          return services.locationConfig[key] = notImplemented(key);
        });
      }, function(module, exports) {
        var Queue = (function() {
          function Queue(_items) {
            if (_items === void 0) {
              _items = [];
            }
            this._items = _items;
          }
          Queue.prototype.enqueue = function(item) {
            this._items.push(item);
            return item;
          };
          Queue.prototype.dequeue = function() {
            if (this.size())
              return this._items.splice(0, 1)[0];
          };
          Queue.prototype.clear = function() {
            var current = this._items;
            this._items = [];
            return current;
          };
          Queue.prototype.size = function() {
            return this._items.length;
          };
          Queue.prototype.remove = function(item) {
            var idx = this._items.indexOf(item);
            return idx > -1 && this._items.splice(idx, 1)[0];
          };
          Queue.prototype.peekTail = function() {
            return this._items[this._items.length - 1];
          };
          Queue.prototype.peekHead = function() {
            if (this.size())
              return this._items[0];
          };
          return Queue;
        })();
        exports.Queue = Queue;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var resolvable_1 = __webpack_require__(7);
        var transition_1 = __webpack_require__(8);
        var rejectFactory_1 = __webpack_require__(28);
        function promiseToString(p) {
          if (common_1.is(rejectFactory_1.TransitionRejection)(p.reason))
            return p.reason.toString();
          return "Promise(" + JSON.stringify(p) + ")";
        }
        function functionToString(fn) {
          var fnStr = common_1.fnToString(fn);
          var namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
          return namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
        }
        var uiViewString = function(viewData) {
          return ("ui-view id#" + viewData.id + ", contextual name '" + viewData.name + "@" + viewData.creationContext + "', fqn: '" + viewData.fqn + "'");
        };
        var viewConfigString = function(viewConfig) {
          return ("ViewConfig targeting ui-view: '" + viewConfig.uiViewName + "@" + viewConfig.uiViewContextAnchor + "', context: '" + viewConfig.context.name + "'");
        };
        function normalizedCat(input) {
          return common_1.isNumber(input) ? Category[input] : Category[Category[input]];
        }
        function stringify(o) {
          var format = common_1.pattern([[common_1.not(common_1.isDefined), common_1.val("undefined")], [common_1.isNull, common_1.val("null")], [common_1.isPromise, promiseToString], [common_1.is(transition_1.Transition), common_1.invoke("toString")], [common_1.is(resolvable_1.Resolvable), common_1.invoke("toString")], [common_1.isInjectable, functionToString], [common_1.val(true), common_1.identity]]);
          return JSON.stringify(o, function(key, val) {
            return format(val);
          }).replace(/\\"/g, '"');
        }
        var Category;
        (function(Category) {
          Category[Category["RESOLVE"] = 0] = "RESOLVE";
          Category[Category["TRANSITION"] = 1] = "TRANSITION";
          Category[Category["HOOK"] = 2] = "HOOK";
          Category[Category["INVOKE"] = 3] = "INVOKE";
          Category[Category["UIVIEW"] = 4] = "UIVIEW";
          Category[Category["VIEWCONFIG"] = 5] = "VIEWCONFIG";
        })(Category || (Category = {}));
        var Trace = (function() {
          function Trace() {
            var _this = this;
            this._enabled = {};
            this.enable = function() {
              var categories = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                categories[_i - 0] = arguments[_i];
              }
              return _this._set(true, categories);
            };
            this.disable = function() {
              var categories = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                categories[_i - 0] = arguments[_i];
              }
              return _this._set(false, categories);
            };
            this.approximateDigests = 0;
          }
          Trace.prototype._set = function(enabled, categories) {
            var _this = this;
            if (!categories.length) {
              categories = Object.keys(Category).filter(function(k) {
                return isNaN(parseInt(k, 10));
              }).map(function(key) {
                return Category[key];
              });
            }
            categories.map(normalizedCat).forEach(function(category) {
              return _this._enabled[category] = enabled;
            });
          };
          Trace.prototype.enabled = function(category) {
            return !!this._enabled[normalizedCat(category)];
          };
          Trace.prototype.traceTransitionStart = function(transition) {
            if (!this.enabled(Category.TRANSITION))
              return;
            var tid = transition.$id,
                digest = this.approximateDigests,
                transitionStr = stringify(transition);
            console.log("Transition #" + tid + " Digest #" + digest + ": Started  -> " + transitionStr);
          };
          Trace.prototype.traceTransitionIgnored = function(transition) {
            if (!this.enabled(Category.TRANSITION))
              return;
            var tid = transition.$id,
                digest = this.approximateDigests,
                transitionStr = stringify(transition);
            console.log("Transition #" + tid + " Digest #" + digest + ": Ignored  <> " + transitionStr);
          };
          Trace.prototype.traceHookInvocation = function(step, options) {
            if (!this.enabled(Category.HOOK))
              return;
            var tid = common_1.parse("transition.$id")(options),
                digest = this.approximateDigests,
                event = common_1.parse("traceData.hookType")(options) || "internal",
                context = common_1.parse("traceData.context.state.name")(options) || common_1.parse("traceData.context")(options) || "unknown",
                name = functionToString(step.fn);
            console.log("Transition #" + tid + " Digest #" + digest + ":   Hook -> " + event + " context: " + context + ", " + common_1.maxLength(200, name));
          };
          Trace.prototype.traceHookResult = function(hookResult, transitionResult, transitionOptions) {
            if (!this.enabled(Category.HOOK))
              return;
            var tid = common_1.parse("transition.$id")(transitionOptions),
                digest = this.approximateDigests,
                hookResultStr = stringify(hookResult),
                transitionResultStr = stringify(transitionResult);
            console.log("Transition #" + tid + " Digest #" + digest + ":   <- Hook returned: " + common_1.maxLength(200, hookResultStr) + ", transition result: " + common_1.maxLength(200, transitionResultStr));
          };
          Trace.prototype.traceResolvePath = function(path, options) {
            if (!this.enabled(Category.RESOLVE))
              return;
            var tid = common_1.parse("transition.$id")(options),
                digest = this.approximateDigests,
                pathStr = path && path.toString(),
                policyStr = options && options.resolvePolicy;
            console.log("Transition #" + tid + " Digest #" + digest + ":         Resolving " + pathStr + " (" + policyStr + ")");
          };
          Trace.prototype.traceResolvePathElement = function(pathElement, resolvablePromises, options) {
            if (!this.enabled(Category.RESOLVE))
              return;
            if (!resolvablePromises.length)
              return;
            var tid = common_1.parse("transition.$id")(options),
                digest = this.approximateDigests,
                resolvablePromisesStr = Object.keys(resolvablePromises).join(", "),
                pathElementStr = pathElement && pathElement.toString(),
                policyStr = options && options.resolvePolicy;
            console.log("Transition #" + tid + " Digest #" + digest + ":         Resolve " + pathElementStr + " resolvables: [" + resolvablePromisesStr + "] (" + policyStr + ")");
          };
          Trace.prototype.traceResolveResolvable = function(resolvable, options) {
            if (!this.enabled(Category.RESOLVE))
              return;
            var tid = common_1.parse("transition.$id")(options),
                digest = this.approximateDigests,
                resolvableStr = resolvable && resolvable.toString();
            console.log("Transition #" + tid + " Digest #" + digest + ":               Resolving -> " + resolvableStr);
          };
          Trace.prototype.traceResolvableResolved = function(resolvable, options) {
            if (!this.enabled(Category.RESOLVE))
              return;
            var tid = common_1.parse("transition.$id")(options),
                digest = this.approximateDigests,
                resolvableStr = resolvable && resolvable.toString(),
                result = stringify(resolvable.data);
            console.log("Transition #" + tid + " Digest #" + digest + ":               <- Resolved  " + resolvableStr + " to: " + common_1.maxLength(200, result));
          };
          Trace.prototype.tracePathElementInvoke = function(node, fn, deps, options) {
            if (!this.enabled(Category.INVOKE))
              return;
            var tid = common_1.parse("transition.$id")(options),
                digest = this.approximateDigests,
                stateName = node && node.state && node.state.toString(),
                fnName = functionToString(fn);
            console.log("Transition #" + tid + " Digest #" + digest + ":         Invoke " + options.when + ": context: " + stateName + " " + common_1.maxLength(200, fnName));
          };
          Trace.prototype.traceError = function(error, transition) {
            if (!this.enabled(Category.TRANSITION))
              return;
            var tid = transition.$id,
                digest = this.approximateDigests,
                transitionStr = stringify(transition);
            console.log("Transition #" + tid + " Digest #" + digest + ": <- Rejected " + transitionStr + ", reason: " + error);
          };
          Trace.prototype.traceSuccess = function(finalState, transition) {
            if (!this.enabled(Category.TRANSITION))
              return;
            var tid = transition.$id,
                digest = this.approximateDigests,
                state = finalState.name,
                transitionStr = stringify(transition);
            console.log("Transition #" + tid + " Digest #" + digest + ": <- Success  " + transitionStr + ", final state: " + state);
          };
          Trace.prototype.traceUiViewEvent = function(event, viewData, extra) {
            if (extra === void 0) {
              extra = "";
            }
            if (!this.enabled(Category.UIVIEW))
              return;
            console.log("ui-view: " + common_1.padString(30, event) + " " + uiViewString(viewData) + extra);
          };
          Trace.prototype.traceUiViewConfigUpdated = function(viewData, context) {
            if (!this.enabled(Category.UIVIEW))
              return;
            this.traceUiViewEvent("Updating", viewData, " with ViewConfig from context='" + context + "'");
          };
          Trace.prototype.traceUiViewScopeCreated = function(viewData, newScope) {
            if (!this.enabled(Category.UIVIEW))
              return;
            this.traceUiViewEvent("Created scope for", viewData, ", scope #" + newScope.$id);
          };
          Trace.prototype.traceUiViewFill = function(viewData, html) {
            if (!this.enabled(Category.UIVIEW))
              return;
            this.traceUiViewEvent("Fill", viewData, " with: " + common_1.maxLength(200, html));
          };
          Trace.prototype.traceViewServiceEvent = function(event, viewConfig) {
            if (!this.enabled(Category.VIEWCONFIG))
              return;
            console.log("$view.ViewConfig: " + event + " " + viewConfigString(viewConfig));
          };
          Trace.prototype.traceViewServiceUiViewEvent = function(event, viewData) {
            if (!this.enabled(Category.VIEWCONFIG))
              return;
            console.log("$view.ViewConfig: " + event + " " + uiViewString(viewData));
          };
          return Trace;
        })();
        var trace = new Trace();
        exports.trace = trace;
        watchDigests.$inject = ['$rootScope'];
        function watchDigests($rootScope) {
          $rootScope.$watch(function() {
            trace.approximateDigests++;
          });
        }
        angular.module("ui.router").run(watchDigests);
        angular.module("ui.router").service("$trace", function() {
          return trace;
        });
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var coreservices_1 = __webpack_require__(4);
        var trace_1 = __webpack_require__(6);
        var Resolvable = (function() {
          function Resolvable(name, resolveFn, preResolvedData) {
            this.promise = undefined;
            common_1.extend(this, {
              name: name,
              resolveFn: resolveFn,
              deps: coreservices_1.services.$injector.annotate(resolveFn),
              data: preResolvedData
            });
          }
          Resolvable.prototype.resolveResolvable = function(resolveContext, options) {
            var _this = this;
            if (options === void 0) {
              options = {};
            }
            var _a = this,
                name = _a.name,
                deps = _a.deps,
                resolveFn = _a.resolveFn;
            trace_1.trace.traceResolveResolvable(this, options);
            var deferred = coreservices_1.services.$q.defer();
            this.promise = deferred.promise;
            var ancestorsByName = resolveContext.getResolvables(null, {omitOwnLocals: [name]});
            var depResolvables = common_1.pick(ancestorsByName, deps);
            var depPromises = common_1.map(depResolvables, function(resolvable) {
              return resolvable.get(resolveContext, options);
            });
            return coreservices_1.services.$q.all(depPromises).then(function(locals) {
              try {
                var result = coreservices_1.services.$injector.invoke(resolveFn, null, locals);
                deferred.resolve(result);
              } catch (error) {
                deferred.reject(error);
              }
              return _this.promise;
            }).then(function(data) {
              _this.data = data;
              trace_1.trace.traceResolvableResolved(_this, options);
              return _this.promise;
            });
          };
          Resolvable.prototype.get = function(resolveContext, options) {
            return this.promise || this.resolveResolvable(resolveContext, options);
          };
          Resolvable.prototype.toString = function() {
            return "Resolvable(name: " + this.name + ", requires: [" + this.deps + "])";
          };
          Resolvable.makeResolvables = function(resolves) {
            var invalid = common_1.filter(resolves, common_1.not(common_1.isFunction)),
                keys = Object.keys(invalid);
            if (keys.length)
              throw new Error("Invalid resolve key/value: " + keys[0] + "/" + invalid[keys[0]]);
            return common_1.map(resolves, function(fn, name) {
              return new Resolvable(name, fn);
            });
          };
          return Resolvable;
        })();
        exports.Resolvable = Resolvable;
      }, function(module, exports, __webpack_require__) {
        var trace_1 = __webpack_require__(6);
        var coreservices_1 = __webpack_require__(4);
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(9);
        var module_2 = __webpack_require__(15);
        var module_3 = __webpack_require__(12);
        var module_4 = __webpack_require__(36);
        var module_5 = __webpack_require__(17);
        var transitionCount = 0,
            REJECT = new module_1.RejectFactory();
        var stateSelf = common_1.prop("self");
        var Transition = (function() {
          function Transition(fromPath, targetState) {
            var _this = this;
            this._deferred = coreservices_1.services.$q.defer();
            this.promise = this._deferred.promise;
            this.treeChanges = function() {
              return _this._treeChanges;
            };
            this.isActive = function() {
              return _this === _this._options.current();
            };
            if (!targetState.valid()) {
              throw new Error(targetState.error());
            }
            module_1.HookRegistry.mixin(new module_1.HookRegistry(), this);
            this._options = common_1.extend({current: common_1.val(this)}, targetState.options());
            this.$id = transitionCount++;
            var toPath = module_2.PathFactory.buildToPath(fromPath, targetState);
            this._treeChanges = module_2.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);
            module_2.PathFactory.bindTransitionResolve(this._treeChanges, this);
          }
          Transition.prototype.$from = function() {
            return common_1.tail(this._treeChanges.from).state;
          };
          Transition.prototype.$to = function() {
            return common_1.tail(this._treeChanges.to).state;
          };
          Transition.prototype.from = function() {
            return this.$from().self;
          };
          Transition.prototype.to = function() {
            return this.$to().self;
          };
          Transition.prototype.is = function(compare) {
            if (compare instanceof Transition) {
              return this.is({
                to: compare.$to().name,
                from: compare.$from().name
              });
            }
            return !((compare.to && !module_1.matchState(this.$to(), compare.to)) || (compare.from && !module_1.matchState(this.$from(), compare.from)));
          };
          Transition.prototype.params = function(pathname) {
            if (pathname === void 0) {
              pathname = "to";
            }
            return this._treeChanges[pathname].map(common_1.prop("values")).reduce(common_1.mergeR, {});
          };
          Transition.prototype.resolves = function() {
            return common_1.map(common_1.tail(this._treeChanges.to).resolveContext.getResolvables(), function(res) {
              return res.data;
            });
          };
          Transition.prototype.addResolves = function(resolves, state) {
            if (state === void 0) {
              state = "";
            }
            var stateName = (typeof state === "string") ? state : state.name;
            var topath = this._treeChanges.to;
            var targetNode = common_1.find(topath, function(node) {
              return node.state.name === stateName;
            });
            common_1.tail(topath).resolveContext.addResolvables(module_5.Resolvable.makeResolvables(resolves), targetNode.state);
          };
          Transition.prototype.previous = function() {
            return this._options.previous || null;
          };
          Transition.prototype.options = function() {
            return this._options;
          };
          Transition.prototype.entering = function() {
            return common_1.map(this._treeChanges.entering, common_1.prop('state')).map(stateSelf);
          };
          Transition.prototype.exiting = function() {
            return common_1.map(this._treeChanges.exiting, common_1.prop('state')).map(stateSelf).reverse();
          };
          Transition.prototype.retained = function() {
            return common_1.map(this._treeChanges.retained, common_1.prop('state')).map(stateSelf);
          };
          Transition.prototype.views = function(pathname, state) {
            if (pathname === void 0) {
              pathname = "entering";
            }
            var path = this._treeChanges[pathname];
            return state ? common_1.find(path, common_1.propEq('state', state)).views : common_1.unnest(path.map(common_1.prop("views")));
          };
          Transition.prototype.redirect = function(targetState) {
            var newOptions = common_1.extend({}, this.options(), targetState.options(), {previous: this});
            targetState = new module_3.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);
            var redirectTo = new Transition(this._treeChanges.from, targetState);
            var redirectedPath = this.treeChanges().to;
            var matching = module_2.Node.matching(redirectTo.treeChanges().to, redirectedPath);
            var includeResolve = function(resolve, key) {
              return ['$stateParams', '$transition$'].indexOf(key) === -1;
            };
            matching.forEach(function(node, idx) {
              return common_1.extend(node.resolves, common_1.filter(redirectedPath[idx].resolves, includeResolve));
            });
            return redirectTo;
          };
          Transition.prototype.ignored = function() {
            var _a = this._treeChanges,
                to = _a.to,
                from = _a.from;
            if (this._options.reload || common_1.tail(to).state !== common_1.tail(from).state)
              return false;
            var nodeSchemas = to.map(function(node) {
              return node.schema.filter(common_1.not(common_1.prop('dynamic')));
            });
            var _b = [to, from].map(function(path) {
              return path.map(common_1.prop('values'));
            }),
                toValues = _b[0],
                fromValues = _b[1];
            var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);
            return tuples.map(function(_a) {
              var schema = _a[0],
                  toVals = _a[1],
                  fromVals = _a[2];
              return module_4.Param.equals(schema, toVals, fromVals);
            }).reduce(common_1.allTrueR, true);
          };
          Transition.prototype.hookBuilder = function() {
            return new module_1.HookBuilder(module_1.$transitions, this, {
              transition: this,
              current: this._options.current
            });
          };
          Transition.prototype.run = function() {
            var _this = this;
            var hookBuilder = this.hookBuilder();
            var runSynchronousHooks = module_1.TransitionHook.runSynchronousHooks;
            var runSuccessHooks = function() {
              return runSynchronousHooks(hookBuilder.getOnSuccessHooks(), {}, true);
            };
            var runErrorHooks = function($error$) {
              return runSynchronousHooks(hookBuilder.getOnErrorHooks(), {$error$: $error$}, true);
            };
            this.promise.then(runSuccessHooks, runErrorHooks);
            var syncResult = runSynchronousHooks(hookBuilder.getOnBeforeHooks());
            if (module_1.TransitionHook.isRejection(syncResult)) {
              var rejectReason = syncResult.reason;
              this._deferred.reject(rejectReason);
              return this.promise;
            }
            if (!this.valid()) {
              var error = new Error(this.error());
              this._deferred.reject(error);
              return this.promise;
            }
            if (this.ignored()) {
              trace_1.trace.traceTransitionIgnored(this);
              var ignored = REJECT.ignored();
              this._deferred.reject(ignored.reason);
              return this.promise;
            }
            var resolve = function() {
              _this._deferred.resolve(_this);
              trace_1.trace.traceSuccess(_this.$to(), _this);
            };
            var reject = function(error) {
              _this._deferred.reject(error);
              trace_1.trace.traceError(error, _this);
              return coreservices_1.services.$q.reject(error);
            };
            trace_1.trace.traceTransitionStart(this);
            var chain = hookBuilder.asyncHooks().reduce(function(_chain, step) {
              return _chain.then(step.invokeStep);
            }, syncResult);
            chain.then(resolve, reject);
            return this.promise;
          };
          Transition.prototype.valid = function() {
            return !this.error();
          };
          Transition.prototype.error = function() {
            var state = this.$to();
            if (state.self[common_1.abstractKey])
              return "Cannot transition to abstract state '" + state.name + "'";
            if (!module_4.Param.validates(state.parameters(), this.params()))
              return "Param values not valid for state '" + state.name + "'";
          };
          Transition.prototype.toString = function() {
            var fromStateOrName = this.from();
            var toStateOrName = this.to();
            var avoidEmptyHash = function(params) {
              return (params["#"] !== null && params["#"] !== undefined) ? params : common_1.omit(params, "#");
            };
            var id = this.$id,
                from = common_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,
                fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(common_1.prop('values')).reduce(common_1.mergeR, {}))),
                toValid = this.valid() ? "" : "(X) ",
                to = common_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName,
                toParams = common_1.toJson(avoidEmptyHash(this.params()));
            return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
          };
          return Transition;
        })();
        exports.Transition = Transition;
      }, function(module, exports, __webpack_require__) {
        function __export(m) {
          for (var p in m)
            if (!exports.hasOwnProperty(p))
              exports[p] = m[p];
        }
        __export(__webpack_require__(10));
        __export(__webpack_require__(11));
        __export(__webpack_require__(28));
        __export(__webpack_require__(8));
        __export(__webpack_require__(47));
        __export(__webpack_require__(48));
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(9);
        var successErrorOptions = {
          async: false,
          rejectIfSuperseded: false
        };
        var HookBuilder = (function() {
          function HookBuilder($transitions, transition, baseHookOptions) {
            var _this = this;
            this.$transitions = $transitions;
            this.transition = transition;
            this.baseHookOptions = baseHookOptions;
            this.getOnBeforeHooks = function() {
              return _this._buildTransitionHooks("onBefore", {}, {async: false});
            };
            this.getOnStartHooks = function() {
              return _this._buildTransitionHooks("onStart");
            };
            this.getOnExitHooks = function() {
              return _this._buildNodeHooks("onExit", _this.treeChanges.exiting.reverse(), function(node) {
                return _this._toFrom({from: node.state});
              });
            };
            this.getOnRetainHooks = function() {
              return _this._buildNodeHooks("onRetain", _this.treeChanges.retained, function(node) {
                return _this._toFrom();
              });
            };
            this.getOnEnterHooks = function() {
              return _this._buildNodeHooks("onEnter", _this.treeChanges.entering, function(node) {
                return _this._toFrom({to: node.state});
              });
            };
            this.getOnFinishHooks = function() {
              return _this._buildTransitionHooks("onFinish", {$treeChanges$: _this.treeChanges});
            };
            this.getOnSuccessHooks = function() {
              return _this._buildTransitionHooks("onSuccess", {}, {
                async: false,
                rejectIfSuperseded: false
              });
            };
            this.getOnErrorHooks = function() {
              return _this._buildTransitionHooks("onError", {}, {
                async: false,
                rejectIfSuperseded: false
              });
            };
            this.treeChanges = transition.treeChanges();
            this.toState = common_1.tail(this.treeChanges.to).state;
            this.fromState = common_1.tail(this.treeChanges.from).state;
            this.transitionOptions = transition.options();
          }
          HookBuilder.prototype.asyncHooks = function() {
            var onStartHooks = this.getOnStartHooks();
            var onExitHooks = this.getOnExitHooks();
            var onRetainHooks = this.getOnRetainHooks();
            var onEnterHooks = this.getOnEnterHooks();
            var onFinishHooks = this.getOnFinishHooks();
            return common_1.flatten([onStartHooks, onExitHooks, onRetainHooks, onEnterHooks, onFinishHooks]).filter(common_1.identity);
          };
          HookBuilder.prototype._toFrom = function(toFromOverride) {
            return common_1.extend({
              to: this.toState,
              from: this.fromState
            }, toFromOverride);
          };
          HookBuilder.prototype._buildTransitionHooks = function(hookType, locals, options) {
            var _this = this;
            if (locals === void 0) {
              locals = {};
            }
            if (options === void 0) {
              options = {};
            }
            var context = this.treeChanges.to,
                node = common_1.tail(context);
            options.traceData = {
              hookType: hookType,
              context: context
            };
            var transitionHook = function(eventHook) {
              return _this.buildHook(node, eventHook.callback, locals, options);
            };
            return this._matchingHooks(hookType, this._toFrom()).map(transitionHook);
          };
          HookBuilder.prototype._buildNodeHooks = function(hookType, path, toFromFn, locals, options) {
            var _this = this;
            if (locals === void 0) {
              locals = {};
            }
            if (options === void 0) {
              options = {};
            }
            var hooksForNode = function(node) {
              var toFrom = toFromFn(node);
              options.traceData = {
                hookType: hookType,
                context: node
              };
              locals.$state$ = node.state;
              var transitionHook = function(eventHook) {
                return _this.buildHook(node, eventHook.callback, locals, options);
              };
              return _this._matchingHooks(hookType, toFrom).map(transitionHook);
            };
            return path.map(hooksForNode);
          };
          HookBuilder.prototype.buildHook = function(node, fn, locals, options) {
            if (options === void 0) {
              options = {};
            }
            var _options = common_1.extend({}, this.baseHookOptions, options);
            return new module_1.TransitionHook(fn, common_1.extend({}, locals), node.resolveContext, _options);
          };
          HookBuilder.prototype._matchingHooks = function(hookName, matchCriteria) {
            var matchFilter = function(hook) {
              return hook.matches(matchCriteria.to, matchCriteria.from);
            };
            var prioritySort = function(l, r) {
              return r.priority - l.priority;
            };
            return [this.transition, this.$transitions].map(function(reg) {
              return reg.getHooks(hookName);
            }).filter(common_1.assertPredicate(common_1.isArray, "broken event named: " + hookName)).reduce(common_1.unnestR).filter(matchFilter).sort(prioritySort);
          };
          return HookBuilder;
        })();
        exports.HookBuilder = HookBuilder;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(12);
        function matchState(state, matchCriteria) {
          var toMatch = common_1.isString(matchCriteria) ? [matchCriteria] : matchCriteria;
          function matchGlobs(_state) {
            for (var i = 0; i < toMatch.length; i++) {
              var glob = module_1.Glob.fromString(toMatch[i]);
              if ((glob && glob.matches(_state.name)) || (!glob && toMatch[i] === _state.name)) {
                return true;
              }
            }
            return false;
          }
          var matchFn = (common_1.isFunction(toMatch) ? toMatch : matchGlobs);
          return !!matchFn(state);
        }
        exports.matchState = matchState;
        var EventHook = (function() {
          function EventHook(matchCriteria, callback, options) {
            if (options === void 0) {
              options = {};
            }
            this.callback = callback;
            this.matchCriteria = common_1.extend({
              to: common_1.val(true),
              from: common_1.val(true)
            }, matchCriteria);
            this.priority = options.priority || 0;
          }
          EventHook.prototype.matches = function(to, from) {
            return matchState(to, this.matchCriteria.to) && matchState(from, this.matchCriteria.from);
          };
          return EventHook;
        })();
        exports.EventHook = EventHook;
        function makeHookRegistrationFn(hooks, name) {
          return function(matchObject, callback, options) {
            if (options === void 0) {
              options = {};
            }
            var eventHook = new EventHook(matchObject, callback, options);
            hooks[name].push(eventHook);
            return function deregisterEventHook() {
              common_1.removeFrom(hooks[name])(eventHook);
            };
          };
        }
        var HookRegistry = (function() {
          function HookRegistry() {
            var _this = this;
            this._transitionEvents = {
              onBefore: [],
              onStart: [],
              onEnter: [],
              onRetain: [],
              onExit: [],
              onFinish: [],
              onSuccess: [],
              onError: []
            };
            this.getHooks = function(name) {
              return _this._transitionEvents[name];
            };
            this.onBefore = makeHookRegistrationFn(this._transitionEvents, "onBefore");
            this.onStart = makeHookRegistrationFn(this._transitionEvents, "onStart");
            this.onEnter = makeHookRegistrationFn(this._transitionEvents, "onEnter");
            this.onRetain = makeHookRegistrationFn(this._transitionEvents, "onRetain");
            this.onExit = makeHookRegistrationFn(this._transitionEvents, "onExit");
            this.onFinish = makeHookRegistrationFn(this._transitionEvents, "onFinish");
            this.onSuccess = makeHookRegistrationFn(this._transitionEvents, "onSuccess");
            this.onError = makeHookRegistrationFn(this._transitionEvents, "onError");
          }
          HookRegistry.mixin = function(source, target) {
            Object.keys(source._transitionEvents).concat(["getHooks"]).forEach(function(key) {
              return target[key] = source[key];
            });
          };
          return HookRegistry;
        })();
        exports.HookRegistry = HookRegistry;
      }, function(module, exports, __webpack_require__) {
        function __export(m) {
          for (var p in m)
            if (!exports.hasOwnProperty(p))
              exports[p] = m[p];
        }
        __export(__webpack_require__(13));
        __export(__webpack_require__(14));
        __export(__webpack_require__(41));
        __export(__webpack_require__(42));
        __export(__webpack_require__(43));
        __export(__webpack_require__(23));
        __export(__webpack_require__(44));
        __export(__webpack_require__(45));
        __export(__webpack_require__(46));
        __export(__webpack_require__(29));
      }, function(module, exports) {
        var Glob = (function() {
          function Glob(text) {
            this.text = text;
            this.glob = text.split('.');
          }
          Glob.prototype.matches = function(name) {
            var segments = name.split('.');
            for (var i = 0,
                l = this.glob.length; i < l; i++) {
              if (this.glob[i] === '*')
                segments[i] = '*';
            }
            if (this.glob[0] === '**') {
              segments = segments.slice(segments.indexOf(this.glob[1]));
              segments.unshift('**');
            }
            if (this.glob[this.glob.length - 1] === '**') {
              segments.splice(segments.indexOf(this.glob[this.glob.length - 2]) + 1, Number.MAX_VALUE);
              segments.push('**');
            }
            if (this.glob.length != segments.length)
              return false;
            return segments.join('') === this.glob.join('');
          };
          Glob.is = function(text) {
            return text.indexOf('*') > -1;
          };
          Glob.fromString = function(text) {
            if (!this.is(text))
              return null;
            return new Glob(text);
          };
          return Glob;
        })();
        exports.Glob = Glob;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var queue_1 = __webpack_require__(5);
        var module_1 = __webpack_require__(12);
        var module_2 = __webpack_require__(9);
        var module_3 = __webpack_require__(15);
        var transitionManager_1 = __webpack_require__(23);
        var module_4 = __webpack_require__(36);
        function $StateProvider($urlRouterProvider, $urlMatcherFactoryProvider) {
          var root,
              states = {};
          var $state = function $state() {};
          var matcher = new module_1.StateMatcher(states);
          var builder = new module_1.StateBuilder(function() {
            return root;
          }, matcher, $urlMatcherFactoryProvider);
          var stateQueue = new module_1.StateQueueManager(states, builder, $urlRouterProvider, $state);
          var transQueue = new queue_1.Queue();
          var treeChangesQueue = new queue_1.Queue();
          var rejectFactory = new module_2.RejectFactory();
          this.decorator = decorator;
          function decorator(name, func) {
            return builder.builder(name, func) || this;
          }
          this.state = state;
          function state(name, definition) {
            if (common_1.isObject(name)) {
              definition = name;
            } else {
              definition.name = name;
            }
            stateQueue.register(definition);
            return this;
          }
          var invalidCallbacks = [];
          this.onInvalid = onInvalid;
          function onInvalid(callback) {
            invalidCallbacks.push(callback);
          }
          this.$get = $get;
          $get.$inject = ['$q', '$injector', '$view', '$stateParams', '$urlRouter', '$transitions'];
          function $get($q, $injector, $view, $stateParams, $urlRouter, _$transition) {
            function handleInvalidTargetState(fromPath, $to$) {
              var latestThing = function() {
                return transQueue.peekTail() || treeChangesQueue.peekTail();
              };
              var latest = latestThing();
              var $from$ = module_3.PathFactory.makeTargetState(fromPath);
              var callbackQueue = new queue_1.Queue([].concat(invalidCallbacks));
              var invokeCallback = function(callback) {
                return $q.when($injector.invoke(callback, null, {
                  $to$: $to$,
                  $from$: $from$
                }));
              };
              function checkForRedirect(result) {
                if (!(result instanceof module_1.TargetState)) {
                  return;
                }
                var target = result;
                target = $state.target(target.identifier(), target.params(), target.options());
                if (!target.valid())
                  return rejectFactory.invalid(target.error());
                if (latestThing() !== latest)
                  return rejectFactory.superseded();
                return $state.transitionTo(target.identifier(), target.params(), target.options());
              }
              function invokeNextCallback() {
                var nextCallback = callbackQueue.dequeue();
                if (nextCallback === undefined)
                  return rejectFactory.invalid($to$.error());
                return invokeCallback(nextCallback).then(checkForRedirect).then(function(result) {
                  return result || invokeNextCallback();
                });
              }
              return invokeNextCallback();
            }
            var $transitions = _$transition;
            var rootStateDef = {
              name: '',
              url: '^',
              views: null,
              params: {'#': {
                  value: null,
                  type: 'hash'
                }},
              abstract: true
            };
            root = stateQueue.register(rootStateDef, true);
            root.navigable = null;
            var rootPath = function() {
              return module_3.PathFactory.bindTransNodesToPath([new module_3.Node(root, {})]);
            };
            $view.rootContext(root);
            common_1.extend($state, {
              params: new module_4.StateParams(),
              current: root.self,
              $current: root,
              transition: null
            });
            stateQueue.flush($state);
            stateQueue.autoFlush = true;
            $state.reload = function reload(reloadState) {
              return $state.transitionTo($state.current, $stateParams, {
                reload: common_1.isDefined(reloadState) ? reloadState : true,
                inherit: false,
                notify: false
              });
            };
            $state.go = function go(to, params, options) {
              var defautGoOpts = {
                relative: $state.$current,
                inherit: true
              };
              var transOpts = common_1.defaults(options, defautGoOpts, module_2.defaultTransOpts);
              return $state.transitionTo(to, params, transOpts);
            };
            $state.target = function target(identifier, params, options) {
              if (options === void 0) {
                options = {};
              }
              var stateDefinition = matcher.find(identifier, options.relative);
              return new module_1.TargetState(identifier, stateDefinition, params, options);
            };
            $state.transitionTo = function transitionTo(to, toParams, options) {
              if (toParams === void 0) {
                toParams = {};
              }
              if (options === void 0) {
                options = {};
              }
              options = common_1.defaults(options, module_2.defaultTransOpts);
              options = common_1.extend(options, {current: transQueue.peekTail.bind(transQueue)});
              if (common_1.isObject(options.reload) && !options.reload.name)
                throw new Error('Invalid reload state object');
              options.reloadState = options.reload === true ? $state.$current.path[0] : matcher.find(options.reload, options.relative);
              if (options.reload && !options.reloadState)
                throw new Error("No such reload state '" + (common_1.isString(options.reload) ? options.reload : options.reload.name) + "'");
              var ref = $state.target(to, toParams, options);
              var latestTreeChanges = treeChangesQueue.peekTail();
              var currentPath = latestTreeChanges ? latestTreeChanges.to : rootPath();
              if (!ref.exists())
                return handleInvalidTargetState(currentPath, ref);
              if (!ref.valid())
                return $q.reject(ref.error());
              var transition = $transitions.create(currentPath, ref);
              var tMgr = new transitionManager_1.TransitionManager(transition, $transitions, $urlRouter, $view, $state, $stateParams, $q, transQueue, treeChangesQueue);
              var transitionPromise = tMgr.runTransition();
              return common_1.extend(transitionPromise, {transition: transition});
            };
            $state.is = function is(stateOrName, params, options) {
              options = common_1.defaults(options, {relative: $state.$current});
              var state = matcher.find(stateOrName, options.relative);
              if (!common_1.isDefined(state))
                return undefined;
              if ($state.$current !== state)
                return false;
              return common_1.isDefined(params) && params !== null ? module_4.Param.equals(state.parameters(), $stateParams, params) : true;
            };
            $state.includes = function includes(stateOrName, params, options) {
              options = common_1.defaults(options, {relative: $state.$current});
              var glob = common_1.isString(stateOrName) && module_1.Glob.fromString(stateOrName);
              if (glob) {
                if (!glob.matches($state.$current.name))
                  return false;
                stateOrName = $state.$current.name;
              }
              var state = matcher.find(stateOrName, options.relative),
                  include = $state.$current.includes;
              if (!common_1.isDefined(state))
                return undefined;
              if (!common_1.isDefined(include[state.name]))
                return false;
              return params ? common_1.equalForKeys(module_4.Param.values(state.parameters(), params), $stateParams, Object.keys(params)) : true;
            };
            $state.href = function href(stateOrName, params, options) {
              var defaultHrefOpts = {
                lossy: true,
                inherit: true,
                absolute: false,
                relative: $state.$current
              };
              options = common_1.defaults(options, defaultHrefOpts);
              var state = matcher.find(stateOrName, options.relative);
              if (!common_1.isDefined(state))
                return null;
              if (options.inherit)
                params = $stateParams.$inherit(params || {}, $state.$current, state);
              var nav = (state && options.lossy) ? state.navigable : state;
              if (!nav || nav.url === undefined || nav.url === null) {
                return null;
              }
              return $urlRouter.href(nav.url, module_4.Param.values(state.parameters(), params), {absolute: options.absolute});
            };
            $state.get = function(stateOrName, base) {
              if (arguments.length === 0)
                return Object.keys(states).map(function(name) {
                  return states[name].self;
                });
              var found = matcher.find(stateOrName, base || $state.$current);
              return found && found.self || null;
            };
            return $state;
          }
        }
        exports.$StateProvider = $StateProvider;
      }, function(module, exports, __webpack_require__) {
        function __export(m) {
          for (var p in m)
            if (!exports.hasOwnProperty(p))
              exports[p] = m[p];
        }
        __export(__webpack_require__(16));
        __export(__webpack_require__(22));
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(17);
        var view_1 = __webpack_require__(21);
        var Node = (function() {
          function Node(state, params, resolves) {
            if (resolves === void 0) {
              resolves = {};
            }
            this.state = state;
            this.schema = state.parameters({inherit: false});
            var getParamVal = function(paramDef) {
              return [paramDef.id, paramDef.value(params[paramDef.id])];
            };
            this.values = this.schema.reduce(function(memo, pDef) {
              return common_1.applyPairs(memo, getParamVal(pDef));
            }, {});
            this.resolves = common_1.extend(common_1.map(state.resolve, function(fn, name) {
              return new module_1.Resolvable(name, fn);
            }), resolves);
            var makeViewConfig = function(viewDeclarationObj, rawViewName) {
              return new view_1.ViewConfig({
                rawViewName: rawViewName,
                viewDeclarationObj: viewDeclarationObj,
                context: state,
                params: params
              });
            };
            this.views = common_1.values(common_1.map(state.views, makeViewConfig));
          }
          Node.prototype.parameter = function(name) {
            return common_1.find(this.schema, common_1.propEq("id", name));
          };
          Node.prototype.equals = function(node, keys) {
            var _this = this;
            if (keys === void 0) {
              keys = this.schema.map(common_1.prop('id'));
            }
            var paramValsEq = function(key) {
              return _this.parameter(key).type.equals(_this.values[key], node.values[key]);
            };
            return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);
          };
          Node.clone = function(node, update) {
            if (update === void 0) {
              update = {};
            }
            return new Node(node.state, (update.values || node.values), (update.resolves || node.resolves));
          };
          Node.matching = function(first, second) {
            var matchedCount = first.reduce(function(prev, node, i) {
              return prev === i && i < second.length && node.state === second[i].state ? i + 1 : prev;
            }, 0);
            return first.slice(0, matchedCount);
          };
          return Node;
        })();
        exports.Node = Node;
      }, function(module, exports, __webpack_require__) {
        function __export(m) {
          for (var p in m)
            if (!exports.hasOwnProperty(p))
              exports[p] = m[p];
        }
        __export(__webpack_require__(7));
        __export(__webpack_require__(18));
        __export(__webpack_require__(20));
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var trace_1 = __webpack_require__(6);
        var coreservices_1 = __webpack_require__(4);
        var interface_1 = __webpack_require__(19);
        var defaultResolvePolicy = interface_1.ResolvePolicy[interface_1.ResolvePolicy.LAZY];
        var ResolveContext = (function() {
          function ResolveContext(_path) {
            this._path = _path;
            common_1.extend(this, {
              _nodeFor: function(state) {
                return common_1.find(this._path, common_1.propEq('state', state));
              },
              _pathTo: function(state) {
                var node = this._nodeFor(state);
                var elementIdx = this._path.indexOf(node);
                if (elementIdx === -1)
                  throw new Error("This path does not contain the state");
                return this._path.slice(0, elementIdx + 1);
              }
            });
          }
          ResolveContext.prototype.getResolvables = function(state, options) {
            options = common_1.defaults(options, {omitOwnLocals: []});
            var offset = common_1.find(this._path, common_1.propEq(''));
            var path = (state ? this._pathTo(state) : this._path);
            var last = common_1.tail(path);
            return path.reduce(function(memo, node) {
              var omitProps = (node === last) ? options.omitOwnLocals : [];
              var filteredResolvables = common_1.omit(node.resolves, omitProps);
              return common_1.extend(memo, filteredResolvables);
            }, {});
          };
          ResolveContext.prototype.getResolvablesForFn = function(fn) {
            var deps = coreservices_1.services.$injector.annotate(fn);
            return common_1.pick(this.getResolvables(), deps);
          };
          ResolveContext.prototype.isolateRootTo = function(state) {
            return new ResolveContext(this._pathTo(state));
          };
          ResolveContext.prototype.addResolvables = function(resolvables, state) {
            common_1.extend(this._nodeFor(state).resolves, resolvables);
          };
          ResolveContext.prototype.getOwnResolvables = function(state) {
            return common_1.extend({}, this._nodeFor(state).resolves);
          };
          ResolveContext.prototype.resolvePath = function(options) {
            var _this = this;
            if (options === void 0) {
              options = {};
            }
            trace_1.trace.traceResolvePath(this._path, options);
            var promiseForNode = function(node) {
              return _this.resolvePathElement(node.state, options);
            };
            return coreservices_1.services.$q.all(common_1.map(this._path, promiseForNode)).then(common_1.noop);
          };
          ResolveContext.prototype.resolvePathElement = function(state, options) {
            var _this = this;
            if (options === void 0) {
              options = {};
            }
            var policy = options && options.resolvePolicy;
            var policyOrdinal = interface_1.ResolvePolicy[policy || defaultResolvePolicy];
            var resolvables = this.getOwnResolvables(state);
            var matchesRequestedPolicy = function(resolvable) {
              return getPolicy(state.resolvePolicy, resolvable) >= policyOrdinal;
            };
            var matchingResolves = common_1.filter(resolvables, matchesRequestedPolicy);
            var getResolvePromise = function(resolvable) {
              return resolvable.get(_this.isolateRootTo(state), options);
            };
            var resolvablePromises = common_1.map(matchingResolves, getResolvePromise);
            trace_1.trace.traceResolvePathElement(this, matchingResolves, options);
            return coreservices_1.services.$q.all(resolvablePromises).then(common_1.noop);
          };
          ResolveContext.prototype.invokeLater = function(fn, locals, options) {
            var _this = this;
            if (locals === void 0) {
              locals = {};
            }
            if (options === void 0) {
              options = {};
            }
            var resolvables = this.getResolvablesForFn(fn);
            trace_1.trace.tracePathElementInvoke(common_1.tail(this._path), fn, Object.keys(resolvables), common_1.extend({when: "Later"}, options));
            var getPromise = function(resolvable) {
              return resolvable.get(_this, options);
            };
            var promises = common_1.map(resolvables, getPromise);
            return coreservices_1.services.$q.all(promises).then(function() {
              try {
                return _this.invokeNow(fn, locals, options);
              } catch (error) {
                return coreservices_1.services.$q.reject(error);
              }
            });
          };
          ResolveContext.prototype.invokeNow = function(fn, locals, options) {
            if (options === void 0) {
              options = {};
            }
            var resolvables = this.getResolvablesForFn(fn);
            trace_1.trace.tracePathElementInvoke(common_1.tail(this._path), fn, Object.keys(resolvables), common_1.extend({when: "Now  "}, options));
            var resolvedLocals = common_1.map(resolvables, common_1.prop("data"));
            return coreservices_1.services.$injector.invoke(fn, null, common_1.extend({}, locals, resolvedLocals));
          };
          return ResolveContext;
        })();
        exports.ResolveContext = ResolveContext;
        function getPolicy(stateResolvePolicyConf, resolvable) {
          var stateLevelPolicy = (common_1.isString(stateResolvePolicyConf) ? stateResolvePolicyConf : null);
          var resolveLevelPolicies = (common_1.isObject(stateResolvePolicyConf) ? stateResolvePolicyConf : {});
          var policyName = resolveLevelPolicies[resolvable.name] || stateLevelPolicy || defaultResolvePolicy;
          return interface_1.ResolvePolicy[policyName];
        }
      }, function(module, exports) {
        (function(ResolvePolicy) {
          ResolvePolicy[ResolvePolicy["JIT"] = 0] = "JIT";
          ResolvePolicy[ResolvePolicy["LAZY"] = 1] = "LAZY";
          ResolvePolicy[ResolvePolicy["EAGER"] = 2] = "EAGER";
        })(exports.ResolvePolicy || (exports.ResolvePolicy = {}));
        var ResolvePolicy = exports.ResolvePolicy;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var ResolveInjector = (function() {
          function ResolveInjector(_resolveContext, _state) {
            this._resolveContext = _resolveContext;
            this._state = _state;
          }
          ResolveInjector.prototype.invokeLater = function(injectedFn, locals) {
            return this._resolveContext.invokeLater(injectedFn, locals);
          };
          ResolveInjector.prototype.invokeNow = function(injectedFn, locals) {
            return this._resolveContext.invokeNow(null, injectedFn, locals);
          };
          ResolveInjector.prototype.getLocals = function(injectedFn) {
            var _this = this;
            var resolve = function(r) {
              return r.get(_this._resolveContext);
            };
            return common_1.map(this._resolveContext.getResolvablesForFn(injectedFn), resolve);
          };
          return ResolveInjector;
        })();
        exports.ResolveInjector = ResolveInjector;
      }, function(module, exports, __webpack_require__) {
        "use strict";
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(2);
        function normalizeUiViewTarget(rawViewName) {
          if (rawViewName === void 0) {
            rawViewName = "";
          }
          var viewAtContext = rawViewName.split("@");
          var uiViewName = viewAtContext[0] || "$default";
          var uiViewContextAnchor = common_1.isString(viewAtContext[1]) ? viewAtContext[1] : "^";
          var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
          if (relativeViewNameSugar) {
            uiViewContextAnchor = relativeViewNameSugar[1];
            uiViewName = relativeViewNameSugar[2];
          }
          if (uiViewName.charAt(0) === '!') {
            uiViewName = uiViewName.substr(1);
            uiViewContextAnchor = "";
          }
          return {
            uiViewName: uiViewName,
            uiViewContextAnchor: uiViewContextAnchor
          };
        }
        var ViewConfig = (function() {
          function ViewConfig(stateViewConfig) {
            var _a = normalizeUiViewTarget(stateViewConfig.rawViewName),
                uiViewName = _a.uiViewName,
                uiViewContextAnchor = _a.uiViewContextAnchor;
            var relativeMatch = /^(\^(?:\.\^)*)$/;
            if (relativeMatch.exec(uiViewContextAnchor)) {
              var anchor = uiViewContextAnchor.split(".").reduce((function(anchor, x) {
                return anchor.parent;
              }), stateViewConfig.context);
              uiViewContextAnchor = anchor.name;
            }
            common_1.extend(this, common_1.pick(stateViewConfig, "viewDeclarationObj", "params", "context", "locals"), {
              uiViewName: uiViewName,
              uiViewContextAnchor: uiViewContextAnchor
            });
            this.controllerAs = stateViewConfig.viewDeclarationObj.controllerAs;
          }
          ViewConfig.prototype.hasTemplate = function() {
            var viewDef = this.viewDeclarationObj;
            return !!(viewDef.template || viewDef.templateUrl || viewDef.templateProvider);
          };
          ViewConfig.prototype.getTemplate = function($factory, injector) {
            return $factory.fromConfig(this.viewDeclarationObj, this.params, injector.invokeLater.bind(injector));
          };
          ViewConfig.prototype.getController = function(injector) {
            var provider = this.viewDeclarationObj.controllerProvider;
            return common_1.isInjectable(provider) ? injector.invokeLater(provider, {}) : this.viewDeclarationObj.controller;
          };
          return ViewConfig;
        })();
        exports.ViewConfig = ViewConfig;
        $View.$inject = ['$rootScope', '$templateFactory', '$q', '$timeout'];
        function $View($rootScope, $templateFactory, $q, $timeout) {
          var uiViews = [];
          var viewConfigs = [];
          var match = function(obj1) {
            var keys = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              keys[_i - 1] = arguments[_i];
            }
            return function(obj2) {
              return keys.reduce((function(memo, key) {
                return memo && obj1[key] === obj2[key];
              }), true);
            };
          };
          this.rootContext = function(context) {
            return context ? this._rootContext = context : this._rootContext;
          };
          this.load = function load(viewConfig, injector) {
            if (!viewConfig.hasTemplate())
              throw new Error("No template configuration specified for '" + viewConfig.uiViewName + "@" + viewConfig.uiViewContextAnchor + "'");
            var promises = {
              template: $q.when(viewConfig.getTemplate($templateFactory, injector)),
              controller: $q.when(viewConfig.getController(injector))
            };
            return $q.all(promises).then(function(results) {
              module_1.trace.traceViewServiceEvent("Loaded", viewConfig);
              return common_1.extend(viewConfig, results);
            });
          };
          this.reset = function reset(viewConfig) {
            module_1.trace.traceViewServiceEvent("<- Removing", viewConfig);
            viewConfigs.filter(match(viewConfig, "uiViewName", "context")).forEach(common_1.removeFrom(viewConfigs));
          };
          this.registerStateViewConfig = function(viewConfig) {
            module_1.trace.traceViewServiceEvent("-> Registering", viewConfig);
            viewConfigs.push(viewConfig);
          };
          this.sync = function() {
            var uiViewsByFqn = uiViews.map(function(uiv) {
              return [uiv.fqn, uiv];
            }).reduce(common_1.applyPairs, {});
            var matches = common_1.curry(function(uiView, viewConfig) {
              var vcSegments = viewConfig.uiViewName.split(".");
              var uivSegments = uiView.fqn.split(".");
              if (!angular.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
                return false;
              var negOffset = (1 - vcSegments.length) || undefined;
              var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");
              var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
              return viewConfig.uiViewContextAnchor === (uiViewContext && uiViewContext.name);
            });
            function uiViewDepth(uiView) {
              return uiView.fqn.split(".").length;
            }
            function viewConfigDepth(config) {
              var context = config.context,
                  count = 0;
              while (++count && context.parent)
                context = context.parent;
              return count;
            }
            var depthCompare = common_1.curry(function(depthFn, posNeg, left, right) {
              return posNeg * (depthFn(left) - depthFn(right));
            });
            var matchingConfigPair = function(uiView) {
              var matchingConfigs = viewConfigs.filter(matches(uiView));
              if (matchingConfigs.length > 1)
                matchingConfigs.sort(depthCompare(viewConfigDepth, -1));
              return [uiView, matchingConfigs[0]];
            };
            var configureUiView = function(_a) {
              var uiView = _a[0],
                  viewConfig = _a[1];
              if (uiViews.indexOf(uiView) !== -1)
                uiView.configUpdated(viewConfig);
            };
            uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUiView);
          };
          this.registerUiView = function register(uiView) {
            module_1.trace.traceViewServiceUiViewEvent("-> Registering", uiView);
            var fqnMatches = function(uiv) {
              return uiv.fqn === uiView.fqn;
            };
            if (uiViews.filter(fqnMatches).length)
              module_1.trace.traceViewServiceUiViewEvent("!!!! duplicate uiView named:", uiView);
            uiViews.push(uiView);
            this.sync();
            return function() {
              var idx = uiViews.indexOf(uiView);
              if (idx <= 0) {
                module_1.trace.traceViewServiceUiViewEvent("Tried removing non-registered uiView", uiView);
                return;
              }
              module_1.trace.traceViewServiceUiViewEvent("<- Deregistering", uiView);
              common_1.removeFrom(uiViews)(uiView);
            };
          };
          this.available = function() {
            return uiViews.map(common_1.prop("fqn"));
          };
          this.active = function() {
            return uiViews.filter(common_1.prop("$config")).map(common_1.prop("name"));
          };
        }
        angular.module('ui.router.state').service('$view', $View);
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(12);
        var module_2 = __webpack_require__(15);
        var module_3 = __webpack_require__(17);
        var PathFactory = (function() {
          function PathFactory() {}
          PathFactory.makeTargetState = function(path) {
            var state = common_1.tail(path).state;
            return new module_1.TargetState(state, state, path.map(common_1.prop("values")).reduce(common_1.mergeR, {}));
          };
          PathFactory.buildToPath = function(fromPath, targetState) {
            var toParams = targetState.params();
            var toParamsNodeFn = PathFactory.makeParamsNode(toParams);
            var toPath = targetState.$state().path.map(toParamsNodeFn);
            if (targetState.options().inherit)
              toPath = PathFactory.inheritParams(fromPath, toPath, Object.keys(toParams));
            return toPath;
          };
          PathFactory.inheritParams = function(fromPath, toPath, toKeys) {
            if (toKeys === void 0) {
              toKeys = [];
            }
            function nodeParamVals(path, state) {
              var node = common_1.find(path, common_1.propEq('state', state));
              return common_1.extend({}, node && node.values);
            }
            var makeInheritedParamsNode = common_1.curry(function(_fromPath, _toKeys, toNode) {
              var toParamVals = common_1.extend({}, toNode && toNode.values);
              var incomingParamVals = common_1.pick(toParamVals, _toKeys);
              toParamVals = common_1.omit(toParamVals, _toKeys);
              var fromParamVals = nodeParamVals(_fromPath, toNode.state) || {};
              var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);
              return new module_2.Node(toNode.state, ownParamVals);
            });
            return toPath.map(makeInheritedParamsNode(fromPath, toKeys));
          };
          PathFactory.bindTransNodesToPath = function(resolvePath) {
            var resolveContext = new module_3.ResolveContext(resolvePath);
            resolvePath.forEach(function(node) {
              node.resolveContext = resolveContext.isolateRootTo(node.state);
              node.resolveInjector = new module_3.ResolveInjector(node.resolveContext, node.state);
              node.resolves.$stateParams = new module_3.Resolvable("$stateParams", function() {
                return node.values;
              }, node.values);
            });
            return resolvePath;
          };
          PathFactory.treeChanges = function(fromPath, toPath, reloadState) {
            var keep = 0,
                max = Math.min(fromPath.length, toPath.length);
            var staticParams = function(state) {
              return state.parameters({inherit: false}).filter(common_1.not(common_1.prop('dynamic'))).map(common_1.prop('id'));
            };
            var nodesMatch = function(node1, node2) {
              return node1.equals(node2, staticParams(node1.state));
            };
            while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
              keep++;
            }
            function applyToParams(retainedNode, idx) {
              return module_2.Node.clone(retainedNode, {values: toPath[idx].values});
            }
            var from,
                retained,
                exiting,
                entering,
                to;
            var retainedWithToParams,
                enteringResolvePath,
                toResolvePath;
            from = fromPath;
            retained = from.slice(0, keep);
            exiting = from.slice(keep);
            retainedWithToParams = retained.map(applyToParams);
            enteringResolvePath = toPath.slice(keep);
            toResolvePath = (retainedWithToParams).concat(enteringResolvePath);
            to = PathFactory.bindTransNodesToPath(toResolvePath);
            entering = to.slice(keep);
            return {
              from: from,
              to: to,
              retained: retained,
              exiting: exiting,
              entering: entering
            };
          };
          PathFactory.bindTransitionResolve = function(treeChanges, transition) {
            var rootNode = treeChanges.to[0];
            rootNode.resolves.$transition$ = new module_3.Resolvable('$transition$', function() {
              return transition;
            }, transition);
          };
          PathFactory.makeParamsNode = common_1.curry(function(params, state) {
            return new module_2.Node(state, params);
          });
          return PathFactory;
        })();
        exports.PathFactory = PathFactory;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var param_1 = __webpack_require__(24);
        var rejectFactory_1 = __webpack_require__(28);
        var targetState_1 = __webpack_require__(29);
        var viewHooks_1 = __webpack_require__(30);
        var enterExitHooks_1 = __webpack_require__(39);
        var resolveHooks_1 = __webpack_require__(40);
        var TransitionManager = (function() {
          function TransitionManager(transition, $transitions, $urlRouter, $view, $state, $stateParams, $q, activeTransQ, changeHistory) {
            this.transition = transition;
            this.$transitions = $transitions;
            this.$urlRouter = $urlRouter;
            this.$view = $view;
            this.$state = $state;
            this.$stateParams = $stateParams;
            this.$q = $q;
            this.activeTransQ = activeTransQ;
            this.changeHistory = changeHistory;
            this.viewHooks = new viewHooks_1.ViewHooks(transition, $view);
            this.enterExitHooks = new enterExitHooks_1.EnterExitHooks(transition);
            this.resolveHooks = new resolveHooks_1.ResolveHooks(transition);
            this.treeChanges = transition.treeChanges();
            this.registerUpdateGlobalState();
            this.viewHooks.registerHooks();
            this.enterExitHooks.registerHooks();
            this.resolveHooks.registerHooks();
          }
          TransitionManager.prototype.runTransition = function() {
            var _this = this;
            this.activeTransQ.clear();
            this.activeTransQ.enqueue(this.transition);
            return this.transition.run().then(function(trans) {
              return trans.to();
            }).catch(function(error) {
              return _this.transRejected(error);
            }).finally(function() {
              return _this.activeTransQ.remove(_this.transition);
            });
          };
          TransitionManager.prototype.registerUpdateGlobalState = function() {
            this.transition.onFinish({}, this.updateGlobalState.bind(this), {priority: -10000});
          };
          TransitionManager.prototype.updateGlobalState = function() {
            var _a = this,
                treeChanges = _a.treeChanges,
                transition = _a.transition,
                $state = _a.$state,
                changeHistory = _a.changeHistory;
            $state.$current = transition.$to();
            $state.current = $state.$current.self;
            changeHistory.enqueue(treeChanges);
            this.updateStateParams();
          };
          TransitionManager.prototype.transRejected = function(error) {
            var _a = this,
                transition = _a.transition,
                $state = _a.$state,
                $stateParams = _a.$stateParams,
                $q = _a.$q;
            if (error instanceof rejectFactory_1.TransitionRejection) {
              if (error.type === rejectFactory_1.RejectType.IGNORED) {
                var dynamic = $state.$current.parameters().filter(common_1.prop('dynamic'));
                if (!param_1.Param.equals(dynamic, $stateParams, transition.params())) {
                  this.updateStateParams();
                }
                return $state.current;
              }
              if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && error.detail instanceof targetState_1.TargetState) {
                return this._redirectMgr(transition.redirect(error.detail)).runTransition();
              }
            }
            this.$transitions.defaultErrorHandler()(error);
            return $q.reject(error);
          };
          TransitionManager.prototype.updateStateParams = function() {
            var _a = this,
                transition = _a.transition,
                $urlRouter = _a.$urlRouter,
                $state = _a.$state,
                $stateParams = _a.$stateParams;
            var options = transition.options();
            $state.params = transition.params();
            common_1.copy($state.params, $stateParams);
            $stateParams.$sync().$off();
            if (options.location && $state.$current.navigable) {
              $urlRouter.push($state.$current.navigable.url, $stateParams, {replace: options.location === 'replace'});
            }
            $urlRouter.update(true);
          };
          TransitionManager.prototype._redirectMgr = function(redirect) {
            var _a = this,
                $transitions = _a.$transitions,
                $urlRouter = _a.$urlRouter,
                $view = _a.$view,
                $state = _a.$state,
                $stateParams = _a.$stateParams,
                $q = _a.$q,
                activeTransQ = _a.activeTransQ,
                changeHistory = _a.changeHistory;
            return new TransitionManager(redirect, $transitions, $urlRouter, $view, $state, $stateParams, $q, activeTransQ, changeHistory);
          };
          return TransitionManager;
        })();
        exports.TransitionManager = TransitionManager;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var coreservices_1 = __webpack_require__(4);
        var urlMatcherConfig_1 = __webpack_require__(25);
        var type_1 = __webpack_require__(26);
        var paramTypes_1 = __webpack_require__(27);
        var hasOwn = Object.prototype.hasOwnProperty;
        var isShorthand = function(cfg) {
          return ["value", "type", "squash", "array", "dynamic"].filter(hasOwn.bind(cfg || {})).length === 0;
        };
        var DefType;
        (function(DefType) {
          DefType[DefType["PATH"] = 0] = "PATH";
          DefType[DefType["SEARCH"] = 1] = "SEARCH";
          DefType[DefType["CONFIG"] = 2] = "CONFIG";
        })(DefType || (DefType = {}));
        var Param = (function() {
          function Param(id, type, config, location) {
            config = unwrapShorthand(config);
            type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;
            var isOptional = config.value !== undefined;
            var dynamic = config.dynamic === true;
            var squash = getSquashPolicy(config, isOptional);
            var replace = getReplace(config, arrayMode, isOptional, squash);
            function unwrapShorthand(config) {
              config = isShorthand(config) && {value: config} || config;
              return common_1.extend(config, {$$fn: common_1.isInjectable(config.value) ? config.value : function() {
                  return config.value;
                }});
            }
            function getType(config, urlType, location) {
              if (config.type && urlType && urlType.name !== 'string')
                throw new Error("Param '" + id + "' has two type configurations.");
              if (config.type && urlType && urlType.name === 'string' && paramTypes_1.paramTypes.type(config.type))
                return paramTypes_1.paramTypes.type(config.type);
              if (urlType)
                return urlType;
              if (!config.type)
                return (location === DefType.CONFIG ? paramTypes_1.paramTypes.type("any") : paramTypes_1.paramTypes.type("string"));
              return config.type instanceof type_1.Type ? config.type : paramTypes_1.paramTypes.type(config.type);
            }
            function getArrayMode() {
              var arrayDefaults = {array: (location === DefType.SEARCH ? "auto" : false)};
              var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
              return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            function getSquashPolicy(config, isOptional) {
              var squash = config.squash;
              if (!isOptional || squash === false)
                return false;
              if (!common_1.isDefined(squash) || squash == null)
                return urlMatcherConfig_1.matcherConfig.defaultSquashPolicy();
              if (squash === true || common_1.isString(squash))
                return squash;
              throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }
            function getReplace(config, arrayMode, isOptional, squash) {
              var replace,
                  configuredKeys,
                  defaultPolicy = [{
                    from: "",
                    to: (isOptional || arrayMode ? undefined : "")
                  }, {
                    from: null,
                    to: (isOptional || arrayMode ? undefined : "")
                  }];
              replace = common_1.isArray(config.replace) ? config.replace : [];
              if (common_1.isString(squash))
                replace.push({
                  from: squash,
                  to: undefined
                });
              configuredKeys = common_1.map(replace, common_1.prop("from"));
              return common_1.filter(defaultPolicy, function(item) {
                return configuredKeys.indexOf(item.from) === -1;
              }).concat(replace);
            }
            common_1.extend(this, {
              id: id,
              type: type,
              location: location,
              squash: squash,
              replace: replace,
              isOptional: isOptional,
              dynamic: dynamic,
              config: config,
              array: arrayMode
            });
          }
          Param.prototype.isDefaultValue = function(value) {
            return this.isOptional && this.type.equals(this.value(), value);
          };
          Param.prototype.value = function(value) {
            var _this = this;
            var $$getDefaultValue = function() {
              if (!coreservices_1.services.$injector)
                throw new Error("Injectable functions cannot be called at configuration time");
              var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);
              if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))
                throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of Type (" + _this.type.name + ")");
              return defaultValue;
            };
            var $replace = function(value) {
              var replacement = common_1.map(common_1.filter(_this.replace, common_1.propEq('from', value)), common_1.prop("to"));
              return replacement.length ? replacement[0] : value;
            };
            value = $replace(value);
            return !common_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);
          };
          Param.prototype.isSearch = function() {
            return this.location === DefType.SEARCH;
          };
          Param.prototype.validates = function(value) {
            if ((!common_1.isDefined(value) || value === null) && this.isOptional)
              return true;
            var normalized = this.type.$normalize(value);
            if (!this.type.is(normalized))
              return false;
            var encoded = this.type.encode(normalized);
            if (common_1.isString(encoded) && !this.type.pattern.exec(encoded))
              return false;
            return true;
          };
          Param.prototype.toString = function() {
            return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
          };
          Param.fromConfig = function(id, type, config) {
            return new Param(id, type, config, DefType.CONFIG);
          };
          Param.fromPath = function(id, type, config) {
            return new Param(id, type, config, DefType.PATH);
          };
          Param.fromSearch = function(id, type, config) {
            return new Param(id, type, config, DefType.SEARCH);
          };
          Param.values = function(params, values) {
            values = values || {};
            return params.map(function(param) {
              return [param.id, param.value(values[param.id])];
            }).reduce(common_1.applyPairs, {});
          };
          Param.equals = function(params, values1, values2) {
            values1 = values1 || {};
            values2 = values2 || {};
            return params.map(function(param) {
              return param.type.equals(values1[param.id], values2[param.id]);
            }).indexOf(false) === -1;
          };
          Param.validates = function(params, values) {
            values = values || {};
            return params.map(function(param) {
              return param.validates(values[param.id]);
            }).indexOf(false) === -1;
          };
          return Param;
        })();
        exports.Param = Param;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var MatcherConfig = (function() {
          function MatcherConfig() {
            this._isCaseInsensitive = false;
            this._isStrictMode = true;
            this._defaultSquashPolicy = false;
          }
          MatcherConfig.prototype.caseInsensitive = function(value) {
            return this._isCaseInsensitive = common_1.isDefined(value) ? value : this._isCaseInsensitive;
          };
          MatcherConfig.prototype.strictMode = function(value) {
            return this._isStrictMode = common_1.isDefined(value) ? value : this._isStrictMode;
          };
          MatcherConfig.prototype.defaultSquashPolicy = function(value) {
            if (common_1.isDefined(value) && value !== true && value !== false && !common_1.isString(value))
              throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return this._defaultSquashPolicy = common_1.isDefined(value) ? value : this._defaultSquashPolicy;
          };
          return MatcherConfig;
        })();
        exports.matcherConfig = new MatcherConfig();
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        function ArrayType(type, mode) {
          var _this = this;
          function arrayWrap(val) {
            return common_1.isArray(val) ? val : (common_1.isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              var arr = arrayWrap(val);
              var result = common_1.map(arr, callback);
              return (allTruthyMode === true) ? common_1.filter(result, function(val) {
                return !val;
              }).length === 0 : arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          ['encode', 'decode', 'equals', '$normalize'].map(function(name) {
            _this[name] = (name === 'equals' ? arrayEqualsHandler : arrayHandler)(type[name].bind(type));
          });
          common_1.extend(this, {
            name: type.name,
            pattern: type.pattern,
            is: arrayHandler(type.is.bind(type), true),
            $arrayMode: mode
          });
        }
        var Type = (function() {
          function Type(def) {
            this.pattern = /.*/;
            common_1.extend(this, def);
          }
          Type.prototype.is = function(val, key) {
            return true;
          };
          Type.prototype.encode = function(val, key) {
            return val;
          };
          Type.prototype.decode = function(val, key) {
            return val;
          };
          Type.prototype.equals = function(a, b) {
            return a == b;
          };
          Type.prototype.$subPattern = function() {
            var sub = this.pattern.toString();
            return sub.substr(1, sub.length - 2);
          };
          Type.prototype.toString = function() {
            return "{Type:" + this.name + "}";
          };
          Type.prototype.$normalize = function(val) {
            return this.is(val) ? val : this.decode(val);
          };
          Type.prototype.$asArray = function(mode, isSearch) {
            if (!mode)
              return this;
            if (mode === "auto" && !isSearch)
              throw new Error("'auto' array mode is for query parameters only");
            return new ArrayType(this, mode);
          };
          return Type;
        })();
        exports.Type = Type;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var coreservices_1 = __webpack_require__(4);
        var type_1 = __webpack_require__(26);
        var swapString = function(search, replace) {
          return function(val) {
            return val != null ? val.toString().replace(search, replace) : val;
          };
        };
        var valToString = swapString(/\//g, "%2F");
        var valFromString = swapString(/%2F/g, "/");
        var ParamTypes = (function() {
          function ParamTypes() {
            this.enqueue = true;
            this.typeQueue = [];
            this.defaultTypes = {
              hash: {
                encode: valToString,
                decode: valFromString,
                is: common_1.is(String),
                pattern: /.*/,
                equals: common_1.val(true)
              },
              string: {
                encode: valToString,
                decode: valFromString,
                is: common_1.is(String),
                pattern: /[^/]*/
              },
              int: {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return common_1.isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /-?\d+/
              },
              bool: {
                encode: function(val) {
                  return val && 1 || 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: common_1.is(Boolean),
                pattern: /0|1/
              },
              date: {
                encode: function(val) {
                  return !this.is(val) ? undefined : [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              json: {
                encode: common_1.toJson,
                decode: common_1.fromJson,
                is: common_1.is(Object),
                equals: common_1.equals,
                pattern: /[^/]*/
              },
              any: {
                encode: common_1.identity,
                decode: common_1.identity,
                equals: common_1.equals,
                pattern: /.*/
              }
            };
            var makeType = function(definition, name) {
              return new type_1.Type(common_1.extend({name: name}, definition));
            };
            this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});
          }
          ParamTypes.prototype.type = function(name, definition, definitionFn) {
            if (!common_1.isDefined(definition))
              return this.types[name];
            if (this.types.hasOwnProperty(name))
              throw new Error("A type named '" + name + "' has already been defined.");
            this.types[name] = new type_1.Type(common_1.extend({name: name}, definition));
            if (definitionFn) {
              this.typeQueue.push({
                name: name,
                def: definitionFn
              });
              if (!this.enqueue)
                this._flushTypeQueue();
            }
            return this;
          };
          ParamTypes.prototype._flushTypeQueue = function() {
            while (this.typeQueue.length) {
              var type = this.typeQueue.shift();
              if (type.pattern)
                throw new Error("You cannot override a type's .pattern at runtime.");
              common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));
            }
          };
          return ParamTypes;
        })();
        exports.paramTypes = new ParamTypes();
      }, function(module, exports, __webpack_require__) {
        "use strict";
        var common_1 = __webpack_require__(3);
        var coreservices_1 = __webpack_require__(4);
        (function(RejectType) {
          RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";
          RejectType[RejectType["ABORTED"] = 3] = "ABORTED";
          RejectType[RejectType["INVALID"] = 4] = "INVALID";
          RejectType[RejectType["IGNORED"] = 5] = "IGNORED";
        })(exports.RejectType || (exports.RejectType = {}));
        var RejectType = exports.RejectType;
        var TransitionRejection = (function() {
          function TransitionRejection(type, message, detail) {
            common_1.extend(this, {
              type: type,
              message: message,
              detail: detail
            });
          }
          TransitionRejection.prototype.toString = function() {
            var detailString = function(d) {
              return d && d.toString !== Object.prototype.toString ? d.toString() : JSON.stringify(d);
            };
            var type = this.type,
                message = this.message,
                detail = detailString(this.detail);
            return "TransitionRejection(type: " + type + ", message: " + message + ", detail: " + detail + ")";
          };
          return TransitionRejection;
        })();
        exports.TransitionRejection = TransitionRejection;
        var RejectFactory = (function() {
          function RejectFactory() {}
          RejectFactory.prototype.superseded = function(detail, options) {
            var message = "The transition has been superseded by a different transition (see detail).";
            var reason = new TransitionRejection(RejectType.SUPERSEDED, message, detail);
            if (options && options.redirected) {
              reason.redirected = true;
            }
            return common_1.extend(coreservices_1.services.$q.reject(reason), {reason: reason});
          };
          RejectFactory.prototype.redirected = function(detail) {
            return this.superseded(detail, {redirected: true});
          };
          RejectFactory.prototype.invalid = function(detail) {
            var message = "This transition is invalid (see detail)";
            var reason = new TransitionRejection(RejectType.INVALID, message, detail);
            return common_1.extend(coreservices_1.services.$q.reject(reason), {reason: reason});
          };
          RejectFactory.prototype.ignored = function(detail) {
            var message = "The transition was ignored.";
            var reason = new TransitionRejection(RejectType.IGNORED, message, detail);
            return common_1.extend(coreservices_1.services.$q.reject(reason), {reason: reason});
          };
          RejectFactory.prototype.aborted = function(detail) {
            var message = "The transition has been aborted.";
            var reason = new TransitionRejection(RejectType.ABORTED, message, detail);
            return common_1.extend(coreservices_1.services.$q.reject(reason), {reason: reason});
          };
          return RejectFactory;
        })();
        exports.RejectFactory = RejectFactory;
      }, function(module, exports) {
        var TargetState = (function() {
          function TargetState(_identifier, _definition, _params, _options) {
            if (_params === void 0) {
              _params = {};
            }
            if (_options === void 0) {
              _options = {};
            }
            this._identifier = _identifier;
            this._definition = _definition;
            this._options = _options;
            this._params = _params || {};
          }
          TargetState.prototype.name = function() {
            return this._definition && this._definition.name || this._identifier;
          };
          TargetState.prototype.identifier = function() {
            return this._identifier;
          };
          TargetState.prototype.params = function() {
            return this._params;
          };
          TargetState.prototype.$state = function() {
            return this._definition;
          };
          TargetState.prototype.state = function() {
            return this._definition && this._definition.self;
          };
          TargetState.prototype.options = function() {
            return this._options;
          };
          TargetState.prototype.exists = function() {
            return !!(this._definition && this._definition.self);
          };
          TargetState.prototype.valid = function() {
            return !this.error();
          };
          TargetState.prototype.error = function() {
            var base = this.options().relative;
            if (!this._definition && !!base) {
              var stateName = base.name ? base.name : base;
              return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
            }
            if (!this._definition)
              return "No such state '" + this.name() + "'";
            if (!this._definition.self)
              return "State '" + this.name() + "' has an invalid definition";
          };
          return TargetState;
        })();
        exports.TargetState = TargetState;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var coreservices_1 = __webpack_require__(4);
        var angular1_1 = __webpack_require__(31);
        var ViewHooks = (function() {
          function ViewHooks(transition, $view) {
            this.transition = transition;
            this.$view = $view;
            this.treeChanges = transition.treeChanges();
            this.enteringViews = transition.views("entering");
            this.exitingViews = transition.views("exiting");
          }
          ViewHooks.prototype.loadAllEnteringViews = function() {
            var _this = this;
            var loadView = function(vc) {
              var resolveInjector = common_1.find(_this.treeChanges.to, common_1.propEq('state', vc.context)).resolveInjector;
              return _this.$view.load(vc, resolveInjector);
            };
            return coreservices_1.services.$q.all(this.enteringViews.map(loadView)).then(common_1.noop);
          };
          ViewHooks.prototype.loadAllControllerLocals = function() {
            var _this = this;
            var loadLocals = function(vc) {
              var deps = angular1_1.annotateController(vc.controller);
              var resolveInjector = common_1.find(_this.treeChanges.to, common_1.propEq('state', vc.context)).resolveInjector;
              function $loadControllerLocals() {}
              $loadControllerLocals.$inject = deps;
              return coreservices_1.services.$q.all(resolveInjector.getLocals($loadControllerLocals)).then(function(locals) {
                return vc.locals = locals;
              });
            };
            var loadAllLocals = this.enteringViews.filter(function(vc) {
              return !!vc.controller;
            }).map(loadLocals);
            return coreservices_1.services.$q.all(loadAllLocals).then(common_1.noop);
          };
          ViewHooks.prototype.updateViews = function() {
            var $view = this.$view;
            this.exitingViews.forEach(function(viewConfig) {
              return $view.reset(viewConfig);
            });
            this.enteringViews.forEach(function(viewConfig) {
              return $view.registerStateViewConfig(viewConfig);
            });
            $view.sync();
          };
          ViewHooks.prototype.registerHooks = function() {
            if (this.enteringViews.length) {
              this.transition.onStart({}, this.loadAllEnteringViews.bind(this));
              this.transition.onFinish({}, this.loadAllControllerLocals.bind(this));
            }
            if (this.exitingViews.length || this.enteringViews.length)
              this.transition.onSuccess({}, this.updateViews.bind(this));
          };
          return ViewHooks;
        })();
        exports.ViewHooks = ViewHooks;
      }, function(module, exports, __webpack_require__) {
        var router_1 = __webpack_require__(32);
        var coreservices_1 = __webpack_require__(4);
        var common_1 = __webpack_require__(3);
        var app = angular.module("ui.router.angular1", []);
        function annotateController(controllerExpression) {
          var $injector = coreservices_1.services.$injector;
          var $controller = $injector.get("$controller");
          var oldInstantiate = $injector.instantiate;
          try {
            var deps;
            $injector.instantiate = function fakeInstantiate(constructorFunction) {
              $injector.instantiate = oldInstantiate;
              deps = $injector.annotate(constructorFunction);
            };
            $controller(controllerExpression, {$scope: {}});
            return deps;
          } finally {
            $injector.instantiate = oldInstantiate;
          }
        }
        exports.annotateController = annotateController;
        runBlock.$inject = ['$injector', '$q'];
        function runBlock($injector, $q) {
          coreservices_1.services.$injector = $injector;
          coreservices_1.services.$q = $q;
        }
        app.run(runBlock);
        var bindFunctions = function(fnNames, from, to) {
          return fnNames.forEach(function(name) {
            return to[name] = from[name].bind(from);
          });
        };
        var router = null;
        ng1UIRouter.$inject = ['$locationProvider'];
        function ng1UIRouter($locationProvider) {
          router = new router_1.Router();
          bindFunctions(['hashPrefix'], $locationProvider, coreservices_1.services.locationConfig);
          this.$get = $get;
          $get.$inject = ['$location', '$browser', '$sniffer'];
          function $get($location, $browser, $sniffer) {
            coreservices_1.services.locationConfig.html5Mode = function() {
              var html5Mode = $locationProvider.html5Mode();
              html5Mode = common_1.isObject(html5Mode) ? html5Mode.enabled : html5Mode;
              return html5Mode && $sniffer.history;
            };
            bindFunctions(["replace", "url", "path", "search", "hash"], $location, coreservices_1.services.location);
            bindFunctions(['port', 'protocol', 'host'], $location, coreservices_1.services.locationConfig);
            bindFunctions(['baseHref'], $browser, coreservices_1.services.locationConfig);
            return router;
          }
        }
        angular.module('ui.router.init', []).provider("ng1UIRouter", ng1UIRouter);
        angular.module('ui.router.util').provider('$urlMatcherFactory', ['ng1UIRouterProvider', function() {
          return router.urlMatcherFactory;
        }]);
        angular.module('ui.router.router').provider('$urlRouter', ['ng1UIRouterProvider', function() {
          return router.urlRouterProvider;
        }]);
        angular.module('ui.router.state').provider('$state', ['ng1UIRouterProvider', function() {
          return router.stateProvider;
        }]);
        angular.module('ui.router.init').run(['ng1UIRouter', function(ng1UIRouter) {}]);
        angular.module('ui.router.state').run(['$state', function($state) {}]);
        angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      }, function(module, exports, __webpack_require__) {
        var urlMatcherFactory_1 = __webpack_require__(33);
        var urlRouter_1 = __webpack_require__(38);
        var state_1 = __webpack_require__(14);
        var Router = (function() {
          function Router() {
            this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();
            this.urlRouterProvider = new urlRouter_1.$UrlRouterProvider(this.urlMatcherFactory);
            this.stateProvider = new state_1.$StateProvider(this.urlRouterProvider, this.urlMatcherFactory);
          }
          return Router;
        })();
        exports.Router = Router;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(34);
        var module_2 = __webpack_require__(36);
        function getDefaultConfig() {
          return {
            strict: module_1.matcherConfig.strictMode(),
            caseInsensitive: module_1.matcherConfig.caseInsensitive()
          };
        }
        var UrlMatcherFactory = (function() {
          function UrlMatcherFactory() {
            common_1.extend(this, {
              UrlMatcher: module_1.UrlMatcher,
              Param: module_2.Param
            });
          }
          UrlMatcherFactory.prototype.caseInsensitive = function(value) {
            return module_1.matcherConfig.caseInsensitive(value);
          };
          UrlMatcherFactory.prototype.strictMode = function(value) {
            return module_1.matcherConfig.strictMode(value);
          };
          UrlMatcherFactory.prototype.defaultSquashPolicy = function(value) {
            return module_1.matcherConfig.defaultSquashPolicy(value);
          };
          UrlMatcherFactory.prototype.compile = function(pattern, config) {
            return new module_1.UrlMatcher(pattern, common_1.extend(getDefaultConfig(), config));
          };
          UrlMatcherFactory.prototype.isMatcher = function(object) {
            if (!common_1.isObject(object))
              return false;
            var result = true;
            common_1.forEach(module_1.UrlMatcher.prototype, function(val, name) {
              if (common_1.isFunction(val))
                result = result && (common_1.isDefined(object[name]) && common_1.isFunction(object[name]));
            });
            return result;
          };
          ;
          UrlMatcherFactory.prototype.type = function(name, definition, definitionFn) {
            var type = module_2.paramTypes.type(name, definition, definitionFn);
            return !common_1.isDefined(definition) ? type : this;
          };
          ;
          UrlMatcherFactory.prototype.$get = function() {
            module_2.paramTypes.enqueue = false;
            module_2.paramTypes._flushTypeQueue();
            return this;
          };
          ;
          return UrlMatcherFactory;
        })();
        exports.UrlMatcherFactory = UrlMatcherFactory;
      }, function(module, exports, __webpack_require__) {
        function __export(m) {
          for (var p in m)
            if (!exports.hasOwnProperty(p))
              exports[p] = m[p];
        }
        __export(__webpack_require__(35));
        __export(__webpack_require__(25));
        __export(__webpack_require__(33));
        __export(__webpack_require__(38));
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(36);
        function quoteRegExp(string, param) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!param)
            return result;
          switch (param.squash) {
            case false:
              surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];
              break;
            case true:
              surroundPattern = ['?(', ')?'];
              break;
            default:
              surroundPattern = [("(" + param.squash + "|"), ')?'];
              break;
          }
          return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
        }
        var memoizeTo = function(obj, prop, fn) {
          return obj[prop] = obj[prop] || fn();
        };
        var UrlMatcher = (function() {
          function UrlMatcher(pattern, config) {
            var _this = this;
            this.pattern = pattern;
            this.config = config;
            this._cache = {
              path: [],
              pattern: null
            };
            this._children = [];
            this._params = [];
            this._segments = [];
            this._compiled = [];
            this.config = common_1.defaults(this.config, {
              params: {},
              strict: true,
              caseInsensitive: false,
              paramMap: common_1.identity
            });
            var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
                searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
                last = 0,
                m,
                patterns = [];
            var checkParamErrors = function(id) {
              if (!UrlMatcher.nameValidator.test(id))
                throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
              if (common_1.find(_this._params, common_1.propEq('id', id)))
                throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            };
            var matchDetails = function(m, isSearch) {
              var id = m[2] || m[3],
                  regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);
              return {
                id: id,
                regexp: regexp,
                cfg: _this.config.params[id],
                segment: pattern.substring(last, m.index),
                type: !regexp ? null : module_1.paramTypes.type(regexp || "string") || common_1.inherit(module_1.paramTypes.type("string"), {pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)})
              };
            };
            var p,
                param,
                segment;
            while ((m = placeholder.exec(pattern))) {
              p = matchDetails(m, false);
              if (p.segment.indexOf('?') >= 0)
                break;
              checkParamErrors(p.id);
              this._params.push(module_1.Param.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));
              this._segments.push(p.segment);
              patterns.push([p.segment, common_1.tail(this._params)]);
              last = placeholder.lastIndex;
            }
            segment = pattern.substring(last);
            var i = segment.indexOf('?');
            if (i >= 0) {
              var search = segment.substring(i);
              segment = segment.substring(0, i);
              if (search.length > 0) {
                last = 0;
                while ((m = searchPlaceholder.exec(search))) {
                  p = matchDetails(m, true);
                  checkParamErrors(p.id);
                  this._params.push(module_1.Param.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));
                  last = placeholder.lastIndex;
                }
              }
            }
            this._segments.push(segment);
            common_1.extend(this, {
              _compiled: patterns.map(function(pattern) {
                return quoteRegExp.apply(null, pattern);
              }).concat(quoteRegExp(segment)),
              prefix: this._segments[0]
            });
            Object.freeze(this);
          }
          UrlMatcher.prototype.append = function(url) {
            this._children.push(url);
            common_1.forEach(url._cache, function(val, key) {
              return url._cache[key] = common_1.isArray(val) ? [] : null;
            });
            url._cache.path = this._cache.path.concat(this);
            return url;
          };
          UrlMatcher.prototype.isRoot = function() {
            return this._cache.path.length === 0;
          };
          UrlMatcher.prototype.toString = function() {
            return this.pattern;
          };
          UrlMatcher.prototype.exec = function(path, search, hash, options) {
            var _this = this;
            if (search === void 0) {
              search = {};
            }
            if (options === void 0) {
              options = {};
            }
            var match = memoizeTo(this._cache, 'pattern', function() {
              return new RegExp(['^', common_1.unnest(_this._cache.path.concat(_this).map(common_1.prop('_compiled'))).join(''), _this.config.strict === false ? '\/?' : '', '$'].join(''), _this.config.caseInsensitive ? 'i' : undefined);
            }).exec(path);
            if (!match)
              return null;
            var allParams = this.parameters(),
                pathParams = allParams.filter(function(param) {
                  return !param.isSearch();
                }),
                searchParams = allParams.filter(function(param) {
                  return param.isSearch();
                }),
                nPathSegments = this._cache.path.concat(this).map(function(urlm) {
                  return urlm._segments.length - 1;
                }).reduce(function(a, x) {
                  return a + x;
                }),
                values = {};
            if (nPathSegments !== match.length - 1)
              throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
            function decodePathArray(string) {
              var reverseString = function(str) {
                return str.split("").reverse().join("");
              };
              var unquoteDashes = function(str) {
                return str.replace(/\\-/g, "-");
              };
              var split = reverseString(string).split(/-(?!\\)/);
              var allReversed = common_1.map(split, reverseString);
              return common_1.map(allReversed, unquoteDashes).reverse();
            }
            for (var i = 0; i < nPathSegments; i++) {
              var param = pathParams[i];
              var value = match[i + 1];
              for (var j = 0; j < param.replace; j++) {
                if (param.replace[j].from === value)
                  value = param.replace[j].to;
              }
              if (value && param.array === true)
                value = decodePathArray(value);
              values[param.id] = param.value(value);
            }
            common_1.forEach(searchParams, function(param) {
              values[param.id] = param.value(search[param.id]);
            });
            if (hash)
              values["#"] = hash;
            return values;
          };
          UrlMatcher.prototype.parameters = function(opts) {
            if (opts === void 0) {
              opts = {};
            }
            if (opts.inherit === false)
              return this._params;
            return common_1.unnest(this._cache.path.concat(this).map(common_1.prop('_params')));
          };
          UrlMatcher.prototype.parameter = function(id, opts) {
            if (opts === void 0) {
              opts = {};
            }
            var parent = common_1.tail(this._cache.path);
            return (common_1.find(this._params, common_1.propEq('id', id)) || (opts.inherit !== false && parent && parent.parameter(id)) || null);
          };
          UrlMatcher.prototype.validates = function(params) {
            var _this = this;
            var validParamVal = function(param, val) {
              return !param || param.validates(val);
            };
            return common_1.pairs(params || {}).map(function(_a) {
              var key = _a[0],
                  val = _a[1];
              return validParamVal(_this.parameter(key), val);
            }).reduce(common_1.allTrueR, true);
          };
          UrlMatcher.prototype.format = function(values) {
            if (values === void 0) {
              values = {};
            }
            var segments = this._segments,
                result = segments[0],
                search = false,
                params = this.parameters({inherit: false}),
                parent = common_1.tail(this._cache.path);
            if (!this.validates(values))
              return null;
            function encodeDashes(str) {
              return encodeURIComponent(str).replace(/-/g, function(c) {
                return ("%5C%" + c.charCodeAt(0).toString(16).toUpperCase());
              });
            }
            params.map(function(param, i) {
              var isPathParam = i < segments.length - 1;
              var value = param.value(values[param.id]);
              var isDefaultValue = param.isDefaultValue(value);
              var squash = isDefaultValue ? param.squash : false;
              var encoded = param.type.encode(value);
              if (!isPathParam) {
                if (encoded == null || (isDefaultValue && squash !== false))
                  return;
                if (!common_1.isArray(encoded))
                  encoded = [encoded];
                encoded = common_1.map(encoded, encodeURIComponent).join("&" + param.id + "=");
                result += (search ? '&' : '?') + (param.id + "=" + encoded);
                search = true;
                return;
              }
              result += (function(segment, result) {
                if (squash === true)
                  return segment.match(result.match(/\/$/) ? /\/?(.*)/ : /(.*)/)[1];
                if (common_1.isString(squash))
                  return squash + segment;
                if (squash !== false)
                  return "";
                if (encoded == null)
                  return segment;
                if (common_1.isArray(encoded))
                  return common_1.map(encoded, encodeDashes).join("-") + segment;
                if (param.type.raw)
                  return encoded + segment;
                return encodeURIComponent(encoded) + segment;
              })(segments[i + 1], result);
            });
            if (values["#"])
              result += "#" + values["#"];
            var processedParams = ['#'].concat(params.map(common_1.prop('id')));
            return (parent && parent.format(common_1.omit(values, processedParams)) || '') + result;
          };
          UrlMatcher.nameValidator = /^\w+(-+\w+)*(?:\[\])?$/;
          return UrlMatcher;
        })();
        exports.UrlMatcher = UrlMatcher;
      }, function(module, exports, __webpack_require__) {
        function __export(m) {
          for (var p in m)
            if (!exports.hasOwnProperty(p))
              exports[p] = m[p];
        }
        __export(__webpack_require__(24));
        __export(__webpack_require__(27));
        __export(__webpack_require__(37));
        __export(__webpack_require__(26));
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var StateParams = (function() {
          function StateParams(params) {
            if (params === void 0) {
              params = {};
            }
            common_1.extend(this, params);
          }
          StateParams.prototype.$digest = function() {};
          StateParams.prototype.$inherit = function(newParams, $current, $to) {};
          StateParams.prototype.$set = function(params, url) {};
          StateParams.prototype.$sync = function() {};
          StateParams.prototype.$off = function() {};
          StateParams.prototype.$raw = function() {};
          StateParams.prototype.$localize = function(state, params) {};
          StateParams.prototype.$observe = function(key, fn) {};
          return StateParams;
        })();
        exports.StateParams = StateParams;
        $StateParamsProvider.$inject = [];
        function $StateParamsProvider() {
          function stateParamsFactory() {
            var observers = {},
                current = {};
            function unhook(key, func) {
              return function() {
                common_1.forEach(key.split(" "), function(k) {
                  return observers[k].splice(observers[k].indexOf(func), 1);
                });
              };
            }
            function observeChange(key, val) {
              if (!observers[key] || !observers[key].length)
                return;
              common_1.forEach(observers[key], function(func) {
                return func(val);
              });
            }
            StateParams.prototype.$digest = function() {
              var _this = this;
              common_1.forEach(this, function(val, key) {
                if (val === current[key] || !_this.hasOwnProperty(key))
                  return;
                current[key] = val;
                observeChange(key, val);
              });
            };
            StateParams.prototype.$inherit = function(newParams, $current, $to) {
              var parents = common_1.ancestors($current, $to),
                  parentParams,
                  inherited = {},
                  inheritList = [];
              for (var i in parents) {
                if (!parents[i].params)
                  continue;
                parentParams = Object.keys(parents[i].params);
                if (!parentParams.length)
                  continue;
                for (var j in parentParams) {
                  if (inheritList.indexOf(parentParams[j]) >= 0)
                    continue;
                  inheritList.push(parentParams[j]);
                  inherited[parentParams[j]] = this[parentParams[j]];
                }
              }
              return common_1.extend({}, inherited, newParams);
            };
            StateParams.prototype.$set = function(params, url) {
              var _this = this;
              var hasChanged = false,
                  abort = false;
              if (url) {
                common_1.forEach(params, function(val, key) {
                  if ((url.parameter(key) || {}).dynamic !== true)
                    abort = true;
                });
              }
              if (abort)
                return false;
              common_1.forEach(params, function(val, key) {
                if (val !== _this[key]) {
                  _this[key] = val;
                  observeChange(key);
                  hasChanged = true;
                }
              });
              this.$sync();
              return hasChanged;
            };
            StateParams.prototype.$sync = function() {
              common_1.copy(this, current);
              return this;
            };
            StateParams.prototype.$off = function() {
              observers = {};
              return this;
            };
            StateParams.prototype.$raw = function() {
              return common_1.omit(this, Object.keys(this).filter(StateParams.prototype.hasOwnProperty.bind(StateParams.prototype)));
            };
            StateParams.prototype.$localize = function(state, params) {
              return new StateParams(common_1.pick(params || this, Object.keys(state.params)));
            };
            StateParams.prototype.$observe = function(key, fn) {
              common_1.forEach(key.split(" "), function(k) {
                return (observers[k] || (observers[k] = [])).push(fn);
              });
              return unhook(key, fn);
            };
            return new StateParams();
          }
          var global = stateParamsFactory();
          this.$get = $get;
          $get.$inject = ['$rootScope'];
          function $get($rootScope) {
            $rootScope.$watch(function() {
              global.$digest();
            });
            return global;
          }
        }
        angular.module('ui.router.state').provider('$stateParams', $StateParamsProvider);
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var coreservices_1 = __webpack_require__(4);
        var $location = coreservices_1.services.location;
        function $UrlRouterProvider($urlMatcherFactory) {
          var rules = [],
              otherwise = null,
              interceptDeferred = false,
              listener;
          function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
          }
          function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
              return match[what === '$' ? 0 : Number(what)];
            });
          }
          this.rule = function(rule) {
            if (!common_1.isFunction(rule))
              throw new Error("'rule' must be a function");
            rules.push(rule);
            return this;
          };
          this.otherwise = function(rule) {
            if (!common_1.isFunction(rule) && !common_1.isString(rule))
              throw new Error("'rule' must be a string or function");
            otherwise = common_1.isString(rule) ? function() {
              return rule;
            } : rule;
            return this;
          };
          function handleIfMatch($injector, handler, match) {
            if (!match)
              return false;
            var result = $injector.invoke(handler, handler, {$match: match});
            return common_1.isDefined(result) ? result : true;
          }
          this.when = function(what, handler) {
            var redirect,
                handlerIsString = common_1.isString(handler);
            if (common_1.isString(what))
              what = $urlMatcherFactory.compile(what);
            if (!handlerIsString && !common_1.isFunction(handler) && !common_1.isArray(handler))
              throw new Error("invalid 'handler' in when()");
            var strategies = {
              matcher: function(what, handler) {
                if (handlerIsString) {
                  redirect = $urlMatcherFactory.compile(handler);
                  handler = ['$match', redirect.format.bind(redirect)];
                }
                return common_1.extend(function() {
                  return handleIfMatch(coreservices_1.services.$injector, handler, what.exec($location.path(), $location.search(), $location.hash()));
                }, {prefix: common_1.isString(what.prefix) ? what.prefix : ''});
              },
              regex: function(what, handler) {
                if (what.global || what.sticky)
                  throw new Error("when() RegExp must not be global or sticky");
                if (handlerIsString) {
                  redirect = handler;
                  handler = ['$match', function($match) {
                    return interpolate(redirect, $match);
                  }];
                }
                return common_1.extend(function() {
                  return handleIfMatch(coreservices_1.services.$injector, handler, what.exec($location.path()));
                }, {prefix: regExpPrefix(what)});
              }
            };
            var check = {
              matcher: $urlMatcherFactory.isMatcher(what),
              regex: what instanceof RegExp
            };
            for (var n in check) {
              if (check[n])
                return this.rule(strategies[n](what, handler));
            }
            throw new Error("invalid 'what' in when()");
          };
          this.deferIntercept = function(defer) {
            if (defer === undefined)
              defer = true;
            interceptDeferred = defer;
          };
          this.$get = $get;
          $get.$inject = ['$rootScope'];
          function $get($rootScope) {
            var location = $location.url();
            function appendBasePath(url, isHtml5, absolute) {
              var baseHref = coreservices_1.services.locationConfig.baseHref();
              if (baseHref === '/')
                return url;
              if (isHtml5)
                return baseHref.slice(0, -1) + url;
              if (absolute)
                return baseHref.slice(1) + url;
              return url;
            }
            function update(evt) {
              if (evt && evt.defaultPrevented)
                return;
              function check(rule) {
                var handled = rule(coreservices_1.services.$injector, $location);
                if (!handled)
                  return false;
                if (common_1.isString(handled)) {
                  $location.replace();
                  $location.url(handled);
                }
                return true;
              }
              var n = rules.length,
                  i;
              for (i = 0; i < n; i++) {
                if (check(rules[i]))
                  return;
              }
              if (otherwise)
                check(otherwise);
            }
            function listen() {
              listener = listener || $rootScope.$on('$locationChangeSuccess', update);
              return listener;
            }
            if (!interceptDeferred)
              listen();
            return {
              sync: function() {
                update();
              },
              listen: function() {
                return listen();
              },
              update: function(read) {
                if (read) {
                  location = $location.url();
                  return;
                }
                if ($location.url() === location)
                  return;
                $location.url(location);
                $location.replace();
              },
              push: function(urlMatcher, params, options) {
                $location.url(urlMatcher.format(params || {}));
                if (options && options.replace)
                  $location.replace();
              },
              href: function(urlMatcher, params, options) {
                if (!urlMatcher.validates(params))
                  return null;
                var url = urlMatcher.format(params);
                options = options || {};
                var cfg = coreservices_1.services.locationConfig;
                var isHtml5 = cfg.html5Mode();
                if (!isHtml5 && url !== null) {
                  url = "#" + cfg.hashPrefix() + url;
                }
                url = appendBasePath(url, isHtml5, options.absolute);
                if (!options.absolute || !url) {
                  return url;
                }
                var slash = (!isHtml5 && url ? '/' : ''),
                    port = cfg.port();
                port = (port === 80 || port === 443 ? '' : ':' + port);
                return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');
              }
            };
          }
        }
        exports.$UrlRouterProvider = $UrlRouterProvider;
      }, function(module, exports) {
        var EnterExitHooks = (function() {
          function EnterExitHooks(transition) {
            this.transition = transition;
          }
          EnterExitHooks.prototype.registerHooks = function() {
            this.registerOnEnterHooks();
            this.registerOnRetainHooks();
            this.registerOnExitHooks();
          };
          EnterExitHooks.prototype.registerOnEnterHooks = function() {
            var _this = this;
            var onEnterRegistration = function(state) {
              return _this.transition.onEnter({to: state.name}, state.onEnter);
            };
            this.transition.entering().filter(function(state) {
              return !!state.onEnter;
            }).forEach(onEnterRegistration);
          };
          EnterExitHooks.prototype.registerOnRetainHooks = function() {
            var _this = this;
            var onRetainRegistration = function(state) {
              return _this.transition.onRetain({}, state.onRetain);
            };
            this.transition.retained().filter(function(state) {
              return !!state.onRetain;
            }).forEach(onRetainRegistration);
          };
          EnterExitHooks.prototype.registerOnExitHooks = function() {
            var _this = this;
            var onExitRegistration = function(state) {
              return _this.transition.onExit({from: state.name}, state.onExit);
            };
            this.transition.exiting().filter(function(state) {
              return !!state.onExit;
            }).forEach(onExitRegistration);
          };
          return EnterExitHooks;
        })();
        exports.EnterExitHooks = EnterExitHooks;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var interface_1 = __webpack_require__(19);
        var LAZY = interface_1.ResolvePolicy[interface_1.ResolvePolicy.LAZY];
        var EAGER = interface_1.ResolvePolicy[interface_1.ResolvePolicy.EAGER];
        var ResolveHooks = (function() {
          function ResolveHooks(transition) {
            this.transition = transition;
          }
          ResolveHooks.prototype.registerHooks = function() {
            var treeChanges = this.transition.treeChanges();
            $eagerResolvePath.$inject = ['$transition$'];
            function $eagerResolvePath($transition$) {
              return common_1.tail(treeChanges.to).resolveContext.resolvePath(common_1.extend({transition: $transition$}, {resolvePolicy: EAGER}));
            }
            $lazyResolveEnteringState.$inject = ['$state$', '$transition$'];
            function $lazyResolveEnteringState($state$, $transition$) {
              var node = common_1.find(treeChanges.entering, common_1.propEq('state', $state$));
              return node.resolveContext.resolvePathElement(node.state, common_1.extend({transition: $transition$}, {resolvePolicy: LAZY}));
            }
            this.transition.onStart({}, $eagerResolvePath, {priority: 1000});
            this.transition.onEnter({}, $lazyResolveEnteringState, {priority: 1000});
          };
          return ResolveHooks;
        })();
        exports.ResolveHooks = ResolveHooks;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(36);
        var parseUrl = function(url) {
          if (!common_1.isString(url))
            return false;
          var root = url.charAt(0) === '^';
          return {
            val: root ? url.substring(1) : url,
            root: root
          };
        };
        var StateBuilder = (function() {
          function StateBuilder(root, matcher, $urlMatcherFactoryProvider) {
            this.matcher = matcher;
            var self = this;
            this.builders = {
              parent: [function(state) {
                if (state === root())
                  return null;
                return matcher.find(self.parentName(state)) || root();
              }],
              data: [function(state) {
                if (state.parent && state.parent.data) {
                  state.data = state.self.data = common_1.extend({}, state.parent.data, state.data);
                }
                return state.data;
              }],
              url: [function(state) {
                var stateDec = state;
                var parsed = parseUrl(stateDec.url),
                    parent = state.parent;
                var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {
                  params: state.params || {},
                  paramMap: function(paramConfig, isSearch) {
                    if (stateDec.reloadOnSearch === false && isSearch)
                      paramConfig = common_1.extend(paramConfig || {}, {dynamic: true});
                    return paramConfig;
                  }
                });
                if (!url)
                  return null;
                if (!$urlMatcherFactoryProvider.isMatcher(url))
                  throw new Error("Invalid url '" + url + "' in state '" + state + "'");
                return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);
              }],
              navigable: [function(state) {
                return (state !== root()) && state.url ? state : (state.parent ? state.parent.navigable : null);
              }],
              params: [function(state) {
                var makeConfigParam = function(config, id) {
                  return module_1.Param.fromConfig(id, null, config);
                };
                var urlParams = (state.url && state.url.parameters({inherit: false})) || [];
                var nonUrlParams = common_1.values(common_1.map(common_1.omit(state.params || {}, urlParams.map(common_1.prop('id'))), makeConfigParam));
                return urlParams.concat(nonUrlParams).map(function(p) {
                  return [p.id, p];
                }).reduce(common_1.applyPairs, {});
              }],
              views: [function(state) {
                var views = {},
                    tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'],
                    ctrlKeys = ['controller', 'controllerProvider', 'controllerAs'];
                var allKeys = tplKeys.concat(ctrlKeys);
                common_1.forEach(state.views || {"$default": common_1.pick(state, allKeys)}, function(config, name) {
                  name = name || "$default";
                  common_1.forEach(ctrlKeys, function(key) {
                    if (state[key] && !config[key])
                      config[key] = state[key];
                  });
                  if (Object.keys(config).length > 0)
                    views[name] = config;
                });
                return views;
              }],
              path: [function(state) {
                return state.parent ? state.parent.path.concat(state) : [state];
              }],
              includes: [function(state) {
                var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};
                includes[state.name] = true;
                return includes;
              }]
            };
          }
          StateBuilder.prototype.builder = function(name, fn) {
            var builders = this.builders;
            var array = builders[name] || [];
            if (common_1.isString(name) && !common_1.isDefined(fn))
              return array.length > 1 ? array : array[0];
            if (!common_1.isString(name) || !common_1.isFunction(fn))
              return;
            builders[name] = array;
            builders[name].push(fn);
            return function() {
              return builders[name].splice(builders[name].indexOf(fn, 1)) && null;
            };
          };
          StateBuilder.prototype.build = function(state) {
            var _a = this,
                matcher = _a.matcher,
                builders = _a.builders;
            var parent = this.parentName(state);
            if (parent && !matcher.find(parent))
              return null;
            for (var key in builders) {
              if (!builders.hasOwnProperty(key))
                continue;
              var chain = builders[key].reduce(function(parentFn, step) {
                return function(state) {
                  return step(state, parentFn);
                };
              }, common_1.noop);
              state[key] = chain(state);
            }
            return state;
          };
          StateBuilder.prototype.parentName = function(state) {
            var name = state.name || "";
            if (name.indexOf('.') !== -1)
              return name.substring(0, name.lastIndexOf('.'));
            if (!state.parent)
              return "";
            return common_1.isString(state.parent) ? state.parent : state.parent.name;
          };
          StateBuilder.prototype.name = function(state) {
            var name = state.name;
            if (name.indexOf('.') !== -1 || !state.parent)
              return name;
            var parentName = common_1.isString(state.parent) ? state.parent : state.parent.name;
            return parentName ? parentName + "." + name : name;
          };
          return StateBuilder;
        })();
        exports.StateBuilder = StateBuilder;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(9);
        function parseStateRef(ref, current) {
          var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
              parsed;
          if (preparsed)
            ref = current + '(' + preparsed[1] + ')';
          parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
          if (!parsed || parsed.length !== 4)
            throw new Error("Invalid state ref '" + ref + "'");
          return {
            state: parsed[1],
            paramExpr: parsed[3] || null
          };
        }
        function stateContext(el) {
          var stateData = el.parent().inheritedData('$uiView');
          if (stateData && stateData.context && stateData.context.name) {
            return stateData.context;
          }
        }
        $StateRefDirective.$inject = ['$state', '$timeout'];
        function $StateRefDirective($state, $timeout) {
          return {
            restrict: 'A',
            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
            link: function(scope, element, attrs, uiSrefActive) {
              var ref = parseStateRef(attrs.uiSref, $state.current.name);
              var params = null,
                  base = stateContext(element) || $state.$current;
              var newHref = null,
                  isAnchor = element.prop("tagName") === "A";
              var isForm = element[0].nodeName === "FORM";
              var attr = isForm ? "action" : "href",
                  nav = true;
              var srefOpts = scope.$eval(attrs.uiSrefOpts);
              var defaultSrefOpts = {
                relative: base,
                inherit: true
              };
              var options = common_1.defaults(srefOpts, defaultSrefOpts, module_1.defaultTransOpts);
              var update = function(newVal) {
                if (newVal)
                  params = common_1.copy(newVal);
                if (!nav)
                  return;
                newHref = $state.href(ref.state, params, options);
                var activeDirective = uiSrefActive[1] || uiSrefActive[0];
                if (activeDirective) {
                  activeDirective.$$addStateInfo(ref.state, params);
                }
                if (newHref === null) {
                  nav = false;
                  return false;
                }
                attrs.$set(attr, newHref);
              };
              if (ref.paramExpr) {
                scope.$watch(ref.paramExpr, function(newVal) {
                  if (newVal !== params)
                    update(newVal);
                }, true);
                params = common_1.copy(scope.$eval(ref.paramExpr));
              }
              update();
              if (isForm)
                return;
              element.bind("click", function(e) {
                var button = e.which || e.button;
                if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                  var transition = $timeout(function() {
                    $state.go(ref.state, params, options);
                  });
                  e.preventDefault();
                  var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                  e.preventDefault = function() {
                    if (ignorePreventDefaultCount-- <= 0)
                      $timeout.cancel(transition);
                  };
                }
              });
            }
          };
        }
        $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
        function $StateRefActiveDirective($state, $stateParams, $interpolate) {
          return {
            restrict: "A",
            controller: ['$scope', '$element', '$attrs', '$timeout', '$transitions', function($scope, $element, $attrs, $timeout, $transitions) {
              var states = [],
                  activeClasses = {},
                  activeEqClass;
              activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
              var uiSrefActive = $scope.$eval($attrs.uiSrefActive) || $interpolate($attrs.uiSrefActive || '', false)($scope);
              if (common_1.isObject(uiSrefActive)) {
                common_1.forEach(uiSrefActive, function(stateOrName, activeClass) {
                  if (common_1.isString(stateOrName)) {
                    var ref = parseStateRef(stateOrName, $state.current.name);
                    addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                  }
                });
              }
              this.$$addStateInfo = function(newState, newParams) {
                if (common_1.isObject(uiSrefActive) && states.length > 0) {
                  return;
                }
                addState(newState, newParams, uiSrefActive);
                update();
              };
              $scope.$on('$stateChangeSuccess', update);
              function addState(stateName, stateParams, activeClass) {
                var state = $state.get(stateName, stateContext($element));
                var stateHash = createStateHash(stateName, stateParams);
                states.push({
                  state: state || {name: stateName},
                  params: stateParams,
                  hash: stateHash
                });
                activeClasses[stateHash] = activeClass;
              }
              updateAfterTransition.$inject = ['$transition$'];
              function updateAfterTransition($transition$) {
                $transition$.promise.then(update);
              }
              ;
              var deregisterFn = $transitions.onStart({}, updateAfterTransition);
              $scope.$on('$destroy', deregisterFn);
              function createStateHash(state, params) {
                if (!common_1.isString(state)) {
                  throw new Error('state should be a string');
                }
                if (common_1.isObject(params)) {
                  return state + common_1.toJson(params);
                }
                params = $scope.$eval(params);
                if (common_1.isObject(params)) {
                  return state + common_1.toJson(params);
                }
                return state;
              }
              function update() {
                for (var i = 0; i < states.length; i++) {
                  if (anyMatch(states[i].state, states[i].params)) {
                    addClass($element, activeClasses[states[i].hash]);
                  } else {
                    removeClass($element, activeClasses[states[i].hash]);
                  }
                  if (exactMatch(states[i].state, states[i].params)) {
                    addClass($element, activeEqClass);
                  } else {
                    removeClass($element, activeEqClass);
                  }
                }
              }
              function addClass(el, className) {
                $timeout(function() {
                  el.addClass(className);
                });
              }
              function removeClass(el, className) {
                el.removeClass(className);
              }
              function anyMatch(state, params) {
                return $state.includes(state.name, params);
              }
              function exactMatch(state, params) {
                return $state.is(state.name, params);
              }
            }]
          };
        }
        angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
      }, function(module, exports) {
        $IsStateFilter.$inject = ['$state'];
        function $IsStateFilter($state) {
          return function(state) {
            return $state.is(state);
          };
        }
        exports.$IsStateFilter = $IsStateFilter;
        $IncludedByStateFilter.$inject = ['$state'];
        function $IncludedByStateFilter($state) {
          return function(state, params, options) {
            return $state.includes(state, params, options);
          };
        }
        exports.$IncludedByStateFilter = $IncludedByStateFilter;
        angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
      }, function(module, exports, __webpack_require__) {
        var module_1 = __webpack_require__(2);
        var State = (function() {
          function State(config) {
            module_1.extend(this, config);
          }
          State.prototype.is = function(ref) {
            return this === ref || this.self === ref || this.fqn() === ref;
          };
          State.prototype.fqn = function() {
            if (!this.parent || !(this.parent instanceof this.constructor))
              return this.name;
            var name = this.parent.fqn();
            return name ? name + "." + this.name : this.name;
          };
          State.prototype.root = function() {
            return this.parent && this.parent.root() || this;
          };
          State.prototype.parameters = function(opts) {
            opts = module_1.defaults(opts, {inherit: true});
            var inherited = opts.inherit && this.parent && this.parent.parameters() || [];
            return inherited.concat(module_1.values(this.params));
          };
          State.prototype.parameter = function(id, opts) {
            if (opts === void 0) {
              opts = {};
            }
            return (this.url && this.url.parameter(id, opts) || module_1.find(module_1.values(this.params), module_1.propEq('id', id)) || opts.inherit && this.parent && this.parent.parameter(id));
          };
          State.prototype.toString = function() {
            return this.fqn();
          };
          return State;
        })();
        exports.State = State;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var StateMatcher = (function() {
          function StateMatcher(_states) {
            this._states = _states;
          }
          StateMatcher.prototype.isRelative = function(stateName) {
            stateName = stateName || "";
            return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
          };
          StateMatcher.prototype.find = function(stateOrName, base) {
            if (!stateOrName && stateOrName !== "")
              return undefined;
            var isStr = common_1.isString(stateOrName);
            var name = isStr ? stateOrName : stateOrName.name;
            if (this.isRelative(name))
              name = this.resolvePath(name, base);
            var state = this._states[name];
            if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
              return state;
            }
            return undefined;
          };
          StateMatcher.prototype.resolvePath = function(name, base) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            var baseState = this.find(base);
            var splitName = name.split("."),
                i = 0,
                pathLength = splitName.length,
                current = baseState;
            for (; i < pathLength; i++) {
              if (splitName[i] === "" && i === 0) {
                current = baseState;
                continue;
              }
              if (splitName[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            var relName = splitName.slice(i).join(".");
            return current.name + (current.name && relName ? "." : "") + relName;
          };
          return StateMatcher;
        })();
        exports.StateMatcher = StateMatcher;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var module_1 = __webpack_require__(12);
        var StateQueueManager = (function() {
          function StateQueueManager(states, builder, $urlRouterProvider, $state) {
            this.states = states;
            this.builder = builder;
            this.$urlRouterProvider = $urlRouterProvider;
            this.$state = $state;
            this.autoFlush = false;
            this.queue = [];
          }
          StateQueueManager.prototype.register = function(config, pre) {
            var _a = this,
                states = _a.states,
                queue = _a.queue,
                $state = _a.$state;
            var state = common_1.inherit(new module_1.State(), common_1.extend({}, config, {
              self: config,
              resolve: config.resolve || {},
              toString: function() {
                return config.name;
              }
            }));
            if (!common_1.isString(state.name))
              throw new Error("State must have a valid name");
            if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)
              throw new Error("State '" + state.name + "' is already defined");
            queue[pre ? "unshift" : "push"](state);
            if (this.autoFlush) {
              this.flush($state);
            }
            return state;
          };
          StateQueueManager.prototype.flush = function($state) {
            var _a = this,
                queue = _a.queue,
                states = _a.states,
                builder = _a.builder;
            var result,
                state,
                orphans = [],
                orphanIdx,
                previousQueueLength = {};
            while (queue.length > 0) {
              state = queue.shift();
              result = builder.build(state);
              orphanIdx = orphans.indexOf(state);
              if (result) {
                if (states.hasOwnProperty(state.name))
                  throw new Error("State '" + name + "' is already defined");
                states[state.name] = state;
                this.attachRoute($state, state);
                if (orphanIdx >= 0)
                  orphans.splice(orphanIdx, 1);
                continue;
              }
              var prev = previousQueueLength[state.name];
              previousQueueLength[state.name] = queue.length;
              if (orphanIdx >= 0 && prev === queue.length) {
                throw new Error("Cannot register orphaned state '" + state.name + "'");
              } else if (orphanIdx < 0) {
                orphans.push(state);
              }
              queue.push(state);
            }
            return states;
          };
          StateQueueManager.prototype.attachRoute = function($state, state) {
            var $urlRouterProvider = this.$urlRouterProvider;
            if (state[common_1.abstractKey] || !state.url)
              return;
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable !== state || !common_1.equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          };
          return StateQueueManager;
        })();
        exports.StateQueueManager = StateQueueManager;
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var trace_1 = __webpack_require__(6);
        var coreservices_1 = __webpack_require__(4);
        var rejectFactory_1 = __webpack_require__(28);
        var module_1 = __webpack_require__(12);
        var REJECT = new rejectFactory_1.RejectFactory();
        var defaultOptions = {
          async: true,
          rejectIfSuperseded: true,
          current: common_1.noop,
          transition: null,
          traceData: {}
        };
        var TransitionHook = (function() {
          function TransitionHook(fn, locals, resolveContext, options) {
            var _this = this;
            this.fn = fn;
            this.locals = locals;
            this.resolveContext = resolveContext;
            this.options = options;
            this.isSuperseded = function() {
              return _this.options.current() !== _this.options.transition;
            };
            this.mapHookResult = common_1.pattern([[this.isSuperseded, function() {
              return REJECT.superseded(_this.options.current());
            }], [common_1.eq(false), common_1.val(REJECT.aborted("Hook aborted transition"))], [common_1.is(module_1.TargetState), function(target) {
              return REJECT.redirected(target);
            }], [common_1.isPromise, function(promise) {
              return promise.then(_this.handleHookResult.bind(_this));
            }]]);
            this.invokeStep = function(moreLocals) {
              var _a = _this,
                  options = _a.options,
                  fn = _a.fn,
                  resolveContext = _a.resolveContext;
              var locals = common_1.extend({}, _this.locals, moreLocals);
              trace_1.trace.traceHookInvocation(_this, options);
              if (options.rejectIfSuperseded && _this.isSuperseded()) {
                return REJECT.superseded(options.current());
              }
              if (!options.async) {
                var hookResult = resolveContext.invokeNow(fn, locals, options);
                return _this.handleHookResult(hookResult);
              }
              return resolveContext.invokeLater(fn, locals, options).then(_this.handleHookResult.bind(_this));
            };
            this.options = common_1.defaults(options, defaultOptions);
          }
          TransitionHook.prototype.handleHookResult = function(hookResult) {
            if (!common_1.isDefined(hookResult))
              return undefined;
            trace_1.trace.traceHookResult(hookResult, undefined, this.options);
            var transitionResult = this.mapHookResult(hookResult);
            if (transitionResult)
              trace_1.trace.traceHookResult(hookResult, transitionResult, this.options);
            return transitionResult;
          };
          TransitionHook.prototype.toString = function() {
            var _a = this,
                options = _a.options,
                fn = _a.fn;
            var event = common_1.parse("traceData.hookType")(options) || "internal",
                context = common_1.parse("traceData.context.state.name")(options) || common_1.parse("traceData.context")(options) || "unknown",
                name = common_1.fnToString(fn);
            return event + " context: " + context + ", " + common_1.maxLength(200, name);
          };
          TransitionHook.runSynchronousHooks = function(hooks, locals, swallowExceptions) {
            if (locals === void 0) {
              locals = {};
            }
            if (swallowExceptions === void 0) {
              swallowExceptions = false;
            }
            var results = [];
            for (var i = 0; i < hooks.length; i++) {
              try {
                results.push(hooks[i].invokeStep(locals));
              } catch (exception) {
                if (!swallowExceptions)
                  throw exception;
                console.log("Swallowed exception during synchronous hook handler: " + exception);
              }
            }
            var rejections = results.filter(TransitionHook.isRejection);
            if (rejections.length)
              return rejections[0];
            return results.filter(common_1.not(TransitionHook.isRejection)).filter(common_1.isPromise).reduce(function(chain, promise) {
              return chain.then(common_1.val(promise));
            }, coreservices_1.services.$q.when());
          };
          TransitionHook.isRejection = function(hookResult) {
            return hookResult && hookResult.reason instanceof rejectFactory_1.TransitionRejection && hookResult;
          };
          return TransitionHook;
        })();
        exports.TransitionHook = TransitionHook;
      }, function(module, exports, __webpack_require__) {
        var transition_1 = __webpack_require__(8);
        var hookRegistry_1 = __webpack_require__(11);
        exports.defaultTransOpts = {
          location: true,
          relative: null,
          inherit: false,
          notify: true,
          reload: false,
          custom: {},
          current: function() {
            return null;
          }
        };
        var TransitionService = (function() {
          function TransitionService() {
            this._defaultErrorHandler = function $defaultErrorHandler($error$) {
              if ($error$ instanceof Error)
                console.log($error$);
            };
            this._reinit();
          }
          TransitionService.prototype.defaultErrorHandler = function(handler) {
            return this._defaultErrorHandler = handler || this._defaultErrorHandler;
          };
          TransitionService.prototype._reinit = function() {
            hookRegistry_1.HookRegistry.mixin(new hookRegistry_1.HookRegistry(), this);
          };
          TransitionService.prototype.create = function(fromPath, targetState) {
            return new transition_1.Transition(fromPath, targetState);
          };
          return TransitionService;
        })();
        exports.$transitions = new TransitionService();
        $TransitionProvider.prototype = exports.$transitions;
        function $TransitionProvider() {
          this._reinit.bind(exports.$transitions)();
          this.$get = function $get() {
            return exports.$transitions;
          };
        }
        exports.$transitionsProvider = $TransitionProvider;
        angular.module('ui.router.state').provider('$transitions', exports.$transitionsProvider);
      }, function(module, exports, __webpack_require__) {
        function __export(m) {
          for (var p in m)
            if (!exports.hasOwnProperty(p))
              exports[p] = m[p];
        }
        __export(__webpack_require__(50));
        __export(__webpack_require__(21));
        __export(__webpack_require__(51));
        __export(__webpack_require__(52));
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        $TemplateFactory.$inject = ['$http', '$templateCache'];
        function $TemplateFactory($http, $templateCache) {
          this.fromConfig = function(config, params, injectFn) {
            return (common_1.isDefined(config.template) ? this.fromString(config.template, params) : common_1.isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : common_1.isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, injectFn) : null);
          };
          this.fromString = function(template, params) {
            return common_1.isFunction(template) ? template(params) : template;
          };
          this.fromUrl = function(url, params) {
            if (common_1.isFunction(url))
              url = url(params);
            if (url == null)
              return null;
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(common_1.prop("data"));
          };
          this.fromProvider = function(provider, params, injectFn) {
            return injectFn(provider);
          };
        }
        angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      }, function(module, exports, __webpack_require__) {
        var common_1 = __webpack_require__(3);
        var trace_1 = __webpack_require__(6);
        $ViewDirective.$inject = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q'];
        function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {
          function getRenderer(attrs, scope) {
            return {
              enter: function(element, target, cb) {
                if (angular.version.minor > 2) {
                  $animate.enter(element, null, target).then(cb);
                } else {
                  $animate.enter(element, null, target, cb);
                }
              },
              leave: function(element, cb) {
                if (angular.version.minor > 2) {
                  $animate.leave(element).then(cb);
                } else {
                  $animate.leave(element, cb);
                }
              }
            };
          }
          function configsEqual(config1, config2) {
            return config1 === config2;
          }
          var rootData = {context: $view.rootContext()};
          var directive = {
            count: 0,
            restrict: 'ECA',
            terminal: true,
            priority: 400,
            transclude: 'element',
            compile: function(tElement, tAttrs, $transclude) {
              return function(scope, $element, attrs) {
                var previousEl,
                    currentEl,
                    currentScope,
                    unregister,
                    onloadExp = attrs.onload || '',
                    autoScrollExp = attrs.autoscroll,
                    renderer = getRenderer(attrs, scope),
                    viewConfig = undefined,
                    inherited = $element.inheritedData('$uiView') || rootData,
                    name = $interpolate(attrs.uiView || attrs.name || '')(scope) || '$default';
                var viewData = {
                  id: directive.count++,
                  name: name,
                  fqn: inherited.name ? inherited.fqn + "." + name : name,
                  config: null,
                  configUpdated: configUpdatedCallback,
                  get creationContext() {
                    return inherited.context;
                  }
                };
                trace_1.trace.traceUiViewEvent("Linking", viewData);
                function configUpdatedCallback(config) {
                  if (configsEqual(viewConfig, config))
                    return;
                  trace_1.trace.traceUiViewConfigUpdated(viewData, config && config.context);
                  viewConfig = config;
                  updateView(config);
                }
                $element.data('$uiView', viewData);
                updateView();
                unregister = $view.registerUiView(viewData);
                scope.$on("$destroy", function() {
                  trace_1.trace.traceUiViewEvent("Destroying/Unregistering", viewData);
                  unregister();
                });
                function cleanupLastView() {
                  if (previousEl) {
                    trace_1.trace.traceUiViewEvent("Removing    (previous) el", viewData);
                    previousEl.remove();
                    previousEl = null;
                  }
                  if (currentScope) {
                    trace_1.trace.traceUiViewEvent("Destroying  (previous) scope", viewData);
                    currentScope.$destroy();
                    currentScope = null;
                  }
                  if (currentEl) {
                    trace_1.trace.traceUiViewEvent("Animate out (previous)", viewData);
                    renderer.leave(currentEl, function() {
                      previousEl = null;
                    });
                    previousEl = currentEl;
                    currentEl = null;
                  }
                }
                function updateView(config) {
                  config = config || {};
                  var newScope = scope.$new();
                  trace_1.trace.traceUiViewScopeCreated(viewData, newScope);
                  common_1.extend(viewData, {
                    context: config.context,
                    $template: config.template,
                    $controller: config.controller,
                    $controllerAs: config.controllerAs,
                    $locals: config.locals
                  });
                  var cloned = $transclude(newScope, function(clone) {
                    renderer.enter(clone.data('$uiView', viewData), $element, function onUiViewEnter() {
                      if (currentScope) {
                        currentScope.$emit('$viewContentAnimationEnded');
                      }
                      if (common_1.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                        $uiViewScroll(clone);
                      }
                    });
                    cleanupLastView();
                  });
                  currentEl = cloned;
                  currentScope = newScope;
                  currentScope.$emit('$viewContentLoaded', config || viewConfig);
                  currentScope.$eval(onloadExp);
                }
              };
            }
          };
          return directive;
        }
        $ViewDirectiveFill.$inject = ['$compile', '$controller', '$interpolate', '$injector', '$q'];
        function $ViewDirectiveFill($compile, $controller, $interpolate, $injector, $q) {
          return {
            restrict: 'ECA',
            priority: -400,
            compile: function(tElement) {
              var initial = tElement.html();
              return function(scope, $element) {
                var data = $element.data('$uiView');
                if (!data)
                  return;
                $element.html(data.$template || initial);
                trace_1.trace.traceUiViewFill(data, $element.html());
                var link = $compile($element.contents());
                var controller = data.$controller;
                var controllerAs = data.$controllerAs;
                if (controller) {
                  var locals = data.$locals;
                  var controllerInstance = $controller(controller, common_1.extend(locals, {$scope: scope}));
                  if (controllerAs)
                    scope[controllerAs] = controllerInstance;
                  $element.data('$ngControllerController', controllerInstance);
                  $element.children().data('$ngControllerController', controllerInstance);
                }
                link(scope);
              };
            }
          };
        }
        angular.module('ui.router.state').directive('uiView', $ViewDirective);
        angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      }, function(module, exports) {
        function $ViewScrollProvider() {
          var useAnchorScroll = false;
          this.useAnchorScroll = function() {
            useAnchorScroll = true;
          };
          this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
            if (useAnchorScroll) {
              return $anchorScroll;
            }
            return function($element) {
              return $timeout(function() {
                $element[0].scrollIntoView();
              }, 0, false);
            };
          }];
        }
        angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      }]);
    });
    ;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-ui-router@1.0.0-alpha0", ["npm:angular-ui-router@1.0.0-alpha0/release/angular-ui-router"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-ui-router@1.0.0-alpha0/release/angular-ui-router');
  global.define = __define;
  return module.exports;
});

System.register('componentes/navegacion/navegacion.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2', 'npm:angular-ui-router@1.0.0-alpha0'], function (_export) {
    'use strict';

    var angular, angularMaterial, angularUiRouter, raiz, nombreComponente, configurarEstado;
    return {
        setters: [function (_npmAngular150Rc1) {
            angular = _npmAngular150Rc1;
        }, function (_npmAngularMaterial102) {
            angularMaterial = _npmAngularMaterial102;
        }, function (_npmAngularUiRouter100Alpha0) {
            angularUiRouter = _npmAngularUiRouter100Alpha0;
        }],
        execute: function () {
            raiz = "./componentes/";
            nombreComponente = 'navegacion';

            configurarEstado = function configurarEstado($stateProvider) {
                $stateProvider.state(nombreComponente, {
                    url: '/' + nombreComponente,
                    template: '<' + nombreComponente + '></' + nombreComponente + '>'
                });
            };

            angular.module(nombreComponente, ['ngMaterial', 'ui.router']).component(nombreComponente, {
                templateUrl: '' + raiz + nombreComponente + '/' + nombreComponente + '.html'
            }).config(configurarEstado);

            _export('default', nombreComponente);
        }
    };
});
System.register('main.js', ['npm:angular@1.5.0-rc.1', 'npm:angular-material@1.0.2', 'npm:angular-ui-router@1.0.0-alpha0', 'componentes/base/base.js', 'componentes/portada/portada.js', 'componentes/tarea/tarea.js', 'componentes/configuracion/configuracion.js', 'componentes/navegacion/navegacion.js'], function (_export) {
  'use strict';

  var angular, angularMaterial, angularUiRouter, base, portada, tarea, configuracion, navegacion, nombreApp, documentoHTML, iniciarApp;
  return {
    setters: [function (_npmAngular150Rc1) {
      angular = _npmAngular150Rc1;
    }, function (_npmAngularMaterial102) {
      angularMaterial = _npmAngularMaterial102;
    }, function (_npmAngularUiRouter100Alpha0) {
      angularUiRouter = _npmAngularUiRouter100Alpha0;
    }, function (_componentesBaseBaseJs) {
      base = _componentesBaseBaseJs['default'];
    }, function (_componentesPortadaPortadaJs) {
      portada = _componentesPortadaPortadaJs['default'];
    }, function (_componentesTareaTareaJs) {
      tarea = _componentesTareaTareaJs['default'];
    }, function (_componentesConfiguracionConfiguracionJs) {
      configuracion = _componentesConfiguracionConfiguracionJs['default'];
    }, function (_componentesNavegacionNavegacionJs) {
      navegacion = _componentesNavegacionNavegacionJs['default'];
    }],
    execute: function () {
      nombreApp = 'frontEdge';

      angular.module(nombreApp, ['ngMaterial', 'ui.router', base, portada, tarea, configuracion, navegacion]).config(function ($urlRouterProvider) {
        return $urlRouterProvider.otherwise('/');
      });

      documentoHTML = angular.element(document);

      iniciarApp = function iniciarApp() {
        return angular.bootstrap(documentoHTML, [nombreApp]);
      };

      documentoHTML.ready(iniciarApp);
    }
  };
});
//# sourceMappingURL=build.js.map